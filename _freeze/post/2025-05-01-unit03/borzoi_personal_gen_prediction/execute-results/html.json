{
  "hash": "6b02cba583e3e8c4827e971bafb90ee1",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Borzoi prediction from personal genome - qmd version\nauthor: Sofia Salazar\ndate: '2025-05-05'\ndescription: Using Borzoi for predicting on a personal genome, derived from VCF\nformat:\n  html:\n    code-fold: true\n    code-summary: Show the code\n    code-tools: true\n    code-overflow: wrap\neditor_options:\n  chunk_output_type: console\neval: false\ncategories:\n  - gene46100\n  - notebook\njupyter: python3\n---\n\n\n\n\n# Borzoi Personal Genome Prediction Tutorial\n\nThis notebook demonstrates how to use Borzoi, a deep learning model for predicting genomic regulatory activity, to analyze personal genome sequences. We'll learn how to:\n\n1. Set up the environment and install required packages\n2. Download and prepare model files and reference data\n3. Process personal genome data from VCF files\n4. Make predictions using Borzoi\n5. Visualize and interpret the results\n\n## 1. Environment Setup\n\nFirst, we need to set up our Python environment. Borzoi requires Python 3.10 or lower due to compatibility requirements.\n\n```\nconda create --name borzoi46100 python=3.10\n```\n\n::: {#197e2dae .cell execution_count=1}\n``` {.python .cell-code}\nimport os\nGITHUB_DIR = '/Users/haekyungim/Github'\n\n# clone baskerville and borzoi if not already cloned\nbaskerville_path = os.path.join(GITHUB_DIR, 'baskerville')\nborzoi_path = os.path.join(GITHUB_DIR, 'borzoi')\nif not os.path.exists(baskerville_path):\n    !git clone https://github.com/calico/baskerville.git {GITHUB_DIR}/baskerville\n\nif not os.path.exists(borzoi_path):\n    !git clone https://github.com/calico/borzoi.git {GITHUB_DIR}/borzoi\n```\n:::\n\n\n**After loading baskerville, restart runtime, run code from here**\n\nInstall libraries\n\n::: {#9dbc5366 .cell execution_count=2}\n``` {.python .cell-code}\ntry:\n    import baskerville\nexcept ImportError:\n    !pip install -e {GITHUB_DIR}/baskerville\n```\n:::\n\n\n::: {#97bc980f .cell execution_count=3}\n``` {.python .cell-code}\ntry:\n    import borzoi\nexcept ImportError:\n    !pip install -e {GITHUB_DIR}/borzoi\n```\n:::\n\n\nNOTE: install tensorflow-metal if running on a mac\n\n::: {#dc2a89e7 .cell execution_count=4}\n``` {.python .cell-code}\n# import platform\n# if platform.processor() == 'arm':\n#     print(\"Apple Silicon detected, installing tensorflow-metal...\")\n#     %pip install tensorflow-metal\n# else:\n#     print(\"Not running on Apple Silicon, skipping tensorflow-metal installation\")\n```\n:::\n\n\n### Load libraries\n\n::: {#cd832aa1 .cell execution_count=5}\n``` {.python .cell-code}\ntry:\n    import kipoiseq\nexcept ImportError:\n    %pip install kipoiseq\nfrom kipoiseq import Interval\ntry:\n    import cyvcf2\nexcept ImportError:\n    %pip install cyvcf2\nimport os\nimport time\nimport io\nimport gzip\n\n#os.environ['CUDA_VISIBLE_DEVICES'] = '-1'\n\nimport h5py\nimport numpy as np\nimport pandas as pd\nimport tensorflow as tf\n\nimport baskerville\nfrom baskerville import seqnn\nfrom baskerville import gene as bgene\nfrom baskerville import dna\n\nimport json\n\nimport pysam\n\nimport pyfaidx\n\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n```\n:::\n\n\n### Configure GPU device\n\n::: {#3bf0fba7 .cell execution_count=6}\n``` {.python .cell-code}\nprint(\"Num GPUs Available: \", len(tf.config.list_physical_devices('GPU')))\ngpu_device = tf.config.list_physical_devices('GPU')[0]\ntf.config.experimental.set_memory_growth(gpu_device, True)\n```\n:::\n\n\n### Dowload model files\n\n::: {#84953ddd .cell execution_count=7}\n``` {.python .cell-code}\nPRE = '/Users/haekyungim/Library/CloudStorage/Box-Box/LargeFiles/imlab-data/data-Github/web-data/web-GENE-46100'\nCONTENT_DIR = PRE + '/borzoi'\n# Create borzoi/data directory if it doesn't exist\nif not os.path.exists(os.path.join(CONTENT_DIR)):\n    !mkdir {CONTENT_DIR}\nif not os.path.exists(os.path.join(CONTENT_DIR, 'data')):\n    !mkdir {CONTENT_DIR}/data\n\n# Create model file structure\nsaved_models_path = os.path.join(CONTENT_DIR, 'data/saved_models')\nif not os.path.exists(saved_models_path):\n    !mkdir {saved_models_path}\nif not os.path.exists(os.path.join(saved_models_path, 'f0')):\n    !mkdir {saved_models_path}/f0\nif not os.path.exists(os.path.join(saved_models_path, 'f1')):\n    !mkdir {saved_models_path}/f1\nif not os.path.exists(os.path.join(saved_models_path, 'f2')):\n    !mkdir {saved_models_path}/f2\nif not os.path.exists(os.path.join(saved_models_path, 'f3')):\n    !mkdir {saved_models_path}/f3\n\n```\n:::\n\n\n::: {#5019c42e .cell execution_count=8}\n``` {.python .cell-code}\n#Download model weights\nif not os.path.exists(os.path.join(saved_models_path, 'f0', 'model0_best.h5')):\n    !wget https://storage.googleapis.com/seqnn-share/borzoi/f0/model0_best.h5 -O {saved_models_path}/f0/model0_best.h5\nif not os.path.exists(os.path.join(saved_models_path, 'f1', 'model0_best.h5')): \n    !wget https://storage.googleapis.com/seqnn-share/borzoi/f1/model0_best.h5 -O {saved_models_path}/f1/model0_best.h5\nif not os.path.exists(os.path.join(saved_models_path, 'f2', 'model0_best.h5')):\n    !wget https://storage.googleapis.com/seqnn-share/borzoi/f2/model0_best.h5 -O {saved_models_path}/f2/model0_best.h5\nif not os.path.exists(os.path.join(saved_models_path, 'f3', 'model0_best.h5')):\n    !wget https://storage.googleapis.com/seqnn-share/borzoi/f3/model0_best.h5 -O {saved_models_path}/f3/model0_best.h5\n```\n:::\n\n\n::: {#58702e34 .cell execution_count=9}\n``` {.python .cell-code}\n#Download and uncompress annotation files\nif not os.path.exists(os.path.join(CONTENT_DIR, 'data', 'gencode41_basic_nort.gtf')):\n    !wget  -O - https://storage.googleapis.com/seqnn-share/helper/gencode41_basic_nort.gtf.gz | gunzip -c > {os.path.join(CONTENT_DIR, 'data', 'gencode41_basic_nort.gtf')}\nif not os.path.exists(os.path.join(CONTENT_DIR, 'data', 'gencode41_basic_protein_splice.csv.gz')):\n    !wget https://storage.googleapis.com/seqnn-share/helper/gencode41_basic_protein_splice.csv.gz -O {os.path.join(CONTENT_DIR, 'data', 'gencode41_basic_protein_splice.csv.gz')}\nif not os.path.exists(os.path.join(CONTENT_DIR, 'data', 'polyadb_human_v3.csv.gz')):\n    !wget https://storage.googleapis.com/seqnn-share/helper/polyadb_human_v3.csv.gz -O {os. path.join(CONTENT_DIR, 'data', 'polyadb_human_v3.csv.gz')}\n```\n:::\n\n\n### Download reference genome\n\n::: {#a8f45dcb .cell execution_count=10}\n``` {.python .cell-code}\nfasta_file = os.path.join(CONTENT_DIR, 'data/hg38.fa')\nif not os.path.exists(fasta_file):\n    !wget -O - http://hgdownload.cse.ucsc.edu/goldenPath/hg38/bigZips/hg38.fa.gz | gunzip -c > {fasta_file}\n```\n:::\n\n\n::: {#f333d68a .cell execution_count=11}\n``` {.python .cell-code}\n### download vcf file and index for chromosome 22\nVCF_FILE = os.path.join(CONTENT_DIR, 'data/ALL.chr22.shapeit2_integrated_SNPs_v2a_27022019.GRCh38.phased.gz')\nif not os.path.exists(VCF_FILE):\n    !wget https://uchicago.box.com/shared/static/u526pjh29w93ufn65yomlch4z8lkb1sp.gz -O {VCF_FILE}\n```\n:::\n\n\n::: {#1109f319 .cell execution_count=12}\n``` {.python .cell-code}\n#!ls /content/data\n!ls {CONTENT_DIR}/data\n```\n:::\n\n\n::: {#67405221 .cell execution_count=13}\n``` {.python .cell-code}\n%cd {CONTENT_DIR}\n```\n:::\n\n\n#### Download htslib to index genome\n\n::: {#c2a0fd60 .cell execution_count=14}\n``` {.python .cell-code}\n# !wget https://github.com/samtools/htslib/releases/download/1.9/htslib-1.9.tar.bz2\n# !tar -vxjf htslib-1.9.tar.bz2\n# %cd htslib-1.9\n# !autoreconf -i\n# !./configure\n# !make\n# !make install\n```\n:::\n\n\n::: {#a4171752 .cell execution_count=15}\n``` {.python .cell-code}\n## if you Permission denied error on a mac, try\n# !brew install htslib\n```\n:::\n\n\n#### Index vcf\n\n::: {#7494bfd8 .cell execution_count=16}\n``` {.python .cell-code}\nif not os.path.exists(VCF_FILE + '.tbi'):\n    !tabix {VCF_FILE}\n```\n:::\n\n\n### Define paths\n\n::: {#b51bb809 .cell execution_count=17}\n``` {.python .cell-code}\nmodels_path = CONTENT_DIR + '/data/saved_models/'\nparams_file = GITHUB_DIR + '/borzoi/examples/params_pred.json'\ntargets_file = GITHUB_DIR + '/borzoi/examples/targets_human.txt'\n```\n:::\n\n\nLoad splice site annotation\n\n::: {#d6a2fe77 .cell execution_count=18}\n``` {.python .cell-code}\n# splice_df = pd.read_csv(CONTENT_DIR+'/data/gencode41_basic_protein_splice.csv.gz', sep='\\t', compression='gzip')\n# print(\"len(splice_df) = \" + str(len(splice_df)))\n```\n:::\n\n\nLoad transcriptome\n\n::: {#599efe61 .cell execution_count=19}\n``` {.python .cell-code}\ntranscriptome = bgene.Transcriptome(CONTENT_DIR + '/data/gencode41_basic_nort.gtf')\n```\n:::\n\n\n## 2. Define functions\n\n#### FastaStringExtractor\nFrom reference seq fasta:\n- Indexes ref sequence\n- Gets chromosome sizes into a dictionary\n\nExtract function:\n- gets target chromosome length from kipoiseq interval and chr sizes dictionary\n- truncates interval if it extends beyond chromosome lengths\n- extracts sequence\n\n#### make_seq_1hot\n- one hot encodes given sequence\n\n#### predict_tracks\n- makes prediction of ALL tracks given an encoded sequence\n\n::: {#19c8b445 .cell execution_count=20}\n``` {.python .cell-code}\nclass FastaStringExtractor:\n\n    def __init__(self, fasta_file):\n        self.fasta = pyfaidx.Fasta(fasta_file)\n        self._chromosome_sizes = {k: len(v) for k, v in self.fasta.items()}\n    #import pd.Interval as Interval\n\n    def extract(self, interval: Interval, **kwargs) -> str:\n        # Truncate interval if it extends beyond the chromosome lengths.\n        chromosome_length = self._chromosome_sizes[interval.chrom]\n        trimmed_interval = Interval(interval.chrom,\n                                    max(interval.start, 0),\n                                    min(interval.end, chromosome_length),\n                                    )\n        # pyfaidx wants a 1-based interval\n        sequence = str(self.fasta.get_seq(trimmed_interval.chrom,\n                                          trimmed_interval.start + 1,\n                                          trimmed_interval.stop).seq).upper()\n        # Fill truncated values with N's.\n        pad_upstream = 'N' * max(-interval.start, 0)\n        pad_downstream = 'N' * max(interval.end - chromosome_length, 0)\n        return pad_upstream + sequence + pad_downstream # returns padded sequence\n\n    def close(self):\n        return self.fasta.close()\n```\n:::\n\n\n::: {#ecd2ab92 .cell execution_count=21}\n``` {.python .cell-code}\n# Make one-hot coded sequence (modified from borzoi)\ndef make_seq_1hot(sequence):\n    return dna.dna_1hot(sequence).astype(\"float32\")\n\ndef predict_tracks(models, sequence_one_hot):\n\n  predicted_tracks = []\n  for fold_ix in range(len(models)):\n\n    yh = models[fold_ix](sequence_one_hot[None, ...])[:, None, ...].astype(\"float16\")\n\n    predicted_tracks.append(yh)\n\n  predicted_tracks = np.concatenate(predicted_tracks, axis=1)\n\n  return predicted_tracks\n```\n:::\n\n\n#### vcf_to_seq_faster\n- Modifies ref sequence to personal sequence given the vcf\n\n::: {#38ae7648 .cell execution_count=22}\n``` {.python .cell-code}\ndef vcf_to_seq_faster(target_interval, individual, vcf_file, fasta_extractor):\n  # target_inverval is a kipoiseq interval, e.g. kipoiseq.Interval(\"chr22\", 18118779, 18145669)\n  # individual is the id of the individual in the vcf file\n\n  target_fa = fasta_extractor.extract(target_interval.resize(SEQUENCE_LENGTH))\n  window_coords = target_interval.resize(SEQUENCE_LENGTH)\n      # two haplotypes per individual\n  haplo_1 = list(target_fa[:])\n  haplo_2 = list(target_fa[:])\n\n  # Open the VCF file\n  vcf_reader = cyvcf2.VCF(vcf_file)\n\n  # Specific genomic region\n  CHROM = window_coords.chrom\n  START = max(1,window_coords.start)\n  END = min(window_coords.end, fasta_extractor._chromosome_sizes[CHROM]-1)\n\n  count1 = 0\n  count2 = 0\n\n  # Iterate through variants in the specified region\n  for variant in vcf_reader(CHROM + ':' + str(START) + '-' + str(END)):\n      # Access the individual's genotype using index (0-based) of the sample\n      individual_index = vcf_reader.samples.index(individual)\n      genotype = variant.genotypes[individual_index]\n      ALT=variant.ALT[0]\n      REF=variant.REF\n      POS=variant.POS\n      if REF == target_fa[POS - window_coords.start - 1]:\n        if genotype[0] == 1:\n          haplo_1[POS - window_coords.start - 1] = ALT\n          count1 = count1 + 1\n        if genotype[1] == 1:\n          haplo_2[POS - window_coords.start - 1] = ALT\n          count2 = count2 + 1\n      else:\n        print(\"ERROR: REF in vcf \"+ REF + \"!= REF from the build\" + target_fa[POS - window_coords.start - 1])\n  print(\"number of changes haplo1:\")\n  print(count1)\n  print(\"number of changes haplo2:\")\n  print(count2)\n  return haplo_1, haplo_2\n```\n:::\n\n\n#### make_prediction function\n\n::: {#7c52a22c .cell execution_count=23}\n``` {.python .cell-code}\ndef make_prediction(gene, interval, haplo, sequence_one_hot, window = 131072): # snp_pos, alt_allele\n    with tf.device('/GPU:0'):\n        search_gene = gene # gene to predict\n\n        resized_interval = interval.resize(SEQUENCE_LENGTH)\n        start = resized_interval.start\n        end = resized_interval.end\n        center_pos = start + SEQUENCE_LENGTH//2 # figure center position\n\n        chrom = resized_interval.chr # chromosome\n\n        #Get exon bin range\n        gene_keys = [gene_key for gene_key in transcriptome.genes.keys() if search_gene in gene_key]\n\n        gene = transcriptome.genes[gene_keys[0]]\n\n        #Determine output sequence start\n        seq_out_start = start + seqnn_model.model_strides[0]*seqnn_model.target_crops[0]\n        seq_out_len = seqnn_model.model_strides[0]*seqnn_model.target_lengths[0]\n\n        #Determine output positions of gene exons\n        gene_slice = gene.output_slice(seq_out_start, seq_out_len, seqnn_model.model_strides[0], False)\n\n        #Make predictions\n        #y_wt\n        return predict_tracks(models, sequence_one_hot)\n```\n:::\n\n\n#### Get indexes of tracks function\n\n::: {#608e358b .cell execution_count=24}\n``` {.python .cell-code}\n# Get indexes of track\ndef get_track_idx(tracks):\n  track_idx = []\n  targets_df['local_index'] = np.arange(len(targets_df))\n  for track in tracks:\n    track_idx.append(targets_df.loc[targets_df['description'] == track]['local_index'].tolist())\n  return track_idx\n```\n:::\n\n\n#### Plot tracks function\n\n::: {#bc257989 .cell execution_count=25}\n``` {.python .cell-code}\ndef plot_tracks(prediction, interval, haplo, anno_df=None, tracks=[],\n                log = [False, False, False],\n                sqrt_scale = [False, False, False]):\n  # Gene slice not included\n  bin_size = 32\n  pad = 16\n\n  resized_interval = interval.resize(SEQUENCE_LENGTH)\n  start = resized_interval.start\n  end = resized_interval.end\n  center_pos = start + SEQUENCE_LENGTH//2 # figure center position\n  window=131072\n\n  plot_start = center_pos - window // 2\n  plot_end = center_pos + window // 2\n\n  plot_start_bin = (plot_start - start) // bin_size - pad\n  plot_end_bin = (plot_end - start) // bin_size - pad\n\n  track_idx = get_track_idx(tracks)\n  track_scales = [0.01, 0.01, 0.01]\n  track_transforms = [3./4., 3./4., 3./4.]\n  soft_clips = [384., 384., 384.]\n\n  # Get annotation positions\n  anno_poses = []\n  if anno_df is not None:\n      anno_poses = anno_df.query(\n          \"chrom == '\"\n          + interval.chr\n          + \"' and position_hg38 >= \"\n          + str(plot_start)\n          + \" and position_hg38 < \"\n          + str(plot_end)\n        )[\"position_hg38\"].values.tolist()\n  # BIG plot\n  fig, axes = plt.subplots(len(tracks), figsize=(20, 1.5 * len(tracks)), sharex = True)\n\n  for ax, track, track_index, track_scale, track_transform, clip_soft in zip(axes,\n        tracks, track_idx, track_scales, track_transforms, soft_clips):\n    # Plot track densities\n    y = np.array(np.copy(prediction), dtype = np.float32)\n    y = np.mean(y[..., track_index], axis=(0, 1, 3))\n    y = y[plot_start_bin:plot_end_bin]\n    signal = np.max(y)\n    if log:\n      y = np.log2(y + 1.0)\n    elif sqrt_scale:\n      y = np.sqrt(y + 1.0)\n\n    max_y = np.max(y)\n    print(\"Max signal for \"+ str(track) + \" = \" + str(round(signal, 4)))\n    print(\"Max transformed signal for \"+ str(track) + \" = \" + str(round(max_y, 4)))\n    print(\"---\")\n    ax.bar(np.arange(plot_end_bin - plot_start_bin) + plot_start_bin,\n            y,\n            width=1.0,\n            color=\"green\",\n            alpha=0.5)\n            # label=\"Prediction\",)\n    # X axis tick annotations\n    xtick_vals = []\n    for _, anno_pos in enumerate(anno_poses):\n      pas_bin = int((anno_pos - start) // 32) - 16\n      xtick_vals.append(pas_bin)\n      bin_end = pas_bin + 3 - 0.5\n      bin_start = bin_end - 5\n\n      ax.axvline(x=pas_bin,\n                color=\"cyan\",\n                linewidth=2,\n                alpha=0.5,\n                linestyle=\"-\",\n                zorder=-1,)\n\n    plt.xlim(plot_start_bin, plot_end_bin - 1)\n    plt.xticks([], [])\n    plt.yticks([], [])\n\n    ax.set(ylabel = \"Signal(log)\" if log else \"Signal\")# , fontsize = 8)\n    ax.set_title(\"Track: \" + str(track)+ \" in \"+ str(haplo), fontsize=10)\n    # plt.legend(fontsize=8)\n    plt.tight_layout()\n  ax.set_xlabel(\n            interval.chr\n            + \":\"\n            + str(plot_start)\n            + \"-\"\n            + str(plot_end)\n            + \" (\"\n            + str(window)\n            + \"bp window)\")\n            # fontsize=8,)\n  plt.show()\n```\n:::\n\n\n### Extract fasta\n\n::: {#5a102b63 .cell execution_count=26}\n``` {.python .cell-code}\nfasta_extractor = FastaStringExtractor(fasta_file)\n```\n:::\n\n\n## 3.Model configuration\n\n::: {#72cf9efd .cell execution_count=27}\n``` {.python .cell-code}\nSEQUENCE_LENGTH = 524288\n#n_folds = 4       #To use only one model fold, change to 'n_folds = 1'\nn_folds = 1       #To use only one model fold, change to 'n_folds = 1'\nrc = True         #Average across reverse-complement prediction\n\n#Read model parameters\n\nwith open(params_file) as params_open :\n\n    params = json.load(params_open)\n\n    params_model = params['model']\n    params_train = params['train']\n\n#Read targets\n\ntargets_df = pd.read_csv(targets_file, index_col=0, sep='\\t')\ntarget_index = targets_df.index\n\n#Create local index of strand_pair (relative to sliced targets)\nif rc :\n    strand_pair = targets_df.strand_pair\n\n    target_slice_dict = {ix : i for i, ix in enumerate(target_index.values.tolist())}\n    slice_pair = np.array([\n        target_slice_dict[ix] if ix in target_slice_dict else ix for ix in strand_pair.values.tolist()\n    ], dtype='int32')\n    \n\n#Initialize model ensemble\n\nmodels = []\nfor fold_ix in range(n_folds) :\n\n    model_file = models_path + \"f\" + str(fold_ix) + \"/model0_best.h5\"\n\n    seqnn_model = seqnn.SeqNN(params_model)\n    seqnn_model.restore(model_file, 0)\n    seqnn_model.build_slice(target_index)\n    if rc :\n        seqnn_model.strand_pair.append(slice_pair)\n    #seqnn_model.build_ensemble(rc, '0')\n    seqnn_model.build_ensemble(rc, [0])\n\n    models.append(seqnn_model)\n```\n:::\n\n\n## 4. Build sequence\n\n::: {#a426af04 .cell execution_count=28}\n``` {.python .cell-code}\n# read VCFs and encode haplotypes\nCHROM = 'chr22'\nvcf_file = CONTENT_DIR + \"/data/ALL.\" + CHROM + \".shapeit2_integrated_SNPs_v2a_27022019.GRCh38.phased.gz\"\ntarget_interval = kipoiseq.Interval(CHROM, 18118779, 18145669)\nhaplo1, haplo2 = vcf_to_seq_faster(target_interval, 'HG00097', vcf_file, fasta_extractor)\nhaplo0 = fasta_extractor.extract(target_interval.resize(SEQUENCE_LENGTH)) # ref seq\n\n# removed extra dimension as input layer is of shape=(None, 524288, 4)\nhaplo1_enc = make_seq_1hot(\"\".join(haplo1))\nhaplo2_enc = make_seq_1hot(\"\".join(haplo2))\nhaplo0_enc = make_seq_1hot(\"\".join(haplo0))\n```\n:::\n\n\n## 5. Predict\n\nENSG00000099968\n\n::: {#ea407d5f .cell execution_count=29}\n``` {.python .cell-code}\nsequences = [haplo0_enc, haplo1_enc, haplo2_enc]\nmy_tracks = ['CAGE:B lymphoblastoid cell line: GM12878 ENCODE, biol_',\n                          'DNASE:CD14-positive monocyte female',\n                          'RNA:blood']\n```\n:::\n\n\n::: {#c5505839 .cell execution_count=30}\n``` {.python .cell-code}\nfor h in range(0, len(sequences)):\n  haplotypes = [\"Reference\", \"Haplotype 1\", \"Haplotype 2\"]\n  prediction = make_prediction(gene = 'ENSG00000099968', interval = target_interval,\n                               haplo = haplotypes[h], sequence_one_hot=sequences[h])\n  print(haplotypes[h])\n  plot_tracks(prediction, interval = target_interval, haplo = haplotypes[h],\n              tracks = my_tracks, log = [True, True, False])\n```\n:::\n\n\n::: {#bbabd5ff .cell execution_count=31}\n``` {.python .cell-code}\nprediction.shape\n```\n:::\n\n\n## Technical Details\n\n### Model Architecture\nBorzoi is a deep learning model that:\n- Takes DNA sequences as input (one-hot encoded)\n- Uses a convolutional neural network architecture and transformer layers\n- Predicts multiple genomic features simultaneously\n- Can identify regulatory elements and their activity levels\n\n### Key Parameters\n- `SEQUENCE_LENGTH`: 524,288 bp (512 kb) - the size of genomic windows processed\n- `n_folds`: 4 - number of model replicates for ensemble predictions\n- `rc`: True - whether to average predictions from forward and reverse complement sequences\n\n### Data Requirements\n1. Reference Genome (hg38):\n   - Used as baseline for sequence comparison\n   - Required for proper variant mapping\n\n2. VCF File:\n   - Contains personal genome variants\n   - Must be phased for haplotype analysis\n   - Should be properly indexed\n\n3. Annotation Files:\n   - GTF file for gene annotations\n   - Additional files for specific features (CAGE, DNase, etc.)\n\n### Prediction Workflow\n1. Sequence Extraction:\n   - Extract reference sequence for target region\n   - Modify sequence based on personal variants\n   - Generate two haplotypes\n\n2. Model Input:\n   - Convert sequences to one-hot encoding\n   - Process in 512kb windows\n   - Handle sequence padding and truncation\n\n3. Prediction:\n   - Run through model ensemble\n   - Average predictions across folds\n   - Generate tissue-specific predictions\n\n4. Visualization:\n   - Plot predictions for each haplotype\n   - Compare with reference sequence\n   - Highlight significant differences\n\n",
    "supporting": [
      "borzoi_personal_gen_prediction_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}