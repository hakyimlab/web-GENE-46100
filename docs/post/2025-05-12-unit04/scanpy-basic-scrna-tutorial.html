<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="scanpy authors">
<meta name="dcterms.date" content="2025-05-12">

<title>scanpy tutorial - qmd – GENE 46100</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-30950e57ca2d683c179b59b95dd53cbb.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">GENE 46100</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#preprocessing-and-clustering" id="toc-preprocessing-and-clustering" class="nav-link active" data-scroll-target="#preprocessing-and-clustering">Preprocessing and clustering</a>
  <ul class="collapse">
  <li><a href="#quality-control" id="toc-quality-control" class="nav-link" data-scroll-target="#quality-control">Quality Control</a>
  <ul class="collapse">
  <li><a href="#doublet-detection" id="toc-doublet-detection" class="nav-link" data-scroll-target="#doublet-detection">Doublet detection</a></li>
  </ul></li>
  <li><a href="#normalization" id="toc-normalization" class="nav-link" data-scroll-target="#normalization">Normalization</a></li>
  <li><a href="#feature-selection" id="toc-feature-selection" class="nav-link" data-scroll-target="#feature-selection">Feature selection</a></li>
  <li><a href="#dimensionality-reduction" id="toc-dimensionality-reduction" class="nav-link" data-scroll-target="#dimensionality-reduction">Dimensionality Reduction</a></li>
  <li><a href="#visualization" id="toc-visualization" class="nav-link" data-scroll-target="#visualization">Visualization</a></li>
  <li><a href="#clustering" id="toc-clustering" class="nav-link" data-scroll-target="#clustering">Clustering</a></li>
  <li><a href="#re-assess-quality-control-and-cell-filtering" id="toc-re-assess-quality-control-and-cell-filtering" class="nav-link" data-scroll-target="#re-assess-quality-control-and-cell-filtering">Re-assess quality control and cell filtering</a></li>
  <li><a href="#cell-type-annotation" id="toc-cell-type-annotation" class="nav-link" data-scroll-target="#cell-type-annotation">Cell-type annotation</a>
  <ul class="collapse">
  <li><a href="#marker-gene-set" id="toc-marker-gene-set" class="nav-link" data-scroll-target="#marker-gene-set">Marker gene set</a></li>
  <li><a href="#automatic-label-prediction" id="toc-automatic-label-prediction" class="nav-link" data-scroll-target="#automatic-label-prediction">Automatic label prediction</a></li>
  <li><a href="#annotation-with-enrichment-analysis" id="toc-annotation-with-enrichment-analysis" class="nav-link" data-scroll-target="#annotation-with-enrichment-analysis">Annotation with enrichment analysis</a></li>
  <li><a href="#differentially-expressed-genes-as-markers" id="toc-differentially-expressed-genes-as-markers" class="nav-link" data-scroll-target="#differentially-expressed-genes-as-markers">Differentially-expressed Genes as Markers</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">scanpy tutorial - qmd</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
  <div class="quarto-categories">
    <div class="quarto-category">notebook</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>scanpy authors </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 12, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>This notebook is not compatible with this python 3.12. Some issues with pickle data and celltypist.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="in">```{bash}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">conda</span> create <span class="at">--name</span> scanpy-tutorial python=3.9</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">conda</span> activate scanpy-tutorial</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ex">conda</span> install nb_conda_kernels jupyter_server</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install nbclient nbformat</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="98a58fa6" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># set first time to False to avoid multiple downloads</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>first_time <span class="op">=</span> <span class="va">False</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(first_time)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>False</code></pre>
</div>
</div>
<section id="preprocessing-and-clustering" class="level1">
<h1>Preprocessing and clustering</h1>
<div id="ad50de2b" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> anndata <span class="im">as</span> ad</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install anndata</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> anndata <span class="im">as</span> ad</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> pooch</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install pooch</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> pooch</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> scanpy <span class="im">as</span> sc</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install scanpy</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> scanpy <span class="im">as</span> sc</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> scrublet</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install scrublet</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> scrublet</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> skimage </span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install scikit<span class="op">-</span>image</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> skimage</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> igraph</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install igraph</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> igraph</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="7eaca72f" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>sc.settings.set_figure_params(dpi<span class="op">=</span><span class="dv">50</span>, facecolor<span class="op">=</span><span class="st">"white"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The data used in this basic preprocessing and clustering tutorial was collected from bone marrow mononuclear cells of healthy human donors and was part of <a href="https://openproblems.bio/competitions/neurips_2021/">openproblem’s NeurIPS 2021 benchmarking dataset</a> {cite}<code>luecken2021</code>. The samples used in this tutorial were measured using the 10X Multiome Gene Expression and Chromatin Accessability kit.</p>
<p>We are reading in the count matrix into an <a href="https://anndata.readthedocs.io/en/latest/tutorials/notebooks/getting-started.html">AnnData</a> object, which holds many slots for annotations and different representations of the data.</p>
<div id="825ef6d2" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>EXAMPLE_DATA <span class="op">=</span> pooch.create(</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    path<span class="op">=</span>pooch.os_cache(<span class="st">"scverse_tutorials"</span>),</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    base_url<span class="op">=</span><span class="st">"doi:10.6084/m9.figshare.22716739.v1/"</span>,</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>EXAMPLE_DATA.load_registry_from_doi()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="ca603a0b" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"s1d1"</span>: <span class="st">"s1d1_filtered_feature_bc_matrix.h5"</span>,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"s1d3"</span>: <span class="st">"s1d3_filtered_feature_bc_matrix.h5"</span>,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>adatas <span class="op">=</span> {}</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sample_id, filename <span class="kw">in</span> samples.items():</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> EXAMPLE_DATA.fetch(filename)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    sample_adata <span class="op">=</span> sc.read_10x_h5(path)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    sample_adata.var_names_make_unique()</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    adatas[sample_id] <span class="op">=</span> sample_adata</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>adata <span class="op">=</span> ad.concat(adatas, label<span class="op">=</span><span class="st">"sample"</span>)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>adata.obs_names_make_unique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/Users/haekyungim/miniconda3/envs/scanpy-tutorial/lib/python3.9/site-packages/anndata/_core/anndata.py:1756: UserWarning: Variable names are not unique. To make them unique, call `.var_names_make_unique`.
  utils.warn_names_duplicates("var")
/Users/haekyungim/miniconda3/envs/scanpy-tutorial/lib/python3.9/site-packages/anndata/_core/anndata.py:1756: UserWarning: Variable names are not unique. To make them unique, call `.var_names_make_unique`.
  utils.warn_names_duplicates("var")
/Users/haekyungim/miniconda3/envs/scanpy-tutorial/lib/python3.9/site-packages/anndata/_core/anndata.py:1756: UserWarning: Variable names are not unique. To make them unique, call `.var_names_make_unique`.
  utils.warn_names_duplicates("var")
/Users/haekyungim/miniconda3/envs/scanpy-tutorial/lib/python3.9/site-packages/anndata/_core/anndata.py:1756: UserWarning: Variable names are not unique. To make them unique, call `.var_names_make_unique`.
  utils.warn_names_duplicates("var")
/Users/haekyungim/miniconda3/envs/scanpy-tutorial/lib/python3.9/site-packages/anndata/_core/anndata.py:1754: UserWarning: Observation names are not unique. To make them unique, call `.obs_names_make_unique`.
  utils.warn_names_duplicates("obs")</code></pre>
</div>
</div>
<p>The data contains 8,785 cells and 36,601 measured genes. This tutorial includes a basic preprocessing and clustering workflow.</p>
<section id="quality-control" class="level2">
<h2 class="anchored" data-anchor-id="quality-control">Quality Control</h2>
<p>The scanpy function {func}<code>~scanpy.pp.calculate_qc_metrics</code> calculates common quality control (QC) metrics, which are largely based on <code>calculateQCMetrics</code> from scater {cite}<code>McCarthy2017</code>. One can pass specific gene population to {func}<code>~scanpy.pp.calculate_qc_metrics</code> in order to calculate proportions of counts for these populations. Mitochondrial, ribosomal and hemoglobin genes are defined by distinct prefixes as listed below.</p>
<div id="46cba2fe" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># mitochondrial genes</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>adata.var[<span class="st">"mt"</span>] <span class="op">=</span> adata.var_names.<span class="bu">str</span>.startswith(<span class="st">"MT-"</span>)  <span class="co"># "MT-" for human, "Mt-" for mouse</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ribosomal genes</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>adata.var[<span class="st">"ribo"</span>] <span class="op">=</span> adata.var_names.<span class="bu">str</span>.startswith((<span class="st">"RPS"</span>, <span class="st">"RPL"</span>))</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co"># hemoglobin genes</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>adata.var[<span class="st">"hb"</span>] <span class="op">=</span> adata.var_names.<span class="bu">str</span>.contains(<span class="st">"^HB[^(P)]"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="ae67c358" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>sc.pp.calculate_qc_metrics(adata, qc_vars<span class="op">=</span>[<span class="st">"mt"</span>, <span class="st">"ribo"</span>, <span class="st">"hb"</span>], inplace<span class="op">=</span><span class="va">True</span>, log1p<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>One can now inspect violin plots of some of the computed QC metrics:</p>
<ul>
<li>the number of genes expressed in the count matrix</li>
<li>the total counts per cell</li>
<li>the percentage of counts in mitochondrial genes</li>
</ul>
<div id="33261a47" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>sc.pl.violin(adata, [<span class="st">"n_genes_by_counts"</span>, <span class="st">"total_counts"</span>, <span class="st">"pct_counts_mt"</span>], jitter<span class="op">=</span><span class="fl">0.4</span>, multi_panel<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-9-output-1.png" width="751" height="238" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Additionally, it is useful to consider QC metrics jointly by inspecting a scatter plot colored by <code>pct_counts_mt</code>.</p>
<div id="ad0fcd3b" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>sc.pl.scatter(adata, <span class="st">"total_counts"</span>, <span class="st">"n_genes_by_counts"</span>, color<span class="op">=</span><span class="st">"pct_counts_mt"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-10-output-1.png" width="209" height="198" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Based on the QC metric plots, one could now remove cells that have too many mitochondrial genes expressed or too many total counts by setting manual or automatic thresholds. However, it proved to be beneficial to apply a very permissive filtering strategy in the beginning for your single-cell analysis and filter low quality cells during clustering or revisit the filtering again at a later point. We therefore now only filter cells with less than 100 genes expressed and genes that are detected in less than 3 cells.</p>
<p>Additionally, it is important to note that for datasets with multiple batches, quality control should be performed for each sample individually as quality control thresholds can very substantially between batches.</p>
<div id="ede26145" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>sc.pp.filter_cells(adata, min_genes<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>sc.pp.filter_genes(adata, min_cells<span class="op">=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="doublet-detection" class="level3">
<h3 class="anchored" data-anchor-id="doublet-detection">Doublet detection</h3>
<p>As a next step, we run a doublet detection algorithm. Identifying doublets is crucial as they can lead to misclassifications or distortions in downstream analysis steps. Scanpy contains the doublet detection method Scrublet {cite}<code>Wolock2019</code>. Scrublet predicts cell doublets using a nearest-neighbor classifier of observed transcriptomes and simulated doublets. {func}<code>scanpy.pp.scrublet</code> adds <code>doublet_score</code> and <code>predicted_doublet</code> to <code>.obs</code>. One can now either filter directly on <code>predicted_doublet</code> or use the <code>doublet_score</code> later during clustering to filter clusters with high doublet scores.</p>
<div id="cc2245f6" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>sc.pp.scrublet(adata, batch_key<span class="op">=</span><span class="st">"sample"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="{seealso}">
<p>Alternative methods for doublet detection within the scverse ecosystem are <a href="https://github.com/JonathanShor/DoubletDetection">DoubletDetection</a> and <a href="https://docs.scvi-tools.org/en/stable/user_guide/models/solo.html">SOLO</a>. You can read more about these in the <a href="https://www.sc-best-practices.org/preprocessing_visualization/quality_control.html#doublet-detection">Doublet Detection chapter</a> of Single Cell Best Practices.</p>
</div>
</section>
</section>
<section id="normalization" class="level2">
<h2 class="anchored" data-anchor-id="normalization">Normalization</h2>
<p>The next preprocessing step is normalization. A common approach is count depth scaling with subsequent log plus one (log1p) transformation. Count depth scaling normalizes the data to a “size factor” such as the median count depth in the dataset, ten thousand (CP10k) or one million (CPM, counts per million). The size factor for count depth scaling can be controlled via <code>target_sum</code> in <code>pp.normalize_total</code>. We are applying median count depth normalization with log1p transformation (AKA log1PF).</p>
<div id="40ec40e5" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Saving count data</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>adata.layers[<span class="st">"counts"</span>] <span class="op">=</span> adata.X.copy()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="f816ebdc" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Normalizing to median total counts</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>sc.pp.normalize_total(adata)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Logarithmize the data:</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>sc.pp.log1p(adata)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="feature-selection" class="level2">
<h2 class="anchored" data-anchor-id="feature-selection">Feature selection</h2>
<p>As a next step, we want to reduce the dimensionality of the dataset and only include the most informative genes. This step is commonly known as feature selection. The scanpy function <code>pp.highly_variable_genes</code> annotates highly variable genes by reproducing the implementations of Seurat {cite}<code>Satija2015</code>, Cell Ranger {cite}<code>Zheng2017</code>, and Seurat v3 {cite}<code>stuart2019comprehensive</code> depending on the chosen <code>flavor</code>.</p>
<div id="4522aa8d" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>sc.pp.highly_variable_genes(adata, n_top_genes<span class="op">=</span><span class="dv">2000</span>, batch_key<span class="op">=</span><span class="st">"sample"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="1478a089" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>sc.pl.highly_variable_genes(adata)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-16-output-1.png" width="357" height="187" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="dimensionality-reduction" class="level2">
<h2 class="anchored" data-anchor-id="dimensionality-reduction">Dimensionality Reduction</h2>
<p>Reduce the dimensionality of the data by running principal component analysis (PCA), which reveals the main axes of variation and denoises the data.</p>
<div id="d3af7e7e" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>sc.tl.pca(adata)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let us inspect the contribution of single PCs to the total variance in the data. This gives us information about how many PCs we should consider in order to compute the neighborhood relations of cells, e.g.&nbsp;used in the clustering function {func}<code>~scanpy.tl.leiden</code> or {func}<code>~scanpy.tl.tsne</code>. In our experience, often a rough estimate of the number of PCs does fine.</p>
<div id="abe542e3" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>sc.pl.pca_variance_ratio(adata, n_pcs<span class="op">=</span><span class="dv">50</span>, log<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-18-output-1.png" width="183" height="200" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="visualization" class="level2">
<h2 class="anchored" data-anchor-id="visualization">Visualization</h2>
<p>Let us compute the neighborhood graph of cells using the PCA representation of the data matrix.</p>
<div id="3d638a63" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>sc.pp.neighbors(adata)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/Users/haekyungim/miniconda3/envs/scanpy-tutorial/lib/python3.9/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html
  from .autonotebook import tqdm as notebook_tqdm</code></pre>
</div>
</div>
<p>We suggest embedding the graph in two dimensions using UMAP (McInnes et al., 2018), see below.</p>
<div id="5e889de7" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>sc.tl.umap(adata)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can now visualize the UMAP according to the <code>sample</code>.</p>
<div id="712c8ab0" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(adata, color<span class="op">=</span><span class="st">"sample"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-21-output-1.png" width="216" height="184" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Even though the data considered in this tutorial includes two different samples, we only observe a minor batch effect and we can continue with clustering and annotation of our data.</p>
<p>If you inspect batch effects in your UMAP it can be beneficial to integrate across samples and perform batch correction/integration.</p>
</section>
<section id="clustering" class="level2">
<h2 class="anchored" data-anchor-id="clustering">Clustering</h2>
<p>As with Seurat and many other frameworks, we recommend the Leiden graph-clustering method (community detection based on optimizing modularity) {cite}<code>traag2019louvain</code>. Note that Leiden clustering directly clusters the neighborhood graph of cells, which we already computed in the previous section.</p>
<div id="59577a1a" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>sc.tl.leiden(adata, flavor<span class="op">=</span><span class="st">"igraph"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="10f9117f" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(adata, color<span class="op">=</span>[<span class="st">"leiden"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-23-output-1.png" width="243" height="187" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="re-assess-quality-control-and-cell-filtering" class="level2">
<h2 class="anchored" data-anchor-id="re-assess-quality-control-and-cell-filtering">Re-assess quality control and cell filtering</h2>
<p>As indicated before, we will now re-assess our filtering strategy by visualizing different QC metrics using UMAP.</p>
<div id="4bf24d75" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>adata.obs[<span class="st">"predicted_doublet"</span>] <span class="op">=</span> adata.obs[<span class="st">"predicted_doublet"</span>].astype(<span class="st">"category"</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    adata,</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span>[<span class="st">"leiden"</span>, <span class="st">"predicted_doublet"</span>, <span class="st">"doublet_score"</span>],</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># increase horizontal space between panels</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    wspace<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-24-output-1.png" width="747" height="187" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We can now subset the AnnData object to exclude cells predicted as doublets:</p>
<div id="df63bce3" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>adata <span class="op">=</span> adata[<span class="op">~</span>adata.obs[<span class="st">"predicted_doublet"</span>].to_numpy()].copy()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="8236bd81" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    adata, color<span class="op">=</span>[<span class="st">"leiden"</span>, <span class="st">"log1p_total_counts"</span>, <span class="st">"pct_counts_mt"</span>, <span class="st">"log1p_n_genes_by_counts"</span>], wspace<span class="op">=</span><span class="fl">0.5</span>, ncols<span class="op">=</span><span class="dv">2</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-26-output-1.png" width="504" height="365" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="cell-type-annotation" class="level2">
<h2 class="anchored" data-anchor-id="cell-type-annotation">Cell-type annotation</h2>
<div id="2f56bb5d" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>: </span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> celltypist <span class="im">as</span> ct</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install celltypist</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> celltypist <span class="im">as</span> ct</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> decoupler <span class="im">as</span> dc</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install decoupler</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> decoupler <span class="im">as</span> dc</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We have now reached a point where we have obtained a set of cells with decent quality, and we can proceed to their annotation to known cell types. Typically, this is done using genes that are exclusively expressed by a given cell type, or in other words these genes are the marker genes of the cell types, and are thus used to distinguish the heterogeneous groups of cells in our data. Previous efforts have collected and curated various marker genes into available resources, such as <a href="http://bio-bigdata.hrbmu.edu.cn/CellMarker/">CellMarker</a>, <a href="http://bio.liclab.net/TF-Marker/">TF-Marker</a>, and <a href="https://panglaodb.se/">PanglaoDB</a>.</p>
<p>Commonly and classically, cell type annotation uses those marker genes subsequent to the grouping of the cells into clusters. So, let’s generate a set of clustering solutions which we can then use to annotate our cell types. Here, we will use the Leiden clustering algorithm which will extract cell communities from our nearest neighbours graph.</p>
<div id="b47a7303" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>sc.tl.leiden(adata, flavor<span class="op">=</span><span class="st">"igraph"</span>, key_added<span class="op">=</span><span class="st">"leiden_res0_02"</span>, resolution<span class="op">=</span><span class="fl">0.02</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>sc.tl.leiden(adata, flavor<span class="op">=</span><span class="st">"igraph"</span>, key_added<span class="op">=</span><span class="st">"leiden_res0_5"</span>, resolution<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>sc.tl.leiden(adata, flavor<span class="op">=</span><span class="st">"igraph"</span>, key_added<span class="op">=</span><span class="st">"leiden_res2"</span>, resolution<span class="op">=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Notably, the number of clusters that we define is largely arbitrary, and so is the <code>resolution</code> parameter that we use to control for it. As such, the number of clusters is ultimately bound to the stable and biologically-meaningful groups that we can ultimately distringuish, typically done by experts in the corresponding field or by using expert-curated prior knowledge in the form of markers.</p>
<div id="2916832f" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    adata,</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span>[<span class="st">"leiden_res0_02"</span>, <span class="st">"leiden_res0_5"</span>, <span class="st">"leiden_res2"</span>],</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    legend_loc<span class="op">=</span><span class="st">"on data"</span>,</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-29-output-1.png" width="583" height="186" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Though UMAPs should not be over-interpreted, here we can already see that in the highest resolution our data is over-clustered, while the lowest resolution is likely grouping cells which belong to distinct cell identities.</p>
<section id="marker-gene-set" class="level3">
<h3 class="anchored" data-anchor-id="marker-gene-set">Marker gene set</h3>
<p>Let’s define a set of marker genes for the main cell types that we expect to see in this dataset. These were adapted from <a href="https://www.sc-best-practices.org/cellular_structure/annotation.html">Single Cell Best Practices annotation chapter</a>, for a more detailed overview and best practices in cell type annotation, we refer the user to it.</p>
<div id="75f2c96b" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>marker_genes <span class="op">=</span> {</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"CD14+ Mono"</span>: [<span class="st">"FCN1"</span>, <span class="st">"CD14"</span>],</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"CD16+ Mono"</span>: [<span class="st">"TCF7L2"</span>, <span class="st">"FCGR3A"</span>, <span class="st">"LYN"</span>],</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note: DMXL2 should be negative</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"cDC2"</span>: [<span class="st">"CST3"</span>, <span class="st">"COTL1"</span>, <span class="st">"LYZ"</span>, <span class="st">"DMXL2"</span>, <span class="st">"CLEC10A"</span>, <span class="st">"FCER1A"</span>],</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Erythroblast"</span>: [<span class="st">"MKI67"</span>, <span class="st">"HBA1"</span>, <span class="st">"HBB"</span>],</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note HBM and GYPA are negative markers</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Proerythroblast"</span>: [<span class="st">"CDK6"</span>, <span class="st">"SYNGR1"</span>, <span class="st">"HBM"</span>, <span class="st">"GYPA"</span>],</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"NK"</span>: [<span class="st">"GNLY"</span>, <span class="st">"NKG7"</span>, <span class="st">"CD247"</span>, <span class="st">"FCER1G"</span>, <span class="st">"TYROBP"</span>, <span class="st">"KLRG1"</span>, <span class="st">"FCGR3A"</span>],</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ILC"</span>: [<span class="st">"ID2"</span>, <span class="st">"PLCG2"</span>, <span class="st">"GNLY"</span>, <span class="st">"SYNE1"</span>],</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Naive CD20+ B"</span>: [<span class="st">"MS4A1"</span>, <span class="st">"IL4R"</span>, <span class="st">"IGHD"</span>, <span class="st">"FCRL1"</span>, <span class="st">"IGHM"</span>],</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note IGHD and IGHM are negative markers</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"B cells"</span>: [<span class="st">"MS4A1"</span>, <span class="st">"ITGB1"</span>, <span class="st">"COL4A4"</span>, <span class="st">"PRDM1"</span>, <span class="st">"IRF4"</span>, <span class="st">"PAX5"</span>, <span class="st">"BCL11A"</span>, <span class="st">"BLK"</span>, <span class="st">"IGHD"</span>, <span class="st">"IGHM"</span>],</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Plasma cells"</span>: [<span class="st">"MZB1"</span>, <span class="st">"HSP90B1"</span>, <span class="st">"FNDC3B"</span>, <span class="st">"PRDM1"</span>, <span class="st">"IGKC"</span>, <span class="st">"JCHAIN"</span>],</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Plasmablast"</span>: [<span class="st">"XBP1"</span>, <span class="st">"PRDM1"</span>, <span class="st">"PAX5"</span>],  <span class="co"># Note PAX5 is a negative marker</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">"CD4+ T"</span>: [<span class="st">"CD4"</span>, <span class="st">"IL7R"</span>, <span class="st">"TRBC2"</span>],</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">"CD8+ T"</span>: [<span class="st">"CD8A"</span>, <span class="st">"CD8B"</span>, <span class="st">"GZMK"</span>, <span class="st">"GZMA"</span>, <span class="st">"CCL5"</span>, <span class="st">"GZMB"</span>, <span class="st">"GZMH"</span>, <span class="st">"GZMA"</span>],</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">"T naive"</span>: [<span class="st">"LEF1"</span>, <span class="st">"CCR7"</span>, <span class="st">"TCF7"</span>],</span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">"pDC"</span>: [<span class="st">"GZMB"</span>, <span class="st">"IL3RA"</span>, <span class="st">"COBLL1"</span>, <span class="st">"TCF4"</span>],</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="7116c1d2" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> group_max(adata: sc.AnnData, groupby: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    agg <span class="op">=</span> sc.get.aggregate(adata, by<span class="op">=</span>groupby, func<span class="op">=</span><span class="st">"mean"</span>)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.Series(agg.layers[<span class="st">"mean"</span>].<span class="bu">sum</span>(<span class="dv">1</span>), agg.obs[groupby]).idxmax()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="09719b54" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>sc.pl.dotplot(adata, marker_genes, groupby<span class="op">=</span><span class="st">"leiden_res0_02"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-32-output-1.png" width="1105" height="178" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Here, we can see that cluster {eval}<code>group_max(adata[:, marker_genes["NK"]], "leiden_res0_02")</code> perhaps contains an admixture of monocytes and dendritic cells, while in cluster {eval}<code>group_max(adata[:, marker_genes["B cells"]], "leiden_res0_02")</code> we have different populations of B lymphocytes. Thus, we should perhaps consider a higher clustering resolution.</p>
<div id="b00803fb" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>sc.pl.dotplot(adata, marker_genes, groupby<span class="op">=</span><span class="st">"leiden_res0_5"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-33-output-1.png" width="1109" height="311" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>This seems like a resolution that suitable to distinguish most of the different cell types in our data. Ideally, one would look specifically into each cluster, and attempt to subcluster those if required.</p>
</section>
<section id="automatic-label-prediction" class="level3">
<h3 class="anchored" data-anchor-id="automatic-label-prediction">Automatic label prediction</h3>
<p>In addition to using marker collections to annotate our labels, there exist approaches to automatically annotate scRNA-seq datasets. One such tool is <a href="https://github.com/Teichlab/celltypist">CellTypist</a>, which uses gradient-descent optimised logistic regression classifiers to predict cell type annotations.</p>
<p>First, we need to retrive the CellTypist models that we wish to use, in this case we will use models with immune cell type and subtype populations generated using 20 tissues from 18 studies (<a href="https://www.science.org/doi/full/10.1126/science.abl5197">Domínguez Conde, et al.&nbsp;2022</a>).</p>
<div id="7e90550e" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> first_time:</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    ct.models.download_models(model<span class="op">=</span>[<span class="st">"Immune_All_Low.pkl"</span>], force_update<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then we predict the major cell type annotations. In this case we will enable <code>majority_voting</code>, which will assign a label to the clusters that we obtained previously.</p>
<div id="721330f3" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> ct.models.Model.load(model<span class="op">=</span><span class="st">"Immune_All_Low.pkl"</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>predictions <span class="op">=</span> ct.annotate(adata, model<span class="op">=</span><span class="st">"Immune_All_Low.pkl"</span>, majority_voting<span class="op">=</span><span class="va">True</span>, over_clustering<span class="op">=</span><span class="st">"leiden_res0_5"</span>)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="co"># convert back to anndata||</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>adata <span class="op">=</span> predictions.to_adata()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>⚠️ Warning: invalid expression matrix, expect ALL genes and log1p normalized expression to 10000 counts per cell. The prediction result may not be accurate
🔬 Input data has 16828 cells and 23427 genes
🔗 Matching reference genes in the model
🧬 5852 features used for prediction
⚖️ Scaling input data
🖋️ Predicting labels
✅ Prediction done!
🗳️ Majority voting the predictions
✅ Majority voting done!</code></pre>
</div>
</div>
<p>Let’s examine the results of automatic clustering:</p>
<div id="631cd07e" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(adata, color<span class="op">=</span><span class="st">"majority_voting"</span>, ncols<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-36-output-1.png" width="297" height="184" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Note that our previously ‘Unknown’ cluster is now assigned as ‘Pro-B cells’.</p>
</section>
<section id="annotation-with-enrichment-analysis" class="level3">
<h3 class="anchored" data-anchor-id="annotation-with-enrichment-analysis">Annotation with enrichment analysis</h3>
<p>Automatic cell type labelling with methods that require pre-trained models will not always work as smoothly, as such classifiers need to be trained on and be representitive for a given tissue and the cell types within it. So, as a more generalizable approach to annotate the cells, we can also use the marker genes from any database, for example <a href="https://panglaodb.se/">PanglaoDB</a>. Here we will use it with simple multi-variate linear regression, implemented in <a href="https://github.com/saezlab/decoupler-py">decoupler</a>. Essentially, this will test if any collection of genes are enriched in any of the cells. Ultimately, this approach is similar to many other marker-based classifiers.</p>
<p>Let’s get canonical cell markers using with <a href="https://github.com/saezlab/decoupler-py">decoupler</a> which queries the OmniPath metadata-base to obtain the <a href="https://panglaodb.se/">PanglaoDB</a> marker gene database with cannonical cell type markers.</p>
<div id="02ea82c9" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Query Omnipath and get PanglaoDB</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>markers <span class="op">=</span> dc.get_resource(name<span class="op">=</span><span class="st">"PanglaoDB"</span>, organism<span class="op">=</span><span class="st">"human"</span>)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Print initial information about the markers DataFrame</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Initial markers DataFrame shape:"</span>, markers.shape)</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert canonical_marker to boolean - fixing the conversion</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>markers[<span class="st">"canonical_marker"</span>] <span class="op">=</span> markers[<span class="st">"canonical_marker"</span>].astype(<span class="bu">str</span>).<span class="bu">map</span>({<span class="st">'True'</span>: <span class="va">True</span>, <span class="st">'False'</span>: <span class="va">False</span>})</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Keep canonical cell type markers alone</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>markers <span class="op">=</span> markers[markers[<span class="st">"canonical_marker"</span>] <span class="op">==</span> <span class="va">True</span>]</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Shape after filtering canonical markers:"</span>, markers.shape)</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove duplicated entries</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>markers <span class="op">=</span> markers[<span class="op">~</span>markers.duplicated([<span class="st">"cell_type"</span>, <span class="st">"genesymbol"</span>])]</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Shape after removing duplicates:"</span>, markers.shape)</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert gene symbols to uppercase in both datasets to ensure consistent matching</span></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>markers[<span class="st">"genesymbol"</span>] <span class="op">=</span> markers[<span class="st">"genesymbol"</span>].<span class="bu">str</span>.upper()</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>adata.var_names <span class="op">=</span> adata.var_names.<span class="bu">str</span>.upper()</span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Print overlap statistics</span></span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Number of unique genes in markers:"</span>, <span class="bu">len</span>(markers[<span class="st">"genesymbol"</span>].unique()))</span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of genes in adata:"</span>, adata.n_vars)</span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of overlapping genes:"</span>, <span class="bu">len</span>(<span class="bu">set</span>(markers[<span class="st">"genesymbol"</span>].unique()) <span class="op">&amp;</span> <span class="bu">set</span>(adata.var_names)))</span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Print some example cell types and their marker counts</span></span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Number of markers per cell type:"</span>)</span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(markers.groupby(<span class="st">"cell_type"</span>)[<span class="st">"genesymbol"</span>].count().sort_values(ascending<span class="op">=</span><span class="va">False</span>).head())</span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Run MLM with a lower min_n value</span></span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>dc.run_mlm(mat<span class="op">=</span>adata, net<span class="op">=</span>markers, weight<span class="op">=</span><span class="va">None</span>, source<span class="op">=</span><span class="st">"cell_type"</span>, target<span class="op">=</span><span class="st">"genesymbol"</span>, verbose<span class="op">=</span><span class="va">True</span>, use_raw<span class="op">=</span><span class="va">False</span>, min_n<span class="op">=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Initial markers DataFrame shape: (8461, 14)

Shape after filtering canonical markers: (5527, 14)

Shape after removing duplicates: (5502, 14)

Number of unique genes in markers: 3366
Number of genes in adata: 23427
Number of overlapping genes: 2424

Number of markers per cell type:
cell_type
Endothelial cells    192
Macrophages          166
Dendritic cells      147
Mast cells           144
Hepatocytes          135
Name: genesymbol, dtype: int64
Running mlm on mat with 16828 samples and 23427 targets for 154 sources.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>  0%|          | 0/2 [00:00&lt;?, ?it/s] 50%|█████     | 1/2 [00:03&lt;00:03,  3.56s/it]100%|██████████| 2/2 [00:06&lt;00:00,  2.92s/it]100%|██████████| 2/2 [00:06&lt;00:00,  3.02s/it]</code></pre>
</div>
</div>
<p>The obtained results are stored in the .obsm key, with <code>mlm_estimate</code> representing coefficient t-values:</p>
<div id="21c4f0b3" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>adata.obsm[<span class="st">"mlm_estimate"</span>].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Acinar cells</th>
<th data-quarto-table-cell-role="th">Adipocyte progenitor cells</th>
<th data-quarto-table-cell-role="th">Adipocytes</th>
<th data-quarto-table-cell-role="th">Adrenergic neurons</th>
<th data-quarto-table-cell-role="th">Airway epithelial cells</th>
<th data-quarto-table-cell-role="th">Airway goblet cells</th>
<th data-quarto-table-cell-role="th">Alpha cells</th>
<th data-quarto-table-cell-role="th">Alveolar macrophages</th>
<th data-quarto-table-cell-role="th">Anterior pituitary gland cells</th>
<th data-quarto-table-cell-role="th">Astrocytes</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">T regulatory cells</th>
<th data-quarto-table-cell-role="th">Tanycytes</th>
<th data-quarto-table-cell-role="th">Taste receptor cells</th>
<th data-quarto-table-cell-role="th">Thymocytes</th>
<th data-quarto-table-cell-role="th">Trichocytes</th>
<th data-quarto-table-cell-role="th">Trigeminal neurons</th>
<th data-quarto-table-cell-role="th">Trophoblast cells</th>
<th data-quarto-table-cell-role="th">Trophoblast progenitor cells</th>
<th data-quarto-table-cell-role="th">Tuft cells</th>
<th data-quarto-table-cell-role="th">Urothelial cells</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">AAACCCAAGGATGGCT-1</td>
<td>-0.829379</td>
<td>-0.192387</td>
<td>-0.433855</td>
<td>-0.259944</td>
<td>0.105843</td>
<td>-0.896782</td>
<td>0.286354</td>
<td>0.445317</td>
<td>-0.360782</td>
<td>0.482100</td>
<td>...</td>
<td>-1.861577</td>
<td>0.653052</td>
<td>-0.914405</td>
<td>2.135190</td>
<td>-0.409456</td>
<td>-0.240998</td>
<td>0.870413</td>
<td>2.188858</td>
<td>1.590695</td>
<td>-0.726171</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">AAACCCAAGGCCTAGA-1</td>
<td>0.305256</td>
<td>-0.409719</td>
<td>0.115441</td>
<td>-0.659562</td>
<td>-0.503354</td>
<td>-0.793676</td>
<td>0.980069</td>
<td>-3.680857</td>
<td>-0.313018</td>
<td>1.018442</td>
<td>...</td>
<td>-1.191339</td>
<td>-0.122365</td>
<td>-0.713158</td>
<td>-0.302480</td>
<td>-0.585186</td>
<td>0.926535</td>
<td>-0.557362</td>
<td>-0.477797</td>
<td>2.051256</td>
<td>-1.071484</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">AAACCCAAGTGAGTGC-1</td>
<td>0.367563</td>
<td>-0.238991</td>
<td>0.066879</td>
<td>-0.181742</td>
<td>0.530131</td>
<td>-0.246711</td>
<td>-0.459827</td>
<td>-0.713275</td>
<td>-0.197698</td>
<td>-1.156477</td>
<td>...</td>
<td>-1.127890</td>
<td>-0.514065</td>
<td>-0.735793</td>
<td>0.894280</td>
<td>-0.270854</td>
<td>-0.110214</td>
<td>2.406705</td>
<td>-0.221142</td>
<td>1.700772</td>
<td>-0.384683</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">AAACCCACAAGAGGCT-1</td>
<td>-1.453875</td>
<td>0.022096</td>
<td>-1.493422</td>
<td>-0.303853</td>
<td>-1.110833</td>
<td>-1.383801</td>
<td>1.080116</td>
<td>0.622730</td>
<td>0.170097</td>
<td>-1.103424</td>
<td>...</td>
<td>-1.076105</td>
<td>-0.212070</td>
<td>-0.546337</td>
<td>0.964560</td>
<td>-0.583426</td>
<td>-0.543244</td>
<td>0.502228</td>
<td>0.681523</td>
<td>3.035343</td>
<td>-1.010428</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">AAACCCACATCGTGGC-1</td>
<td>1.160588</td>
<td>-0.435748</td>
<td>-1.242875</td>
<td>-0.100550</td>
<td>-1.379393</td>
<td>-0.165989</td>
<td>-0.541564</td>
<td>-0.351312</td>
<td>-0.015558</td>
<td>0.188370</td>
<td>...</td>
<td>1.963929</td>
<td>-0.292627</td>
<td>1.647266</td>
<td>-1.076357</td>
<td>-0.191659</td>
<td>-0.791095</td>
<td>-0.017454</td>
<td>-0.156497</td>
<td>-0.078420</td>
<td>-0.396215</td>
</tr>
</tbody>
</table>

<p>5 rows × 154 columns</p>
</div>
</div>
</div>
<p>To visualize the obtianed scores, we can re-use any of scanpy’s plotting functions. First though, we will extract them from the adata object.</p>
<div id="6f06449c" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>acts <span class="op">=</span> dc.get_acts(adata<span class="op">=</span>adata, obsm_key<span class="op">=</span><span class="st">"mlm_estimate"</span>)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    acts,</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span>[</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"majority_voting"</span>,</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"B cells"</span>,</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">"T cells"</span>,</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Monocytes"</span>,</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Erythroid-like and erythroid precursor cells"</span>,</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">"NK cells"</span>,</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>    wspace<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>    ncols<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-39-output-1.png" width="745" height="360" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>These results further confirm the our automatic annotation with Celltypist. In addition, here we can also transfer the max over-representation score estimates to assign a label to each cluster.</p>
<div id="fe5cab66" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>mean_enr <span class="op">=</span> dc.summarize_acts(acts, groupby<span class="op">=</span><span class="st">"leiden_res0_5"</span>, min_std<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>annotation_dict <span class="op">=</span> dc.assign_groups(mean_enr)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>adata.obs[<span class="st">"dc_anno"</span>] <span class="op">=</span> [annotation_dict[clust] <span class="cf">for</span> clust <span class="kw">in</span> adata.obs[<span class="st">"leiden_res0_5"</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s compare all resulting annotations here</p>
<div id="fd900502" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(adata, color<span class="op">=</span>[<span class="st">"majority_voting"</span>, <span class="st">"dc_anno"</span>], ncols<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>... storing 'dc_anno' as categorical</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-41-output-2.png" width="383" height="360" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Great. We can see that the different approaches to annotate the data are largely concordant. Though, these annotations are decent, cell type annotation is laborous and repetitive task, one which typically requires multiple rounds of sublucstering and re-annotation. Nevertheless, we now have a good basis with which we can further proceed with manually refining our annotations.</p>
</section>
<section id="differentially-expressed-genes-as-markers" class="level3">
<h3 class="anchored" data-anchor-id="differentially-expressed-genes-as-markers">Differentially-expressed Genes as Markers</h3>
<p>Furthermore, one can also calculate marker genes per cluster and then look up whether we can link those marker genes to any known biology, such as cell types and/or states. This is typically done using simple statistical tests, such as Wilcoxon and t-test, for each cluster vs the rest.</p>
<div id="05b47c1d" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Obtain cluster-specific differentially expressed genes</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>sc.tl.rank_genes_groups(adata, groupby<span class="op">=</span><span class="st">"leiden_res0_5"</span>)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter those</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>sc.tl.filter_rank_genes_groups(adata, min_fold_change<span class="op">=</span><span class="fl">1.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can then visualize the top 5 differentially-expressed genes on a dotplot.</p>
<div id="e4d78aee" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>sc.pl.rank_genes_groups_dotplot(adata, groupby<span class="op">=</span><span class="st">"leiden_res0_5"</span>, standard_scale<span class="op">=</span><span class="st">"var"</span>, n_genes<span class="op">=</span><span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>WARNING: dendrogram data not found (using key=dendrogram_leiden_res0_5). Running `sc.tl.dendrogram` with default parameters. For fine tuning it is recommended to run `sc.tl.dendrogram` independently.</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-43-output-2.png" width="1129" height="286" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We see that <em>LYZ</em>, <em>ACT8</em>, <em>S100A6</em>, <em>S100A4</em>, and <em>CST3</em> are all highly expressed in cluster <code>3</code>. Let’s visualize those at the UMAP space:</p>
<div id="3c4818fb" class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>cluster3_genes <span class="op">=</span> [<span class="st">"LYZ"</span>, <span class="st">"ACTB"</span>, <span class="st">"S100A6"</span>, <span class="st">"S100A4"</span>, <span class="st">"CST3"</span>]</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(adata, color<span class="op">=</span>[<span class="op">*</span>cluster3_genes, <span class="st">"leiden_res0_5"</span>], legend_loc<span class="op">=</span><span class="st">"on data"</span>, frameon<span class="op">=</span><span class="va">False</span>, ncols<span class="op">=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-44-output-1.png" width="588" height="354" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Similarly, we can also generate a Violin plot with the distrubtions of the same genes across the clusters.</p>
<div id="c3a58842" class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>sc.pl.violin(adata, keys<span class="op">=</span>cluster3_genes[<span class="dv">0</span>:<span class="dv">3</span>], groupby<span class="op">=</span><span class="st">"leiden_res0_5"</span>, multi_panel<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.
Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="scanpy-basic-scrna-tutorial_files/figure-html/cell-45-output-2.png" width="538" height="190" class="figure-img"></p>
</figure>
</div>
</div>
</div>


<!-- -->

</section>
</section>
</section>

<p>© <a href="https://hakyimlab.org">HakyImLab and Listed Authors</a> - <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 License</a></p></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb55" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> scanpy tutorial - qmd</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> '2025-05-12'</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> scanpy authors</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="an">eval:</span><span class="co"> true</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="co">  - notebook</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a><span class="an">freeze:</span><span class="co"> true</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> </span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a><span class="co">  kernelspec:</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a><span class="co">    name: "conda-env-scanpy-tutorial-py"</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a><span class="co">    language: "python"</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a><span class="co">    display_name: "scanpy-tutorial"</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>This notebook is not compatible with this python 3.12. Some issues with pickle data and celltypist.</span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a><span class="in">```{bash}</span></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a><span class="ex">conda</span> create <span class="at">--name</span> scanpy-tutorial python=3.9</span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a><span class="ex">conda</span> activate scanpy-tutorial</span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a><span class="ex">conda</span> install nb_conda_kernels jupyter_server</span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install nbclient nbformat</span>
<span id="cb55-24"><a href="#cb55-24" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-25"><a href="#cb55-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-28"><a href="#cb55-28" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-29"><a href="#cb55-29" aria-hidden="true" tabindex="-1"></a><span class="co"># set first time to False to avoid multiple downloads</span></span>
<span id="cb55-30"><a href="#cb55-30" aria-hidden="true" tabindex="-1"></a>first_time <span class="op">=</span> <span class="va">False</span></span>
<span id="cb55-31"><a href="#cb55-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(first_time)</span>
<span id="cb55-32"><a href="#cb55-32" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-33"><a href="#cb55-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-34"><a href="#cb55-34" aria-hidden="true" tabindex="-1"></a><span class="fu"># Preprocessing and clustering</span></span>
<span id="cb55-35"><a href="#cb55-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-38"><a href="#cb55-38" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-39"><a href="#cb55-39" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb55-40"><a href="#cb55-40" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> anndata <span class="im">as</span> ad</span>
<span id="cb55-41"><a href="#cb55-41" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb55-42"><a href="#cb55-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install anndata</span>
<span id="cb55-43"><a href="#cb55-43" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> anndata <span class="im">as</span> ad</span>
<span id="cb55-44"><a href="#cb55-44" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb55-45"><a href="#cb55-45" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> pooch</span>
<span id="cb55-46"><a href="#cb55-46" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb55-47"><a href="#cb55-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install pooch</span>
<span id="cb55-48"><a href="#cb55-48" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> pooch</span>
<span id="cb55-49"><a href="#cb55-49" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb55-50"><a href="#cb55-50" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> scanpy <span class="im">as</span> sc</span>
<span id="cb55-51"><a href="#cb55-51" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb55-52"><a href="#cb55-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install scanpy</span>
<span id="cb55-53"><a href="#cb55-53" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> scanpy <span class="im">as</span> sc</span>
<span id="cb55-54"><a href="#cb55-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-55"><a href="#cb55-55" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb55-56"><a href="#cb55-56" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> scrublet</span>
<span id="cb55-57"><a href="#cb55-57" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb55-58"><a href="#cb55-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install scrublet</span>
<span id="cb55-59"><a href="#cb55-59" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> scrublet</span>
<span id="cb55-60"><a href="#cb55-60" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb55-61"><a href="#cb55-61" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> skimage </span>
<span id="cb55-62"><a href="#cb55-62" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb55-63"><a href="#cb55-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install scikit<span class="op">-</span>image</span>
<span id="cb55-64"><a href="#cb55-64" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> skimage</span>
<span id="cb55-65"><a href="#cb55-65" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb55-66"><a href="#cb55-66" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> igraph</span>
<span id="cb55-67"><a href="#cb55-67" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb55-68"><a href="#cb55-68" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install igraph</span>
<span id="cb55-69"><a href="#cb55-69" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> igraph</span>
<span id="cb55-70"><a href="#cb55-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-71"><a href="#cb55-71" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-72"><a href="#cb55-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-75"><a href="#cb55-75" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-76"><a href="#cb55-76" aria-hidden="true" tabindex="-1"></a>sc.settings.set_figure_params(dpi<span class="op">=</span><span class="dv">50</span>, facecolor<span class="op">=</span><span class="st">"white"</span>)</span>
<span id="cb55-77"><a href="#cb55-77" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-78"><a href="#cb55-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-79"><a href="#cb55-79" aria-hidden="true" tabindex="-1"></a>The data used in this basic preprocessing and clustering tutorial was collected from bone marrow mononuclear cells of healthy human donors and was part of <span class="co">[</span><span class="ot">openproblem's NeurIPS 2021 benchmarking dataset</span><span class="co">](https://openproblems.bio/competitions/neurips_2021/)</span> {cite}<span class="in">`luecken2021`</span>. The samples used in this tutorial were measured using the 10X Multiome Gene Expression and Chromatin Accessability kit. </span>
<span id="cb55-80"><a href="#cb55-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-81"><a href="#cb55-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-82"><a href="#cb55-82" aria-hidden="true" tabindex="-1"></a>We are reading in the count matrix into an <span class="co">[</span><span class="ot">AnnData</span><span class="co">](https://anndata.readthedocs.io/en/latest/tutorials/notebooks/getting-started.html)</span> object, which holds many slots for annotations and different representations of the data.</span>
<span id="cb55-83"><a href="#cb55-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-86"><a href="#cb55-86" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-87"><a href="#cb55-87" aria-hidden="true" tabindex="-1"></a>EXAMPLE_DATA <span class="op">=</span> pooch.create(</span>
<span id="cb55-88"><a href="#cb55-88" aria-hidden="true" tabindex="-1"></a>    path<span class="op">=</span>pooch.os_cache(<span class="st">"scverse_tutorials"</span>),</span>
<span id="cb55-89"><a href="#cb55-89" aria-hidden="true" tabindex="-1"></a>    base_url<span class="op">=</span><span class="st">"doi:10.6084/m9.figshare.22716739.v1/"</span>,</span>
<span id="cb55-90"><a href="#cb55-90" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb55-91"><a href="#cb55-91" aria-hidden="true" tabindex="-1"></a>EXAMPLE_DATA.load_registry_from_doi()</span>
<span id="cb55-92"><a href="#cb55-92" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-93"><a href="#cb55-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-96"><a href="#cb55-96" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-97"><a href="#cb55-97" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> {</span>
<span id="cb55-98"><a href="#cb55-98" aria-hidden="true" tabindex="-1"></a>    <span class="st">"s1d1"</span>: <span class="st">"s1d1_filtered_feature_bc_matrix.h5"</span>,</span>
<span id="cb55-99"><a href="#cb55-99" aria-hidden="true" tabindex="-1"></a>    <span class="st">"s1d3"</span>: <span class="st">"s1d3_filtered_feature_bc_matrix.h5"</span>,</span>
<span id="cb55-100"><a href="#cb55-100" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb55-101"><a href="#cb55-101" aria-hidden="true" tabindex="-1"></a>adatas <span class="op">=</span> {}</span>
<span id="cb55-102"><a href="#cb55-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-103"><a href="#cb55-103" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sample_id, filename <span class="kw">in</span> samples.items():</span>
<span id="cb55-104"><a href="#cb55-104" aria-hidden="true" tabindex="-1"></a>    path <span class="op">=</span> EXAMPLE_DATA.fetch(filename)</span>
<span id="cb55-105"><a href="#cb55-105" aria-hidden="true" tabindex="-1"></a>    sample_adata <span class="op">=</span> sc.read_10x_h5(path)</span>
<span id="cb55-106"><a href="#cb55-106" aria-hidden="true" tabindex="-1"></a>    sample_adata.var_names_make_unique()</span>
<span id="cb55-107"><a href="#cb55-107" aria-hidden="true" tabindex="-1"></a>    adatas[sample_id] <span class="op">=</span> sample_adata</span>
<span id="cb55-108"><a href="#cb55-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-109"><a href="#cb55-109" aria-hidden="true" tabindex="-1"></a>adata <span class="op">=</span> ad.concat(adatas, label<span class="op">=</span><span class="st">"sample"</span>)</span>
<span id="cb55-110"><a href="#cb55-110" aria-hidden="true" tabindex="-1"></a>adata.obs_names_make_unique()</span>
<span id="cb55-111"><a href="#cb55-111" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-112"><a href="#cb55-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-113"><a href="#cb55-113" aria-hidden="true" tabindex="-1"></a>The data contains 8,785 cells and 36,601 measured genes. This tutorial includes a basic preprocessing and clustering workflow. </span>
<span id="cb55-114"><a href="#cb55-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-115"><a href="#cb55-115" aria-hidden="true" tabindex="-1"></a><span class="fu">## Quality Control</span></span>
<span id="cb55-116"><a href="#cb55-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-117"><a href="#cb55-117" aria-hidden="true" tabindex="-1"></a>The scanpy function {func}<span class="in">`~scanpy.pp.calculate_qc_metrics`</span> calculates common quality control (QC) metrics, which are largely based on <span class="in">`calculateQCMetrics`</span> from scater {cite}<span class="in">`McCarthy2017`</span>. One can pass specific gene population to {func}<span class="in">`~scanpy.pp.calculate_qc_metrics`</span> in order to calculate proportions of counts for these populations. Mitochondrial, ribosomal and hemoglobin genes are defined by distinct prefixes as listed below. </span>
<span id="cb55-118"><a href="#cb55-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-121"><a href="#cb55-121" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-122"><a href="#cb55-122" aria-hidden="true" tabindex="-1"></a><span class="co"># mitochondrial genes</span></span>
<span id="cb55-123"><a href="#cb55-123" aria-hidden="true" tabindex="-1"></a>adata.var[<span class="st">"mt"</span>] <span class="op">=</span> adata.var_names.<span class="bu">str</span>.startswith(<span class="st">"MT-"</span>)  <span class="co"># "MT-" for human, "Mt-" for mouse</span></span>
<span id="cb55-124"><a href="#cb55-124" aria-hidden="true" tabindex="-1"></a><span class="co"># ribosomal genes</span></span>
<span id="cb55-125"><a href="#cb55-125" aria-hidden="true" tabindex="-1"></a>adata.var[<span class="st">"ribo"</span>] <span class="op">=</span> adata.var_names.<span class="bu">str</span>.startswith((<span class="st">"RPS"</span>, <span class="st">"RPL"</span>))</span>
<span id="cb55-126"><a href="#cb55-126" aria-hidden="true" tabindex="-1"></a><span class="co"># hemoglobin genes</span></span>
<span id="cb55-127"><a href="#cb55-127" aria-hidden="true" tabindex="-1"></a>adata.var[<span class="st">"hb"</span>] <span class="op">=</span> adata.var_names.<span class="bu">str</span>.contains(<span class="st">"^HB[^(P)]"</span>)</span>
<span id="cb55-128"><a href="#cb55-128" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-129"><a href="#cb55-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-132"><a href="#cb55-132" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-133"><a href="#cb55-133" aria-hidden="true" tabindex="-1"></a>sc.pp.calculate_qc_metrics(adata, qc_vars<span class="op">=</span>[<span class="st">"mt"</span>, <span class="st">"ribo"</span>, <span class="st">"hb"</span>], inplace<span class="op">=</span><span class="va">True</span>, log1p<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb55-134"><a href="#cb55-134" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-135"><a href="#cb55-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-136"><a href="#cb55-136" aria-hidden="true" tabindex="-1"></a>One can now inspect violin plots of some of the computed QC metrics:</span>
<span id="cb55-137"><a href="#cb55-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-138"><a href="#cb55-138" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>the number of genes expressed in the count matrix</span>
<span id="cb55-139"><a href="#cb55-139" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>the total counts per cell</span>
<span id="cb55-140"><a href="#cb55-140" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>the percentage of counts in mitochondrial genes</span>
<span id="cb55-141"><a href="#cb55-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-144"><a href="#cb55-144" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-145"><a href="#cb55-145" aria-hidden="true" tabindex="-1"></a>sc.pl.violin(adata, [<span class="st">"n_genes_by_counts"</span>, <span class="st">"total_counts"</span>, <span class="st">"pct_counts_mt"</span>], jitter<span class="op">=</span><span class="fl">0.4</span>, multi_panel<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb55-146"><a href="#cb55-146" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-147"><a href="#cb55-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-148"><a href="#cb55-148" aria-hidden="true" tabindex="-1"></a>Additionally, it is useful to consider QC metrics jointly by inspecting a scatter plot colored by <span class="in">`pct_counts_mt`</span>. </span>
<span id="cb55-149"><a href="#cb55-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-152"><a href="#cb55-152" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-153"><a href="#cb55-153" aria-hidden="true" tabindex="-1"></a>sc.pl.scatter(adata, <span class="st">"total_counts"</span>, <span class="st">"n_genes_by_counts"</span>, color<span class="op">=</span><span class="st">"pct_counts_mt"</span>)</span>
<span id="cb55-154"><a href="#cb55-154" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-155"><a href="#cb55-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-156"><a href="#cb55-156" aria-hidden="true" tabindex="-1"></a>Based on the QC metric plots, one could now remove cells that have too many mitochondrial genes expressed or too many total counts by setting manual or automatic thresholds. However, it proved to be beneficial to apply a very permissive filtering strategy in the beginning for your single-cell analysis and filter low quality cells during clustering or revisit the filtering again at a later point. We therefore now only filter cells with less than 100 genes expressed and genes that are detected in less than 3 cells. </span>
<span id="cb55-157"><a href="#cb55-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-158"><a href="#cb55-158" aria-hidden="true" tabindex="-1"></a>Additionally, it is important to note that for datasets with multiple batches, quality control should be performed for each sample individually as quality control thresholds can very substantially between batches. </span>
<span id="cb55-159"><a href="#cb55-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-162"><a href="#cb55-162" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-163"><a href="#cb55-163" aria-hidden="true" tabindex="-1"></a>sc.pp.filter_cells(adata, min_genes<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb55-164"><a href="#cb55-164" aria-hidden="true" tabindex="-1"></a>sc.pp.filter_genes(adata, min_cells<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb55-165"><a href="#cb55-165" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-166"><a href="#cb55-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-167"><a href="#cb55-167" aria-hidden="true" tabindex="-1"></a><span class="fu">### Doublet detection</span></span>
<span id="cb55-168"><a href="#cb55-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-169"><a href="#cb55-169" aria-hidden="true" tabindex="-1"></a>As a next step, we run a doublet detection algorithm. Identifying doublets is crucial as they can lead to misclassifications or distortions in downstream analysis steps. Scanpy contains the doublet detection method Scrublet {cite}<span class="in">`Wolock2019`</span>. Scrublet predicts cell doublets using a nearest-neighbor classifier of observed transcriptomes and simulated doublets. {func}<span class="in">`scanpy.pp.scrublet`</span> adds <span class="in">`doublet_score`</span> and <span class="in">`predicted_doublet`</span> to <span class="in">`.obs`</span>. One can now either filter directly on <span class="in">`predicted_doublet`</span> or use the <span class="in">`doublet_score`</span> later during clustering to filter clusters with high doublet scores. </span>
<span id="cb55-170"><a href="#cb55-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-173"><a href="#cb55-173" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-174"><a href="#cb55-174" aria-hidden="true" tabindex="-1"></a>sc.pp.scrublet(adata, batch_key<span class="op">=</span><span class="st">"sample"</span>)</span>
<span id="cb55-175"><a href="#cb55-175" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-176"><a href="#cb55-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-177"><a href="#cb55-177" aria-hidden="true" tabindex="-1"></a>:::{seealso}</span>
<span id="cb55-178"><a href="#cb55-178" aria-hidden="true" tabindex="-1"></a>Alternative methods for doublet detection within the scverse ecosystem are <span class="co">[</span><span class="ot">DoubletDetection</span><span class="co">](https://github.com/JonathanShor/DoubletDetection)</span> and <span class="co">[</span><span class="ot">SOLO</span><span class="co">](https://docs.scvi-tools.org/en/stable/user_guide/models/solo.html)</span>. You can read more about these in the <span class="co">[</span><span class="ot">Doublet Detection chapter</span><span class="co">](https://www.sc-best-practices.org/preprocessing_visualization/quality_control.html#doublet-detection)</span> of Single Cell Best Practices.</span>
<span id="cb55-179"><a href="#cb55-179" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb55-180"><a href="#cb55-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-181"><a href="#cb55-181" aria-hidden="true" tabindex="-1"></a><span class="fu">## Normalization</span></span>
<span id="cb55-182"><a href="#cb55-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-183"><a href="#cb55-183" aria-hidden="true" tabindex="-1"></a>The next preprocessing step is normalization. A common approach is count depth scaling with subsequent log plus one (log1p) transformation. Count depth scaling normalizes the data to a “size factor” such as the median count depth in the dataset, ten thousand (CP10k) or one million (CPM, counts per million). The size factor for count depth scaling can be controlled via <span class="in">`target_sum`</span> in <span class="in">`pp.normalize_total`</span>. We are applying median count depth normalization with log1p transformation (AKA log1PF).</span>
<span id="cb55-184"><a href="#cb55-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-187"><a href="#cb55-187" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-188"><a href="#cb55-188" aria-hidden="true" tabindex="-1"></a><span class="co"># Saving count data</span></span>
<span id="cb55-189"><a href="#cb55-189" aria-hidden="true" tabindex="-1"></a>adata.layers[<span class="st">"counts"</span>] <span class="op">=</span> adata.X.copy()</span>
<span id="cb55-190"><a href="#cb55-190" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-191"><a href="#cb55-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-194"><a href="#cb55-194" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-195"><a href="#cb55-195" aria-hidden="true" tabindex="-1"></a><span class="co"># Normalizing to median total counts</span></span>
<span id="cb55-196"><a href="#cb55-196" aria-hidden="true" tabindex="-1"></a>sc.pp.normalize_total(adata)</span>
<span id="cb55-197"><a href="#cb55-197" aria-hidden="true" tabindex="-1"></a><span class="co"># Logarithmize the data:</span></span>
<span id="cb55-198"><a href="#cb55-198" aria-hidden="true" tabindex="-1"></a>sc.pp.log1p(adata)</span>
<span id="cb55-199"><a href="#cb55-199" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-200"><a href="#cb55-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-201"><a href="#cb55-201" aria-hidden="true" tabindex="-1"></a><span class="fu">## Feature selection</span></span>
<span id="cb55-202"><a href="#cb55-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-203"><a href="#cb55-203" aria-hidden="true" tabindex="-1"></a>As a next step, we want to reduce the dimensionality of the dataset and only include the most informative genes. This step is commonly known as feature selection. The scanpy function <span class="in">`pp.highly_variable_genes`</span> annotates highly variable genes by reproducing the implementations of Seurat {cite}<span class="in">`Satija2015`</span>, Cell Ranger {cite}<span class="in">`Zheng2017`</span>, and Seurat v3 {cite}<span class="in">`stuart2019comprehensive`</span> depending on the chosen <span class="in">`flavor`</span>. </span>
<span id="cb55-204"><a href="#cb55-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-207"><a href="#cb55-207" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-208"><a href="#cb55-208" aria-hidden="true" tabindex="-1"></a>sc.pp.highly_variable_genes(adata, n_top_genes<span class="op">=</span><span class="dv">2000</span>, batch_key<span class="op">=</span><span class="st">"sample"</span>)</span>
<span id="cb55-209"><a href="#cb55-209" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-210"><a href="#cb55-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-213"><a href="#cb55-213" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-214"><a href="#cb55-214" aria-hidden="true" tabindex="-1"></a>sc.pl.highly_variable_genes(adata)</span>
<span id="cb55-215"><a href="#cb55-215" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-216"><a href="#cb55-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-217"><a href="#cb55-217" aria-hidden="true" tabindex="-1"></a><span class="fu">## Dimensionality Reduction</span></span>
<span id="cb55-218"><a href="#cb55-218" aria-hidden="true" tabindex="-1"></a>Reduce the dimensionality of the data by running principal component analysis (PCA), which reveals the main axes of variation and denoises the data.</span>
<span id="cb55-219"><a href="#cb55-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-222"><a href="#cb55-222" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-223"><a href="#cb55-223" aria-hidden="true" tabindex="-1"></a>sc.tl.pca(adata)</span>
<span id="cb55-224"><a href="#cb55-224" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-225"><a href="#cb55-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-226"><a href="#cb55-226" aria-hidden="true" tabindex="-1"></a>Let us inspect the contribution of single PCs to the total variance in the data. This gives us information about how many PCs we should consider in order to compute the neighborhood relations of cells, e.g. used in the clustering function {func}<span class="in">`~scanpy.tl.leiden`</span> or {func}<span class="in">`~scanpy.tl.tsne`</span>. In our experience, often a rough estimate of the number of PCs does fine.</span>
<span id="cb55-227"><a href="#cb55-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-230"><a href="#cb55-230" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-231"><a href="#cb55-231" aria-hidden="true" tabindex="-1"></a>sc.pl.pca_variance_ratio(adata, n_pcs<span class="op">=</span><span class="dv">50</span>, log<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb55-232"><a href="#cb55-232" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-233"><a href="#cb55-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-234"><a href="#cb55-234" aria-hidden="true" tabindex="-1"></a><span class="fu">## Visualization</span></span>
<span id="cb55-235"><a href="#cb55-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-236"><a href="#cb55-236" aria-hidden="true" tabindex="-1"></a>Let us compute the neighborhood graph of cells using the PCA representation of the data matrix.</span>
<span id="cb55-237"><a href="#cb55-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-240"><a href="#cb55-240" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-241"><a href="#cb55-241" aria-hidden="true" tabindex="-1"></a>sc.pp.neighbors(adata)</span>
<span id="cb55-242"><a href="#cb55-242" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-243"><a href="#cb55-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-244"><a href="#cb55-244" aria-hidden="true" tabindex="-1"></a>We suggest embedding the graph in two dimensions using UMAP (McInnes et al., 2018), see below. </span>
<span id="cb55-245"><a href="#cb55-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-248"><a href="#cb55-248" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-249"><a href="#cb55-249" aria-hidden="true" tabindex="-1"></a>sc.tl.umap(adata)</span>
<span id="cb55-250"><a href="#cb55-250" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-251"><a href="#cb55-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-252"><a href="#cb55-252" aria-hidden="true" tabindex="-1"></a>We can now visualize the UMAP according to the <span class="in">`sample`</span>. </span>
<span id="cb55-253"><a href="#cb55-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-256"><a href="#cb55-256" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-257"><a href="#cb55-257" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(adata, color<span class="op">=</span><span class="st">"sample"</span>)</span>
<span id="cb55-258"><a href="#cb55-258" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-259"><a href="#cb55-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-260"><a href="#cb55-260" aria-hidden="true" tabindex="-1"></a>Even though the data considered in this tutorial includes two different samples, we only observe a minor batch effect and we can continue with clustering and annotation of our data. </span>
<span id="cb55-261"><a href="#cb55-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-262"><a href="#cb55-262" aria-hidden="true" tabindex="-1"></a>If you inspect batch effects in your UMAP it can be beneficial to integrate across samples and perform batch correction/integration. </span>
<span id="cb55-263"><a href="#cb55-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-264"><a href="#cb55-264" aria-hidden="true" tabindex="-1"></a><span class="fu">## Clustering</span></span>
<span id="cb55-265"><a href="#cb55-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-266"><a href="#cb55-266" aria-hidden="true" tabindex="-1"></a>As with Seurat and many other frameworks, we recommend the Leiden graph-clustering method (community detection based on optimizing modularity) {cite}<span class="in">`traag2019louvain`</span>. Note that Leiden clustering directly clusters the neighborhood graph of cells, which we already computed in the previous section.</span>
<span id="cb55-267"><a href="#cb55-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-270"><a href="#cb55-270" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-271"><a href="#cb55-271" aria-hidden="true" tabindex="-1"></a>sc.tl.leiden(adata, flavor<span class="op">=</span><span class="st">"igraph"</span>)</span>
<span id="cb55-272"><a href="#cb55-272" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-273"><a href="#cb55-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-276"><a href="#cb55-276" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-277"><a href="#cb55-277" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(adata, color<span class="op">=</span>[<span class="st">"leiden"</span>])</span>
<span id="cb55-278"><a href="#cb55-278" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-279"><a href="#cb55-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-280"><a href="#cb55-280" aria-hidden="true" tabindex="-1"></a><span class="fu">## Re-assess quality control and cell filtering </span></span>
<span id="cb55-281"><a href="#cb55-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-282"><a href="#cb55-282" aria-hidden="true" tabindex="-1"></a>As indicated before, we will now re-assess our filtering strategy by visualizing different QC metrics using UMAP. </span>
<span id="cb55-283"><a href="#cb55-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-286"><a href="#cb55-286" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-287"><a href="#cb55-287" aria-hidden="true" tabindex="-1"></a>adata.obs[<span class="st">"predicted_doublet"</span>] <span class="op">=</span> adata.obs[<span class="st">"predicted_doublet"</span>].astype(<span class="st">"category"</span>)</span>
<span id="cb55-288"><a href="#cb55-288" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(</span>
<span id="cb55-289"><a href="#cb55-289" aria-hidden="true" tabindex="-1"></a>    adata,</span>
<span id="cb55-290"><a href="#cb55-290" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span>[<span class="st">"leiden"</span>, <span class="st">"predicted_doublet"</span>, <span class="st">"doublet_score"</span>],</span>
<span id="cb55-291"><a href="#cb55-291" aria-hidden="true" tabindex="-1"></a>    <span class="co"># increase horizontal space between panels</span></span>
<span id="cb55-292"><a href="#cb55-292" aria-hidden="true" tabindex="-1"></a>    wspace<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb55-293"><a href="#cb55-293" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb55-294"><a href="#cb55-294" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-295"><a href="#cb55-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-296"><a href="#cb55-296" aria-hidden="true" tabindex="-1"></a>We can now subset the AnnData object to exclude cells predicted as doublets: </span>
<span id="cb55-297"><a href="#cb55-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-300"><a href="#cb55-300" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-301"><a href="#cb55-301" aria-hidden="true" tabindex="-1"></a>adata <span class="op">=</span> adata[<span class="op">~</span>adata.obs[<span class="st">"predicted_doublet"</span>].to_numpy()].copy()</span>
<span id="cb55-302"><a href="#cb55-302" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-303"><a href="#cb55-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-306"><a href="#cb55-306" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-307"><a href="#cb55-307" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(</span>
<span id="cb55-308"><a href="#cb55-308" aria-hidden="true" tabindex="-1"></a>    adata, color<span class="op">=</span>[<span class="st">"leiden"</span>, <span class="st">"log1p_total_counts"</span>, <span class="st">"pct_counts_mt"</span>, <span class="st">"log1p_n_genes_by_counts"</span>], wspace<span class="op">=</span><span class="fl">0.5</span>, ncols<span class="op">=</span><span class="dv">2</span></span>
<span id="cb55-309"><a href="#cb55-309" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb55-310"><a href="#cb55-310" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-311"><a href="#cb55-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-312"><a href="#cb55-312" aria-hidden="true" tabindex="-1"></a><span class="fu">## Cell-type annotation</span></span>
<span id="cb55-313"><a href="#cb55-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-316"><a href="#cb55-316" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-317"><a href="#cb55-317" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>: </span>
<span id="cb55-318"><a href="#cb55-318" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> celltypist <span class="im">as</span> ct</span>
<span id="cb55-319"><a href="#cb55-319" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb55-320"><a href="#cb55-320" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install celltypist</span>
<span id="cb55-321"><a href="#cb55-321" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> celltypist <span class="im">as</span> ct</span>
<span id="cb55-322"><a href="#cb55-322" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb55-323"><a href="#cb55-323" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> decoupler <span class="im">as</span> dc</span>
<span id="cb55-324"><a href="#cb55-324" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb55-325"><a href="#cb55-325" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>pip install decoupler</span>
<span id="cb55-326"><a href="#cb55-326" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> decoupler <span class="im">as</span> dc</span>
<span id="cb55-327"><a href="#cb55-327" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-328"><a href="#cb55-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-329"><a href="#cb55-329" aria-hidden="true" tabindex="-1"></a>We have now reached a point where we have obtained a set of cells with decent quality, and we can proceed to their annotation to known cell types. Typically, this is done using genes that are exclusively expressed by a given cell type, or in other words these genes are the marker genes of the cell types, and are thus used to distinguish the heterogeneous groups of cells in our data. Previous efforts have collected and curated various marker genes into available resources, such as <span class="co">[</span><span class="ot">CellMarker</span><span class="co">](http://bio-bigdata.hrbmu.edu.cn/CellMarker/)</span>, <span class="co">[</span><span class="ot">TF-Marker</span><span class="co">](http://bio.liclab.net/TF-Marker/)</span>, and <span class="co">[</span><span class="ot">PanglaoDB</span><span class="co">](https://panglaodb.se/)</span>.</span>
<span id="cb55-330"><a href="#cb55-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-331"><a href="#cb55-331" aria-hidden="true" tabindex="-1"></a>Commonly and classically, cell type annotation uses those marker genes subsequent to the grouping of the cells into clusters. So, let's generate a set of clustering solutions which we can then use to annotate our cell types. Here, we will use the Leiden clustering algorithm which will extract cell communities from our nearest neighbours graph.</span>
<span id="cb55-332"><a href="#cb55-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-335"><a href="#cb55-335" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-336"><a href="#cb55-336" aria-hidden="true" tabindex="-1"></a>sc.tl.leiden(adata, flavor<span class="op">=</span><span class="st">"igraph"</span>, key_added<span class="op">=</span><span class="st">"leiden_res0_02"</span>, resolution<span class="op">=</span><span class="fl">0.02</span>)</span>
<span id="cb55-337"><a href="#cb55-337" aria-hidden="true" tabindex="-1"></a>sc.tl.leiden(adata, flavor<span class="op">=</span><span class="st">"igraph"</span>, key_added<span class="op">=</span><span class="st">"leiden_res0_5"</span>, resolution<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb55-338"><a href="#cb55-338" aria-hidden="true" tabindex="-1"></a>sc.tl.leiden(adata, flavor<span class="op">=</span><span class="st">"igraph"</span>, key_added<span class="op">=</span><span class="st">"leiden_res2"</span>, resolution<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb55-339"><a href="#cb55-339" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-340"><a href="#cb55-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-341"><a href="#cb55-341" aria-hidden="true" tabindex="-1"></a>Notably, the number of clusters that we define is largely arbitrary, and so is the <span class="in">`resolution`</span> parameter that we use to control for it. As such, the number of clusters is ultimately bound to the stable and biologically-meaningful groups that we can ultimately distringuish, typically done by experts in the corresponding field or by using expert-curated prior knowledge in the form of markers.</span>
<span id="cb55-342"><a href="#cb55-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-345"><a href="#cb55-345" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-346"><a href="#cb55-346" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(</span>
<span id="cb55-347"><a href="#cb55-347" aria-hidden="true" tabindex="-1"></a>    adata,</span>
<span id="cb55-348"><a href="#cb55-348" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span>[<span class="st">"leiden_res0_02"</span>, <span class="st">"leiden_res0_5"</span>, <span class="st">"leiden_res2"</span>],</span>
<span id="cb55-349"><a href="#cb55-349" aria-hidden="true" tabindex="-1"></a>    legend_loc<span class="op">=</span><span class="st">"on data"</span>,</span>
<span id="cb55-350"><a href="#cb55-350" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb55-351"><a href="#cb55-351" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-352"><a href="#cb55-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-353"><a href="#cb55-353" aria-hidden="true" tabindex="-1"></a>Though UMAPs should not be over-interpreted, here we can already see that in the highest resolution our data is over-clustered, while the lowest resolution is likely grouping cells which belong to distinct cell identities.</span>
<span id="cb55-354"><a href="#cb55-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-355"><a href="#cb55-355" aria-hidden="true" tabindex="-1"></a><span class="fu">### Marker gene set</span></span>
<span id="cb55-356"><a href="#cb55-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-357"><a href="#cb55-357" aria-hidden="true" tabindex="-1"></a>Let's define a set of marker genes for the main cell types that we expect to see in this dataset. These were adapted from <span class="co">[</span><span class="ot">Single Cell Best Practices annotation chapter</span><span class="co">](https://www.sc-best-practices.org/cellular_structure/annotation.html)</span>, for a more detailed overview and best practices in cell type annotation, we refer the user to it.</span>
<span id="cb55-358"><a href="#cb55-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-361"><a href="#cb55-361" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-362"><a href="#cb55-362" aria-hidden="true" tabindex="-1"></a>marker_genes <span class="op">=</span> {</span>
<span id="cb55-363"><a href="#cb55-363" aria-hidden="true" tabindex="-1"></a>    <span class="st">"CD14+ Mono"</span>: [<span class="st">"FCN1"</span>, <span class="st">"CD14"</span>],</span>
<span id="cb55-364"><a href="#cb55-364" aria-hidden="true" tabindex="-1"></a>    <span class="st">"CD16+ Mono"</span>: [<span class="st">"TCF7L2"</span>, <span class="st">"FCGR3A"</span>, <span class="st">"LYN"</span>],</span>
<span id="cb55-365"><a href="#cb55-365" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note: DMXL2 should be negative</span></span>
<span id="cb55-366"><a href="#cb55-366" aria-hidden="true" tabindex="-1"></a>    <span class="st">"cDC2"</span>: [<span class="st">"CST3"</span>, <span class="st">"COTL1"</span>, <span class="st">"LYZ"</span>, <span class="st">"DMXL2"</span>, <span class="st">"CLEC10A"</span>, <span class="st">"FCER1A"</span>],</span>
<span id="cb55-367"><a href="#cb55-367" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Erythroblast"</span>: [<span class="st">"MKI67"</span>, <span class="st">"HBA1"</span>, <span class="st">"HBB"</span>],</span>
<span id="cb55-368"><a href="#cb55-368" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note HBM and GYPA are negative markers</span></span>
<span id="cb55-369"><a href="#cb55-369" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Proerythroblast"</span>: [<span class="st">"CDK6"</span>, <span class="st">"SYNGR1"</span>, <span class="st">"HBM"</span>, <span class="st">"GYPA"</span>],</span>
<span id="cb55-370"><a href="#cb55-370" aria-hidden="true" tabindex="-1"></a>    <span class="st">"NK"</span>: [<span class="st">"GNLY"</span>, <span class="st">"NKG7"</span>, <span class="st">"CD247"</span>, <span class="st">"FCER1G"</span>, <span class="st">"TYROBP"</span>, <span class="st">"KLRG1"</span>, <span class="st">"FCGR3A"</span>],</span>
<span id="cb55-371"><a href="#cb55-371" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ILC"</span>: [<span class="st">"ID2"</span>, <span class="st">"PLCG2"</span>, <span class="st">"GNLY"</span>, <span class="st">"SYNE1"</span>],</span>
<span id="cb55-372"><a href="#cb55-372" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Naive CD20+ B"</span>: [<span class="st">"MS4A1"</span>, <span class="st">"IL4R"</span>, <span class="st">"IGHD"</span>, <span class="st">"FCRL1"</span>, <span class="st">"IGHM"</span>],</span>
<span id="cb55-373"><a href="#cb55-373" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note IGHD and IGHM are negative markers</span></span>
<span id="cb55-374"><a href="#cb55-374" aria-hidden="true" tabindex="-1"></a>    <span class="st">"B cells"</span>: [<span class="st">"MS4A1"</span>, <span class="st">"ITGB1"</span>, <span class="st">"COL4A4"</span>, <span class="st">"PRDM1"</span>, <span class="st">"IRF4"</span>, <span class="st">"PAX5"</span>, <span class="st">"BCL11A"</span>, <span class="st">"BLK"</span>, <span class="st">"IGHD"</span>, <span class="st">"IGHM"</span>],</span>
<span id="cb55-375"><a href="#cb55-375" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Plasma cells"</span>: [<span class="st">"MZB1"</span>, <span class="st">"HSP90B1"</span>, <span class="st">"FNDC3B"</span>, <span class="st">"PRDM1"</span>, <span class="st">"IGKC"</span>, <span class="st">"JCHAIN"</span>],</span>
<span id="cb55-376"><a href="#cb55-376" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Plasmablast"</span>: [<span class="st">"XBP1"</span>, <span class="st">"PRDM1"</span>, <span class="st">"PAX5"</span>],  <span class="co"># Note PAX5 is a negative marker</span></span>
<span id="cb55-377"><a href="#cb55-377" aria-hidden="true" tabindex="-1"></a>    <span class="st">"CD4+ T"</span>: [<span class="st">"CD4"</span>, <span class="st">"IL7R"</span>, <span class="st">"TRBC2"</span>],</span>
<span id="cb55-378"><a href="#cb55-378" aria-hidden="true" tabindex="-1"></a>    <span class="st">"CD8+ T"</span>: [<span class="st">"CD8A"</span>, <span class="st">"CD8B"</span>, <span class="st">"GZMK"</span>, <span class="st">"GZMA"</span>, <span class="st">"CCL5"</span>, <span class="st">"GZMB"</span>, <span class="st">"GZMH"</span>, <span class="st">"GZMA"</span>],</span>
<span id="cb55-379"><a href="#cb55-379" aria-hidden="true" tabindex="-1"></a>    <span class="st">"T naive"</span>: [<span class="st">"LEF1"</span>, <span class="st">"CCR7"</span>, <span class="st">"TCF7"</span>],</span>
<span id="cb55-380"><a href="#cb55-380" aria-hidden="true" tabindex="-1"></a>    <span class="st">"pDC"</span>: [<span class="st">"GZMB"</span>, <span class="st">"IL3RA"</span>, <span class="st">"COBLL1"</span>, <span class="st">"TCF4"</span>],</span>
<span id="cb55-381"><a href="#cb55-381" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb55-382"><a href="#cb55-382" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-383"><a href="#cb55-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-386"><a href="#cb55-386" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-387"><a href="#cb55-387" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> group_max(adata: sc.AnnData, groupby: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb55-388"><a href="#cb55-388" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb55-389"><a href="#cb55-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-390"><a href="#cb55-390" aria-hidden="true" tabindex="-1"></a>    agg <span class="op">=</span> sc.get.aggregate(adata, by<span class="op">=</span>groupby, func<span class="op">=</span><span class="st">"mean"</span>)</span>
<span id="cb55-391"><a href="#cb55-391" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.Series(agg.layers[<span class="st">"mean"</span>].<span class="bu">sum</span>(<span class="dv">1</span>), agg.obs[groupby]).idxmax()</span>
<span id="cb55-392"><a href="#cb55-392" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-393"><a href="#cb55-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-396"><a href="#cb55-396" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-397"><a href="#cb55-397" aria-hidden="true" tabindex="-1"></a>sc.pl.dotplot(adata, marker_genes, groupby<span class="op">=</span><span class="st">"leiden_res0_02"</span>)</span>
<span id="cb55-398"><a href="#cb55-398" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-399"><a href="#cb55-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-400"><a href="#cb55-400" aria-hidden="true" tabindex="-1"></a>Here, we can see that cluster {eval}<span class="in">`group_max(adata[:, marker_genes["NK"]], "leiden_res0_02")`</span> perhaps contains an admixture of monocytes and dendritic cells, while in cluster {eval}<span class="in">`group_max(adata[:, marker_genes["B cells"]], "leiden_res0_02")`</span> we have different populations of B lymphocytes. Thus, we should perhaps consider a higher clustering resolution.</span>
<span id="cb55-401"><a href="#cb55-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-404"><a href="#cb55-404" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-405"><a href="#cb55-405" aria-hidden="true" tabindex="-1"></a>sc.pl.dotplot(adata, marker_genes, groupby<span class="op">=</span><span class="st">"leiden_res0_5"</span>)</span>
<span id="cb55-406"><a href="#cb55-406" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-407"><a href="#cb55-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-408"><a href="#cb55-408" aria-hidden="true" tabindex="-1"></a>This seems like a resolution that suitable to distinguish most of the different cell types in our data. Ideally, one would look specifically into each cluster, and attempt to subcluster those if required.</span>
<span id="cb55-409"><a href="#cb55-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-410"><a href="#cb55-410" aria-hidden="true" tabindex="-1"></a><span class="fu">### Automatic label prediction</span></span>
<span id="cb55-411"><a href="#cb55-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-412"><a href="#cb55-412" aria-hidden="true" tabindex="-1"></a>In addition to using marker collections to annotate our labels, there exist approaches to automatically annotate scRNA-seq datasets. One such tool is <span class="co">[</span><span class="ot">CellTypist</span><span class="co">](https://github.com/Teichlab/celltypist)</span>, which uses gradient-descent optimised logistic regression classifiers to predict cell type annotations.</span>
<span id="cb55-413"><a href="#cb55-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-414"><a href="#cb55-414" aria-hidden="true" tabindex="-1"></a>First, we need to retrive the CellTypist models that we wish to use, in this case we will use models with immune cell type and subtype populations generated using 20 tissues from 18 studies (<span class="co">[</span><span class="ot">Domínguez Conde, et al. 2022</span><span class="co">](https://www.science.org/doi/full/10.1126/science.abl5197)</span>). </span>
<span id="cb55-415"><a href="#cb55-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-418"><a href="#cb55-418" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-419"><a href="#cb55-419" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> first_time:</span>
<span id="cb55-420"><a href="#cb55-420" aria-hidden="true" tabindex="-1"></a>    ct.models.download_models(model<span class="op">=</span>[<span class="st">"Immune_All_Low.pkl"</span>], force_update<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb55-421"><a href="#cb55-421" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-422"><a href="#cb55-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-423"><a href="#cb55-423" aria-hidden="true" tabindex="-1"></a>Then we predict the major cell type annotations. In this case we will enable <span class="in">`majority_voting`</span>, which will assign a label to the clusters that we obtained previously.</span>
<span id="cb55-424"><a href="#cb55-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-427"><a href="#cb55-427" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-428"><a href="#cb55-428" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> ct.models.Model.load(model<span class="op">=</span><span class="st">"Immune_All_Low.pkl"</span>)</span>
<span id="cb55-429"><a href="#cb55-429" aria-hidden="true" tabindex="-1"></a>predictions <span class="op">=</span> ct.annotate(adata, model<span class="op">=</span><span class="st">"Immune_All_Low.pkl"</span>, majority_voting<span class="op">=</span><span class="va">True</span>, over_clustering<span class="op">=</span><span class="st">"leiden_res0_5"</span>)</span>
<span id="cb55-430"><a href="#cb55-430" aria-hidden="true" tabindex="-1"></a><span class="co"># convert back to anndata||</span></span>
<span id="cb55-431"><a href="#cb55-431" aria-hidden="true" tabindex="-1"></a>adata <span class="op">=</span> predictions.to_adata()</span>
<span id="cb55-432"><a href="#cb55-432" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-433"><a href="#cb55-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-434"><a href="#cb55-434" aria-hidden="true" tabindex="-1"></a>Let's examine the results of automatic clustering:</span>
<span id="cb55-435"><a href="#cb55-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-438"><a href="#cb55-438" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-439"><a href="#cb55-439" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(adata, color<span class="op">=</span><span class="st">"majority_voting"</span>, ncols<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb55-440"><a href="#cb55-440" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-441"><a href="#cb55-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-442"><a href="#cb55-442" aria-hidden="true" tabindex="-1"></a>Note that our previously 'Unknown' cluster is now assigned as 'Pro-B cells'.</span>
<span id="cb55-443"><a href="#cb55-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-444"><a href="#cb55-444" aria-hidden="true" tabindex="-1"></a><span class="fu">### Annotation with enrichment analysis</span></span>
<span id="cb55-445"><a href="#cb55-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-446"><a href="#cb55-446" aria-hidden="true" tabindex="-1"></a>Automatic cell type labelling with methods that require pre-trained models will not always work as smoothly, as such classifiers need to be trained on and be representitive for a given tissue and the cell types within it. So, as a more generalizable approach to annotate the cells, we can also use the marker genes from any database, for example <span class="co">[</span><span class="ot">PanglaoDB</span><span class="co">](https://panglaodb.se/)</span>. Here we will use it with simple multi-variate linear regression, implemented in <span class="co">[</span><span class="ot">decoupler</span><span class="co">](https://github.com/saezlab/decoupler-py)</span>. Essentially, this will test if any collection of genes are enriched in any of the cells. Ultimately, this approach is similar to many other marker-based classifiers.</span>
<span id="cb55-447"><a href="#cb55-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-448"><a href="#cb55-448" aria-hidden="true" tabindex="-1"></a>Let's get canonical cell markers using with <span class="co">[</span><span class="ot">decoupler</span><span class="co">](https://github.com/saezlab/decoupler-py)</span> which queries the OmniPath metadata-base to obtain the <span class="co">[</span><span class="ot">PanglaoDB</span><span class="co">](https://panglaodb.se/)</span> marker gene database with cannonical cell type markers.</span>
<span id="cb55-449"><a href="#cb55-449" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-452"><a href="#cb55-452" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-453"><a href="#cb55-453" aria-hidden="true" tabindex="-1"></a><span class="co"># Query Omnipath and get PanglaoDB</span></span>
<span id="cb55-454"><a href="#cb55-454" aria-hidden="true" tabindex="-1"></a>markers <span class="op">=</span> dc.get_resource(name<span class="op">=</span><span class="st">"PanglaoDB"</span>, organism<span class="op">=</span><span class="st">"human"</span>)</span>
<span id="cb55-455"><a href="#cb55-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-456"><a href="#cb55-456" aria-hidden="true" tabindex="-1"></a><span class="co"># Print initial information about the markers DataFrame</span></span>
<span id="cb55-457"><a href="#cb55-457" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Initial markers DataFrame shape:"</span>, markers.shape)</span>
<span id="cb55-458"><a href="#cb55-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-459"><a href="#cb55-459" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert canonical_marker to boolean - fixing the conversion</span></span>
<span id="cb55-460"><a href="#cb55-460" aria-hidden="true" tabindex="-1"></a>markers[<span class="st">"canonical_marker"</span>] <span class="op">=</span> markers[<span class="st">"canonical_marker"</span>].astype(<span class="bu">str</span>).<span class="bu">map</span>({<span class="st">'True'</span>: <span class="va">True</span>, <span class="st">'False'</span>: <span class="va">False</span>})</span>
<span id="cb55-461"><a href="#cb55-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-462"><a href="#cb55-462" aria-hidden="true" tabindex="-1"></a><span class="co"># Keep canonical cell type markers alone</span></span>
<span id="cb55-463"><a href="#cb55-463" aria-hidden="true" tabindex="-1"></a>markers <span class="op">=</span> markers[markers[<span class="st">"canonical_marker"</span>] <span class="op">==</span> <span class="va">True</span>]</span>
<span id="cb55-464"><a href="#cb55-464" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Shape after filtering canonical markers:"</span>, markers.shape)</span>
<span id="cb55-465"><a href="#cb55-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-466"><a href="#cb55-466" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove duplicated entries</span></span>
<span id="cb55-467"><a href="#cb55-467" aria-hidden="true" tabindex="-1"></a>markers <span class="op">=</span> markers[<span class="op">~</span>markers.duplicated([<span class="st">"cell_type"</span>, <span class="st">"genesymbol"</span>])]</span>
<span id="cb55-468"><a href="#cb55-468" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Shape after removing duplicates:"</span>, markers.shape)</span>
<span id="cb55-469"><a href="#cb55-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-470"><a href="#cb55-470" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert gene symbols to uppercase in both datasets to ensure consistent matching</span></span>
<span id="cb55-471"><a href="#cb55-471" aria-hidden="true" tabindex="-1"></a>markers[<span class="st">"genesymbol"</span>] <span class="op">=</span> markers[<span class="st">"genesymbol"</span>].<span class="bu">str</span>.upper()</span>
<span id="cb55-472"><a href="#cb55-472" aria-hidden="true" tabindex="-1"></a>adata.var_names <span class="op">=</span> adata.var_names.<span class="bu">str</span>.upper()</span>
<span id="cb55-473"><a href="#cb55-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-474"><a href="#cb55-474" aria-hidden="true" tabindex="-1"></a><span class="co"># Print overlap statistics</span></span>
<span id="cb55-475"><a href="#cb55-475" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Number of unique genes in markers:"</span>, <span class="bu">len</span>(markers[<span class="st">"genesymbol"</span>].unique()))</span>
<span id="cb55-476"><a href="#cb55-476" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of genes in adata:"</span>, adata.n_vars)</span>
<span id="cb55-477"><a href="#cb55-477" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of overlapping genes:"</span>, <span class="bu">len</span>(<span class="bu">set</span>(markers[<span class="st">"genesymbol"</span>].unique()) <span class="op">&amp;</span> <span class="bu">set</span>(adata.var_names)))</span>
<span id="cb55-478"><a href="#cb55-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-479"><a href="#cb55-479" aria-hidden="true" tabindex="-1"></a><span class="co"># Print some example cell types and their marker counts</span></span>
<span id="cb55-480"><a href="#cb55-480" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Number of markers per cell type:"</span>)</span>
<span id="cb55-481"><a href="#cb55-481" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(markers.groupby(<span class="st">"cell_type"</span>)[<span class="st">"genesymbol"</span>].count().sort_values(ascending<span class="op">=</span><span class="va">False</span>).head())</span>
<span id="cb55-482"><a href="#cb55-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-483"><a href="#cb55-483" aria-hidden="true" tabindex="-1"></a><span class="co"># Run MLM with a lower min_n value</span></span>
<span id="cb55-484"><a href="#cb55-484" aria-hidden="true" tabindex="-1"></a>dc.run_mlm(mat<span class="op">=</span>adata, net<span class="op">=</span>markers, weight<span class="op">=</span><span class="va">None</span>, source<span class="op">=</span><span class="st">"cell_type"</span>, target<span class="op">=</span><span class="st">"genesymbol"</span>, verbose<span class="op">=</span><span class="va">True</span>, use_raw<span class="op">=</span><span class="va">False</span>, min_n<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb55-485"><a href="#cb55-485" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-486"><a href="#cb55-486" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-487"><a href="#cb55-487" aria-hidden="true" tabindex="-1"></a>The obtained results are stored in the .obsm key, with <span class="in">`mlm_estimate`</span> representing coefficient t-values:</span>
<span id="cb55-488"><a href="#cb55-488" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-491"><a href="#cb55-491" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-492"><a href="#cb55-492" aria-hidden="true" tabindex="-1"></a>adata.obsm[<span class="st">"mlm_estimate"</span>].head()</span>
<span id="cb55-493"><a href="#cb55-493" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-494"><a href="#cb55-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-495"><a href="#cb55-495" aria-hidden="true" tabindex="-1"></a>To visualize the obtianed scores, we can re-use any of scanpy’s plotting functions. </span>
<span id="cb55-496"><a href="#cb55-496" aria-hidden="true" tabindex="-1"></a>First though, we will extract them from the adata object.</span>
<span id="cb55-497"><a href="#cb55-497" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-500"><a href="#cb55-500" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-501"><a href="#cb55-501" aria-hidden="true" tabindex="-1"></a>acts <span class="op">=</span> dc.get_acts(adata<span class="op">=</span>adata, obsm_key<span class="op">=</span><span class="st">"mlm_estimate"</span>)</span>
<span id="cb55-502"><a href="#cb55-502" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(</span>
<span id="cb55-503"><a href="#cb55-503" aria-hidden="true" tabindex="-1"></a>    acts,</span>
<span id="cb55-504"><a href="#cb55-504" aria-hidden="true" tabindex="-1"></a>    color<span class="op">=</span>[</span>
<span id="cb55-505"><a href="#cb55-505" aria-hidden="true" tabindex="-1"></a>        <span class="st">"majority_voting"</span>,</span>
<span id="cb55-506"><a href="#cb55-506" aria-hidden="true" tabindex="-1"></a>        <span class="st">"B cells"</span>,</span>
<span id="cb55-507"><a href="#cb55-507" aria-hidden="true" tabindex="-1"></a>        <span class="st">"T cells"</span>,</span>
<span id="cb55-508"><a href="#cb55-508" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Monocytes"</span>,</span>
<span id="cb55-509"><a href="#cb55-509" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Erythroid-like and erythroid precursor cells"</span>,</span>
<span id="cb55-510"><a href="#cb55-510" aria-hidden="true" tabindex="-1"></a>        <span class="st">"NK cells"</span>,</span>
<span id="cb55-511"><a href="#cb55-511" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb55-512"><a href="#cb55-512" aria-hidden="true" tabindex="-1"></a>    wspace<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb55-513"><a href="#cb55-513" aria-hidden="true" tabindex="-1"></a>    ncols<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb55-514"><a href="#cb55-514" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb55-515"><a href="#cb55-515" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-516"><a href="#cb55-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-517"><a href="#cb55-517" aria-hidden="true" tabindex="-1"></a>These results further confirm the our automatic annotation with Celltypist. In addition, here we can also transfer the max over-representation score estimates to assign a label to each cluster.</span>
<span id="cb55-518"><a href="#cb55-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-521"><a href="#cb55-521" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-522"><a href="#cb55-522" aria-hidden="true" tabindex="-1"></a>mean_enr <span class="op">=</span> dc.summarize_acts(acts, groupby<span class="op">=</span><span class="st">"leiden_res0_5"</span>, min_std<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb55-523"><a href="#cb55-523" aria-hidden="true" tabindex="-1"></a>annotation_dict <span class="op">=</span> dc.assign_groups(mean_enr)</span>
<span id="cb55-524"><a href="#cb55-524" aria-hidden="true" tabindex="-1"></a>adata.obs[<span class="st">"dc_anno"</span>] <span class="op">=</span> [annotation_dict[clust] <span class="cf">for</span> clust <span class="kw">in</span> adata.obs[<span class="st">"leiden_res0_5"</span>]]</span>
<span id="cb55-525"><a href="#cb55-525" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-526"><a href="#cb55-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-527"><a href="#cb55-527" aria-hidden="true" tabindex="-1"></a>Let's compare all resulting annotations here</span>
<span id="cb55-528"><a href="#cb55-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-531"><a href="#cb55-531" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-532"><a href="#cb55-532" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(adata, color<span class="op">=</span>[<span class="st">"majority_voting"</span>, <span class="st">"dc_anno"</span>], ncols<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb55-533"><a href="#cb55-533" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-534"><a href="#cb55-534" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-535"><a href="#cb55-535" aria-hidden="true" tabindex="-1"></a>Great. We can see that the different approaches to annotate the data are largely concordant. Though, these annotations are decent, cell type annotation is laborous and repetitive task, one which typically requires multiple rounds of sublucstering and re-annotation. Nevertheless, we now have a good basis with which we can further proceed with manually refining our annotations. </span>
<span id="cb55-536"><a href="#cb55-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-537"><a href="#cb55-537" aria-hidden="true" tabindex="-1"></a><span class="fu">### Differentially-expressed Genes as Markers</span></span>
<span id="cb55-538"><a href="#cb55-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-539"><a href="#cb55-539" aria-hidden="true" tabindex="-1"></a>Furthermore, one can also calculate marker genes per cluster and then look up whether we can link those marker genes to any known biology, such as cell types and/or states. This is typically done using simple statistical tests, such as Wilcoxon and t-test, for each cluster vs the rest.</span>
<span id="cb55-540"><a href="#cb55-540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-543"><a href="#cb55-543" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-544"><a href="#cb55-544" aria-hidden="true" tabindex="-1"></a><span class="co"># Obtain cluster-specific differentially expressed genes</span></span>
<span id="cb55-545"><a href="#cb55-545" aria-hidden="true" tabindex="-1"></a>sc.tl.rank_genes_groups(adata, groupby<span class="op">=</span><span class="st">"leiden_res0_5"</span>)</span>
<span id="cb55-546"><a href="#cb55-546" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter those</span></span>
<span id="cb55-547"><a href="#cb55-547" aria-hidden="true" tabindex="-1"></a>sc.tl.filter_rank_genes_groups(adata, min_fold_change<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb55-548"><a href="#cb55-548" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-549"><a href="#cb55-549" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-550"><a href="#cb55-550" aria-hidden="true" tabindex="-1"></a>We can then visualize the top 5 differentially-expressed genes on a dotplot.</span>
<span id="cb55-551"><a href="#cb55-551" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-554"><a href="#cb55-554" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-555"><a href="#cb55-555" aria-hidden="true" tabindex="-1"></a>sc.pl.rank_genes_groups_dotplot(adata, groupby<span class="op">=</span><span class="st">"leiden_res0_5"</span>, standard_scale<span class="op">=</span><span class="st">"var"</span>, n_genes<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb55-556"><a href="#cb55-556" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-557"><a href="#cb55-557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-558"><a href="#cb55-558" aria-hidden="true" tabindex="-1"></a>We see that *LYZ*, *ACT8*, *S100A6*, *S100A4*, and *CST3* are all highly expressed in cluster <span class="in">`3`</span>.</span>
<span id="cb55-559"><a href="#cb55-559" aria-hidden="true" tabindex="-1"></a>Let's visualize those at the UMAP space:</span>
<span id="cb55-560"><a href="#cb55-560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-563"><a href="#cb55-563" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-564"><a href="#cb55-564" aria-hidden="true" tabindex="-1"></a>cluster3_genes <span class="op">=</span> [<span class="st">"LYZ"</span>, <span class="st">"ACTB"</span>, <span class="st">"S100A6"</span>, <span class="st">"S100A4"</span>, <span class="st">"CST3"</span>]</span>
<span id="cb55-565"><a href="#cb55-565" aria-hidden="true" tabindex="-1"></a>sc.pl.umap(adata, color<span class="op">=</span>[<span class="op">*</span>cluster3_genes, <span class="st">"leiden_res0_5"</span>], legend_loc<span class="op">=</span><span class="st">"on data"</span>, frameon<span class="op">=</span><span class="va">False</span>, ncols<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb55-566"><a href="#cb55-566" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb55-567"><a href="#cb55-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-568"><a href="#cb55-568" aria-hidden="true" tabindex="-1"></a>Similarly, we can also generate a Violin plot with the distrubtions of the same genes across the clusters.</span>
<span id="cb55-569"><a href="#cb55-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-572"><a href="#cb55-572" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb55-573"><a href="#cb55-573" aria-hidden="true" tabindex="-1"></a><span class="co">#| scrolled: true</span></span>
<span id="cb55-574"><a href="#cb55-574" aria-hidden="true" tabindex="-1"></a>sc.pl.violin(adata, keys<span class="op">=</span>cluster3_genes[<span class="dv">0</span>:<span class="dv">3</span>], groupby<span class="op">=</span><span class="st">"leiden_res0_5"</span>, multi_panel<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb55-575"><a href="#cb55-575" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>