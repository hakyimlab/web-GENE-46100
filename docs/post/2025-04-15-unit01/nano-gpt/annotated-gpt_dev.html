<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Andrey Karpathy">
<meta name="dcterms.date" content="2025-04-15">
<meta name="description" content="Companion notebook from Karpathys video on building a minimal GPT, annotated by cursors LLM with summary from gemini.">

<title>GENE 46100 - Building a GPT - companion notebook annotated</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">GENE 46100</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html">
 <span class="menu-text">Home</span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#building-a-gpt" id="toc-building-a-gpt" class="nav-link active" data-scroll-target="#building-a-gpt">Building a GPT</a>
  <ul class="collapse">
  <li><a href="#download-the-tiny-shakespeare-dataset" id="toc-download-the-tiny-shakespeare-dataset" class="nav-link" data-scroll-target="#download-the-tiny-shakespeare-dataset">download the tiny shakespeare dataset</a></li>
  <li><a href="#mapping-characters-to-integers-and-vice-versa" id="toc-mapping-characters-to-integers-and-vice-versa" class="nav-link" data-scroll-target="#mapping-characters-to-integers-and-vice-versa">mapping characters to integers and vice versa</a></li>
  <li><a href="#encode-the-data-into-torch-tensor" id="toc-encode-the-data-into-torch-tensor" class="nav-link" data-scroll-target="#encode-the-data-into-torch-tensor">encode the data into torch tensor</a></li>
  <li><a href="#split-up-the-data-into-train-and-validation-sets" id="toc-split-up-the-data-into-train-and-validation-sets" class="nav-link" data-scroll-target="#split-up-the-data-into-train-and-validation-sets">split up the data into train and validation sets</a></li>
  <li><a href="#define-the-block-size" id="toc-define-the-block-size" class="nav-link" data-scroll-target="#define-the-block-size">define the block size</a></li>
  <li><a href="#define-the-context-and-target-8-examples-in-one-batch" id="toc-define-the-context-and-target-8-examples-in-one-batch" class="nav-link" data-scroll-target="#define-the-context-and-target-8-examples-in-one-batch">define the context and target: 8 examples in one batch</a></li>
  <li><a href="#define-the-batch-size-and-get-the-batch" id="toc-define-the-batch-size-and-get-the-batch" class="nav-link" data-scroll-target="#define-the-batch-size-and-get-the-batch">define the batch size and get the batch</a></li>
  <li><a href="#start-with-a-simple-model-the-bigram-language-model" id="toc-start-with-a-simple-model-the-bigram-language-model" class="nav-link" data-scroll-target="#start-with-a-simple-model-the-bigram-language-model">start with a simple model: the bigram language model</a></li>
  <li><a href="#cross-entropy-loss" id="toc-cross-entropy-loss" class="nav-link" data-scroll-target="#cross-entropy-loss">cross entropy loss</a></li>
  <li><a href="#initialize-the-model-and-compute-the-loss" id="toc-initialize-the-model-and-compute-the-loss" class="nav-link" data-scroll-target="#initialize-the-model-and-compute-the-loss">initialize the model and compute the loss</a></li>
  <li><a href="#generate-text" id="toc-generate-text" class="nav-link" data-scroll-target="#generate-text">generate text</a></li>
  <li><a href="#choose-adamw-as-the-optimizer" id="toc-choose-adamw-as-the-optimizer" class="nav-link" data-scroll-target="#choose-adamw-as-the-optimizer">choose AdamW as the optimizer</a></li>
  <li><a href="#train-the-model" id="toc-train-the-model" class="nav-link" data-scroll-target="#train-the-model">train the model</a></li>
  <li><a href="#generate-text-starting-with-0n-as-initial-context" id="toc-generate-text-starting-with-0n-as-initial-context" class="nav-link" data-scroll-target="#generate-text-starting-with-0n-as-initial-context">generate text starting with 0=<code>\n</code> as initial context</a></li>
  <li><a href="#the-mathematical-trick-in-self-attention" id="toc-the-mathematical-trick-in-self-attention" class="nav-link" data-scroll-target="#the-mathematical-trick-in-self-attention">The mathematical trick in self-attention</a></li>
  <li><a href="#version-1-using-a-for-loop-to-compute-the-weighted-aggregation" id="toc-version-1-using-a-for-loop-to-compute-the-weighted-aggregation" class="nav-link" data-scroll-target="#version-1-using-a-for-loop-to-compute-the-weighted-aggregation">version 1: using a for loop to compute the weighted aggregation</a></li>
  <li><a href="#version-2-using-matrix-multiply-for-a-weighted-aggregation" id="toc-version-2-using-matrix-multiply-for-a-weighted-aggregation" class="nav-link" data-scroll-target="#version-2-using-matrix-multiply-for-a-weighted-aggregation">version 2: using matrix multiply for a weighted aggregation</a></li>
  <li><a href="#version-3-use-softmax" id="toc-version-3-use-softmax" class="nav-link" data-scroll-target="#version-3-use-softmax">version 3: use Softmax</a></li>
  <li><a href="#softmax-function" id="toc-softmax-function" class="nav-link" data-scroll-target="#softmax-function">softmax function</a></li>
  <li><a href="#version-4-self-attention" id="toc-version-4-self-attention" class="nav-link" data-scroll-target="#version-4-self-attention">version 4: self-attention</a></li>
  <li><a href="#check-that-x-xc-is-is-the-correlation-matrix-if-x-is-normalized" id="toc-check-that-x-xc-is-is-the-correlation-matrix-if-x-is-normalized" class="nav-link" data-scroll-target="#check-that-x-xc-is-is-the-correlation-matrix-if-x-is-normalized">Check that X X’/C is is the correlation matrix if X is normalized</a></li>
  <li><a href="#layernorm1d" id="toc-layernorm1d" class="nav-link" data-scroll-target="#layernorm1d">LayerNorm1d</a></li>
  <li><a href="#french-to-english-translation-example" id="toc-french-to-english-translation-example" class="nav-link" data-scroll-target="#french-to-english-translation-example">French to English translation example:</a></li>
  <li><a href="#full-finished-code-for-reference" id="toc-full-finished-code-for-reference" class="nav-link" data-scroll-target="#full-finished-code-for-reference">Full finished code, for reference</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Building a GPT - companion notebook annotated</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>

<div>
  <div class="description">
    Companion notebook from Karpathys video on building a minimal GPT, annotated by cursors LLM with summary from gemini.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Andrey Karpathy </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 15, 2025</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="building-a-gpt" class="level2">
<h2 class="anchored" data-anchor-id="building-a-gpt">Building a GPT</h2>
<p>Companion notebook to the <a href="https://karpathy.ai/zero-to-hero.html">Zero To Hero</a> video on GPT. Downloaded from <a href="https://colab.research.google.com/drive/1JMLa53HDuA-i7ZBmqV7ZnA3c_fvtXnx-?usp=sharing">here</a></p>
<p>(https://github.com/karpathy/nanoGPT)</p>
<section id="download-the-tiny-shakespeare-dataset" class="level3">
<h3 class="anchored" data-anchor-id="download-the-tiny-shakespeare-dataset">download the tiny shakespeare dataset</h3>
<div id="59fc39e7" class="cell" data-execution_count="1">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># Download the tiny shakespeare dataset</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co">#!wget https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="29ba3e6c" class="cell" data-execution_count="2">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># read it in to inspect it</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">'input.txt'</span>, <span class="st">'r'</span>, encoding<span class="op">=</span><span class="st">'utf-8'</span>) <span class="im">as</span> f:</span>
<span id="cb2-3"><a href="#cb2-3"></a>    text <span class="op">=</span> f.read()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cbaabcfa" class="cell" data-execution_count="3">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># print the length of the dataset</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="bu">print</span>(<span class="st">"length of dataset in characters: "</span>, <span class="bu">len</span>(text))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>length of dataset in characters:  1115394</code></pre>
</div>
</div>
<div id="fa026a17" class="cell" data-execution_count="4">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># let's look at the first 1000 characters</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="bu">print</span>(text[:<span class="dv">1000</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>First Citizen:
Before we proceed any further, hear me speak.

All:
Speak, speak.

First Citizen:
You are all resolved rather to die than to famish?

All:
Resolved. resolved.

First Citizen:
First, you know Caius Marcius is chief enemy to the people.

All:
We know't, we know't.

First Citizen:
Let us kill him, and we'll have corn at our own price.
Is't a verdict?

All:
No more talking on't; let it be done: away, away!

Second Citizen:
One word, good citizens.

First Citizen:
We are accounted poor citizens, the patricians good.
What authority surfeits on would relieve us: if they
would yield us but the superfluity, while it were
wholesome, we might guess they relieved us humanely;
but they think we are too dear: the leanness that
afflicts us, the object of our misery, is as an
inventory to particularise their abundance; our
sufferance is a gain to them Let us revenge this with
our pikes, ere we become rakes: for the gods know I
speak this in hunger for bread, not in thirst for revenge.

</code></pre>
</div>
</div>
<div id="1aac16f0" class="cell" data-execution_count="5">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># here are all the unique characters that occur in this text</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>chars <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(text)))</span>
<span id="cb7-3"><a href="#cb7-3"></a>vocab_size <span class="op">=</span> <span class="bu">len</span>(chars)</span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="bu">print</span>(<span class="st">''</span>.join(chars))</span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="bu">print</span>(vocab_size)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
 !$&amp;',-.3:;?ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
65</code></pre>
</div>
</div>
</section>
<section id="mapping-characters-to-integers-and-vice-versa" class="level3">
<h3 class="anchored" data-anchor-id="mapping-characters-to-integers-and-vice-versa">mapping characters to integers and vice versa</h3>
<div id="2453f382" class="cell" data-execution_count="6">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># create a mapping from characters to integers</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>stoi <span class="op">=</span> { ch:i <span class="cf">for</span> i,ch <span class="kw">in</span> <span class="bu">enumerate</span>(chars) }</span>
<span id="cb9-3"><a href="#cb9-3"></a>itos <span class="op">=</span> { i:ch <span class="cf">for</span> i,ch <span class="kw">in</span> <span class="bu">enumerate</span>(chars) }</span>
<span id="cb9-4"><a href="#cb9-4"></a>encode <span class="op">=</span> <span class="kw">lambda</span> s: [stoi[c] <span class="cf">for</span> c <span class="kw">in</span> s] <span class="co"># encoder: take a string, output a list of integers</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>decode <span class="op">=</span> <span class="kw">lambda</span> l: <span class="st">''</span>.join([itos[i] <span class="cf">for</span> i <span class="kw">in</span> l]) <span class="co"># decoder: take a list of integers, output a string</span></span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="bu">print</span>(encode(<span class="st">"hii there"</span>))</span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="bu">print</span>(decode(encode(<span class="st">"hii there"</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[46, 47, 47, 1, 58, 46, 43, 56, 43]
hii there</code></pre>
</div>
</div>
</section>
<section id="encode-the-data-into-torch-tensor" class="level3">
<h3 class="anchored" data-anchor-id="encode-the-data-into-torch-tensor">encode the data into torch tensor</h3>
<div id="742e63db" class="cell" data-execution_count="7">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># let's now encode the entire text dataset and store it into a torch.Tensor</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="im">import</span> torch <span class="co"># we use PyTorch: [https://pytorch.org](https://pytorch.org)</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>data <span class="op">=</span> torch.tensor(encode(text), dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="bu">print</span>(data.shape, data.dtype)</span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="bu">print</span>(data[:<span class="dv">1000</span>]) <span class="co"># the 1000 characters we looked at earier will to the GPT look like this</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([1115394]) torch.int64
tensor([18, 47, 56, 57, 58,  1, 15, 47, 58, 47, 64, 43, 52, 10,  0, 14, 43, 44,
        53, 56, 43,  1, 61, 43,  1, 54, 56, 53, 41, 43, 43, 42,  1, 39, 52, 63,
         1, 44, 59, 56, 58, 46, 43, 56,  6,  1, 46, 43, 39, 56,  1, 51, 43,  1,
        57, 54, 43, 39, 49,  8,  0,  0, 13, 50, 50, 10,  0, 31, 54, 43, 39, 49,
         6,  1, 57, 54, 43, 39, 49,  8,  0,  0, 18, 47, 56, 57, 58,  1, 15, 47,
        58, 47, 64, 43, 52, 10,  0, 37, 53, 59,  1, 39, 56, 43,  1, 39, 50, 50,
         1, 56, 43, 57, 53, 50, 60, 43, 42,  1, 56, 39, 58, 46, 43, 56,  1, 58,
        53,  1, 42, 47, 43,  1, 58, 46, 39, 52,  1, 58, 53,  1, 44, 39, 51, 47,
        57, 46, 12,  0,  0, 13, 50, 50, 10,  0, 30, 43, 57, 53, 50, 60, 43, 42,
         8,  1, 56, 43, 57, 53, 50, 60, 43, 42,  8,  0,  0, 18, 47, 56, 57, 58,
         1, 15, 47, 58, 47, 64, 43, 52, 10,  0, 18, 47, 56, 57, 58,  6,  1, 63,
        53, 59,  1, 49, 52, 53, 61,  1, 15, 39, 47, 59, 57,  1, 25, 39, 56, 41,
        47, 59, 57,  1, 47, 57,  1, 41, 46, 47, 43, 44,  1, 43, 52, 43, 51, 63,
         1, 58, 53,  1, 58, 46, 43,  1, 54, 43, 53, 54, 50, 43,  8,  0,  0, 13,
        50, 50, 10,  0, 35, 43,  1, 49, 52, 53, 61,  5, 58,  6,  1, 61, 43,  1,
        49, 52, 53, 61,  5, 58,  8,  0,  0, 18, 47, 56, 57, 58,  1, 15, 47, 58,
        47, 64, 43, 52, 10,  0, 24, 43, 58,  1, 59, 57,  1, 49, 47, 50, 50,  1,
        46, 47, 51,  6,  1, 39, 52, 42,  1, 61, 43,  5, 50, 50,  1, 46, 39, 60,
        43,  1, 41, 53, 56, 52,  1, 39, 58,  1, 53, 59, 56,  1, 53, 61, 52,  1,
        54, 56, 47, 41, 43,  8,  0, 21, 57,  5, 58,  1, 39,  1, 60, 43, 56, 42,
        47, 41, 58, 12,  0,  0, 13, 50, 50, 10,  0, 26, 53,  1, 51, 53, 56, 43,
         1, 58, 39, 50, 49, 47, 52, 45,  1, 53, 52,  5, 58, 11,  1, 50, 43, 58,
         1, 47, 58,  1, 40, 43,  1, 42, 53, 52, 43, 10,  1, 39, 61, 39, 63,  6,
         1, 39, 61, 39, 63,  2,  0,  0, 31, 43, 41, 53, 52, 42,  1, 15, 47, 58,
        47, 64, 43, 52, 10,  0, 27, 52, 43,  1, 61, 53, 56, 42,  6,  1, 45, 53,
        53, 42,  1, 41, 47, 58, 47, 64, 43, 52, 57,  8,  0,  0, 18, 47, 56, 57,
        58,  1, 15, 47, 58, 47, 64, 43, 52, 10,  0, 35, 43,  1, 39, 56, 43,  1,
        39, 41, 41, 53, 59, 52, 58, 43, 42,  1, 54, 53, 53, 56,  1, 41, 47, 58,
        47, 64, 43, 52, 57,  6,  1, 58, 46, 43,  1, 54, 39, 58, 56, 47, 41, 47,
        39, 52, 57,  1, 45, 53, 53, 42,  8,  0, 35, 46, 39, 58,  1, 39, 59, 58,
        46, 53, 56, 47, 58, 63,  1, 57, 59, 56, 44, 43, 47, 58, 57,  1, 53, 52,
         1, 61, 53, 59, 50, 42,  1, 56, 43, 50, 47, 43, 60, 43,  1, 59, 57, 10,
         1, 47, 44,  1, 58, 46, 43, 63,  0, 61, 53, 59, 50, 42,  1, 63, 47, 43,
        50, 42,  1, 59, 57,  1, 40, 59, 58,  1, 58, 46, 43,  1, 57, 59, 54, 43,
        56, 44, 50, 59, 47, 58, 63,  6,  1, 61, 46, 47, 50, 43,  1, 47, 58,  1,
        61, 43, 56, 43,  0, 61, 46, 53, 50, 43, 57, 53, 51, 43,  6,  1, 61, 43,
         1, 51, 47, 45, 46, 58,  1, 45, 59, 43, 57, 57,  1, 58, 46, 43, 63,  1,
        56, 43, 50, 47, 43, 60, 43, 42,  1, 59, 57,  1, 46, 59, 51, 39, 52, 43,
        50, 63, 11,  0, 40, 59, 58,  1, 58, 46, 43, 63,  1, 58, 46, 47, 52, 49,
         1, 61, 43,  1, 39, 56, 43,  1, 58, 53, 53,  1, 42, 43, 39, 56, 10,  1,
        58, 46, 43,  1, 50, 43, 39, 52, 52, 43, 57, 57,  1, 58, 46, 39, 58,  0,
        39, 44, 44, 50, 47, 41, 58, 57,  1, 59, 57,  6,  1, 58, 46, 43,  1, 53,
        40, 48, 43, 41, 58,  1, 53, 44,  1, 53, 59, 56,  1, 51, 47, 57, 43, 56,
        63,  6,  1, 47, 57,  1, 39, 57,  1, 39, 52,  0, 47, 52, 60, 43, 52, 58,
        53, 56, 63,  1, 58, 53,  1, 54, 39, 56, 58, 47, 41, 59, 50, 39, 56, 47,
        57, 43,  1, 58, 46, 43, 47, 56,  1, 39, 40, 59, 52, 42, 39, 52, 41, 43,
        11,  1, 53, 59, 56,  0, 57, 59, 44, 44, 43, 56, 39, 52, 41, 43,  1, 47,
        57,  1, 39,  1, 45, 39, 47, 52,  1, 58, 53,  1, 58, 46, 43, 51,  1, 24,
        43, 58,  1, 59, 57,  1, 56, 43, 60, 43, 52, 45, 43,  1, 58, 46, 47, 57,
         1, 61, 47, 58, 46,  0, 53, 59, 56,  1, 54, 47, 49, 43, 57,  6,  1, 43,
        56, 43,  1, 61, 43,  1, 40, 43, 41, 53, 51, 43,  1, 56, 39, 49, 43, 57,
        10,  1, 44, 53, 56,  1, 58, 46, 43,  1, 45, 53, 42, 57,  1, 49, 52, 53,
        61,  1, 21,  0, 57, 54, 43, 39, 49,  1, 58, 46, 47, 57,  1, 47, 52,  1,
        46, 59, 52, 45, 43, 56,  1, 44, 53, 56,  1, 40, 56, 43, 39, 42,  6,  1,
        52, 53, 58,  1, 47, 52,  1, 58, 46, 47, 56, 57, 58,  1, 44, 53, 56,  1,
        56, 43, 60, 43, 52, 45, 43,  8,  0,  0])</code></pre>
</div>
</div>
</section>
<section id="split-up-the-data-into-train-and-validation-sets" class="level3">
<h3 class="anchored" data-anchor-id="split-up-the-data-into-train-and-validation-sets">split up the data into train and validation sets</h3>
<div id="14c10d42" class="cell" data-execution_count="8">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="co"># split up the data into train and validation sets</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>n <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.9</span><span class="op">*</span><span class="bu">len</span>(data)) <span class="co"># first 90% will be train, rest val</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>train_data <span class="op">=</span> data[:n]</span>
<span id="cb13-4"><a href="#cb13-4"></a>val_data <span class="op">=</span> data[n:]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="define-the-block-size" class="level3">
<h3 class="anchored" data-anchor-id="define-the-block-size">define the block size</h3>
<div id="48af431c" class="cell" data-execution_count="9">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a>block_size <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>train_data[:block_size<span class="op">+</span><span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>tensor([18, 47, 56, 57, 58,  1, 15, 47, 58])</code></pre>
</div>
</div>
</section>
<section id="define-the-context-and-target-8-examples-in-one-batch" class="level3">
<h3 class="anchored" data-anchor-id="define-the-context-and-target-8-examples-in-one-batch">define the context and target: 8 examples in one batch</h3>
<div id="01664152" class="cell" data-execution_count="10">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a>x <span class="op">=</span> train_data[:block_size]</span>
<span id="cb16-2"><a href="#cb16-2"></a>y <span class="op">=</span> train_data[<span class="dv">1</span>:block_size<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(block_size):</span>
<span id="cb16-4"><a href="#cb16-4"></a>    context <span class="op">=</span> x[:t<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb16-5"><a href="#cb16-5"></a>    target <span class="op">=</span> y[t]</span>
<span id="cb16-6"><a href="#cb16-6"></a>    <span class="bu">print</span>(<span class="ss">f"when input is </span><span class="sc">{</span>context<span class="sc">}</span><span class="ss"> the target: </span><span class="sc">{</span>target<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>when input is tensor([18]) the target: 47
when input is tensor([18, 47]) the target: 56
when input is tensor([18, 47, 56]) the target: 57
when input is tensor([18, 47, 56, 57]) the target: 58
when input is tensor([18, 47, 56, 57, 58]) the target: 1
when input is tensor([18, 47, 56, 57, 58,  1]) the target: 15
when input is tensor([18, 47, 56, 57, 58,  1, 15]) the target: 47
when input is tensor([18, 47, 56, 57, 58,  1, 15, 47]) the target: 58</code></pre>
</div>
</div>
</section>
<section id="define-the-batch-size-and-get-the-batch" class="level3">
<h3 class="anchored" data-anchor-id="define-the-batch-size-and-get-the-batch">define the batch size and get the batch</h3>
<div id="d1a80647" class="cell" data-execution_count="11">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb18-2"><a href="#cb18-2"></a>batch_size <span class="op">=</span> <span class="dv">4</span> <span class="co"># how many independent sequences will we process in parallel?</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>block_size <span class="op">=</span> <span class="dv">8</span> <span class="co"># what is the maximum context length for predictions?</span></span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="kw">def</span> get_batch(split):</span>
<span id="cb18-6"><a href="#cb18-6"></a>    <span class="co"># generate a small batch of data of inputs x and targets y</span></span>
<span id="cb18-7"><a href="#cb18-7"></a>    data <span class="op">=</span> train_data <span class="cf">if</span> split <span class="op">==</span> <span class="st">'train'</span> <span class="cf">else</span> val_data</span>
<span id="cb18-8"><a href="#cb18-8"></a>    ix <span class="op">=</span> torch.randint(<span class="bu">len</span>(data) <span class="op">-</span> block_size, (batch_size,))</span>
<span id="cb18-9"><a href="#cb18-9"></a>    x <span class="op">=</span> torch.stack([data[i:i<span class="op">+</span>block_size] <span class="cf">for</span> i <span class="kw">in</span> ix])</span>
<span id="cb18-10"><a href="#cb18-10"></a>    y <span class="op">=</span> torch.stack([data[i<span class="op">+</span><span class="dv">1</span>:i<span class="op">+</span>block_size<span class="op">+</span><span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> ix])</span>
<span id="cb18-11"><a href="#cb18-11"></a>    <span class="cf">return</span> x, y</span>
<span id="cb18-12"><a href="#cb18-12"></a></span>
<span id="cb18-13"><a href="#cb18-13"></a>xb, yb <span class="op">=</span> get_batch(<span class="st">'train'</span>)</span>
<span id="cb18-14"><a href="#cb18-14"></a><span class="bu">print</span>(<span class="st">'inputs:'</span>)</span>
<span id="cb18-15"><a href="#cb18-15"></a><span class="bu">print</span>(xb.shape)</span>
<span id="cb18-16"><a href="#cb18-16"></a><span class="bu">print</span>(xb)</span>
<span id="cb18-17"><a href="#cb18-17"></a><span class="bu">print</span>(<span class="st">'targets:'</span>)</span>
<span id="cb18-18"><a href="#cb18-18"></a><span class="bu">print</span>(yb.shape)</span>
<span id="cb18-19"><a href="#cb18-19"></a><span class="bu">print</span>(yb)</span>
<span id="cb18-20"><a href="#cb18-20"></a></span>
<span id="cb18-21"><a href="#cb18-21"></a><span class="bu">print</span>(<span class="st">'----'</span>)</span>
<span id="cb18-22"><a href="#cb18-22"></a></span>
<span id="cb18-23"><a href="#cb18-23"></a><span class="cf">for</span> b <span class="kw">in</span> <span class="bu">range</span>(batch_size): <span class="co"># batch dimension</span></span>
<span id="cb18-24"><a href="#cb18-24"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(block_size): <span class="co"># time dimension</span></span>
<span id="cb18-25"><a href="#cb18-25"></a>        context <span class="op">=</span> xb[b, :t<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb18-26"><a href="#cb18-26"></a>        target <span class="op">=</span> yb[b,t]</span>
<span id="cb18-27"><a href="#cb18-27"></a>        <span class="bu">print</span>(<span class="ss">f"when input is </span><span class="sc">{</span>context<span class="sc">.</span>tolist()<span class="sc">}</span><span class="ss"> the target: </span><span class="sc">{</span>target<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>inputs:
torch.Size([4, 8])
tensor([[24, 43, 58,  5, 57,  1, 46, 43],
        [44, 53, 56,  1, 58, 46, 39, 58],
        [52, 58,  1, 58, 46, 39, 58,  1],
        [25, 17, 27, 10,  0, 21,  1, 54]])
targets:
torch.Size([4, 8])
tensor([[43, 58,  5, 57,  1, 46, 43, 39],
        [53, 56,  1, 58, 46, 39, 58,  1],
        [58,  1, 58, 46, 39, 58,  1, 46],
        [17, 27, 10,  0, 21,  1, 54, 39]])
----
when input is [24] the target: 43
when input is [24, 43] the target: 58
when input is [24, 43, 58] the target: 5
when input is [24, 43, 58, 5] the target: 57
when input is [24, 43, 58, 5, 57] the target: 1
when input is [24, 43, 58, 5, 57, 1] the target: 46
when input is [24, 43, 58, 5, 57, 1, 46] the target: 43
when input is [24, 43, 58, 5, 57, 1, 46, 43] the target: 39
when input is [44] the target: 53
when input is [44, 53] the target: 56
when input is [44, 53, 56] the target: 1
when input is [44, 53, 56, 1] the target: 58
when input is [44, 53, 56, 1, 58] the target: 46
when input is [44, 53, 56, 1, 58, 46] the target: 39
when input is [44, 53, 56, 1, 58, 46, 39] the target: 58
when input is [44, 53, 56, 1, 58, 46, 39, 58] the target: 1
when input is [52] the target: 58
when input is [52, 58] the target: 1
when input is [52, 58, 1] the target: 58
when input is [52, 58, 1, 58] the target: 46
when input is [52, 58, 1, 58, 46] the target: 39
when input is [52, 58, 1, 58, 46, 39] the target: 58
when input is [52, 58, 1, 58, 46, 39, 58] the target: 1
when input is [52, 58, 1, 58, 46, 39, 58, 1] the target: 46
when input is [25] the target: 17
when input is [25, 17] the target: 27
when input is [25, 17, 27] the target: 10
when input is [25, 17, 27, 10] the target: 0
when input is [25, 17, 27, 10, 0] the target: 21
when input is [25, 17, 27, 10, 0, 21] the target: 1
when input is [25, 17, 27, 10, 0, 21, 1] the target: 54
when input is [25, 17, 27, 10, 0, 21, 1, 54] the target: 39</code></pre>
</div>
</div>
</section>
<section id="start-with-a-simple-model-the-bigram-language-model" class="level3">
<h3 class="anchored" data-anchor-id="start-with-a-simple-model-the-bigram-language-model">start with a simple model: the bigram language model</h3>
<div id="a8d1ed22" class="cell" data-execution_count="12">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a><span class="co"># define the bigram language model</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="im">import</span> torch</span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="im">from</span> torch.nn <span class="im">import</span> functional <span class="im">as</span> F</span>
<span id="cb20-5"><a href="#cb20-5"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb20-6"><a href="#cb20-6"></a></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="kw">class</span> BigramLanguageModel(nn.Module):</span>
<span id="cb20-8"><a href="#cb20-8"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, vocab_size):</span>
<span id="cb20-9"><a href="#cb20-9"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb20-10"><a href="#cb20-10"></a>        <span class="va">self</span>.token_embedding_table <span class="op">=</span> nn.Embedding(vocab_size, vocab_size)</span>
<span id="cb20-11"><a href="#cb20-11"></a></span>
<span id="cb20-12"><a href="#cb20-12"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, idx, targets<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb20-13"><a href="#cb20-13"></a>        <span class="co"># idx and targets are both (B,T) tensor of integers</span></span>
<span id="cb20-14"><a href="#cb20-14"></a>        logits <span class="op">=</span> <span class="va">self</span>.token_embedding_table(idx) <span class="co"># (B,T,C)</span></span>
<span id="cb20-15"><a href="#cb20-15"></a></span>
<span id="cb20-16"><a href="#cb20-16"></a>        <span class="cf">if</span> targets <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb20-17"><a href="#cb20-17"></a>            loss <span class="op">=</span> <span class="va">None</span></span>
<span id="cb20-18"><a href="#cb20-18"></a>        <span class="cf">else</span>:</span>
<span id="cb20-19"><a href="#cb20-19"></a>            B, T, C <span class="op">=</span> logits.shape</span>
<span id="cb20-20"><a href="#cb20-20"></a>            logits <span class="op">=</span> logits.view(B<span class="op">*</span>T, C)</span>
<span id="cb20-21"><a href="#cb20-21"></a>            targets <span class="op">=</span> targets.view(B<span class="op">*</span>T)</span>
<span id="cb20-22"><a href="#cb20-22"></a>            loss <span class="op">=</span> F.cross_entropy(logits, targets)</span>
<span id="cb20-23"><a href="#cb20-23"></a></span>
<span id="cb20-24"><a href="#cb20-24"></a>        <span class="cf">return</span> logits, loss</span>
<span id="cb20-25"><a href="#cb20-25"></a></span>
<span id="cb20-26"><a href="#cb20-26"></a>    <span class="kw">def</span> generate(<span class="va">self</span>, idx, max_new_tokens):</span>
<span id="cb20-27"><a href="#cb20-27"></a>        <span class="co"># idx is (B, T) array of indices in the current context</span></span>
<span id="cb20-28"><a href="#cb20-28"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_new_tokens):</span>
<span id="cb20-29"><a href="#cb20-29"></a>            <span class="co"># get the predictions</span></span>
<span id="cb20-30"><a href="#cb20-30"></a>            logits, loss <span class="op">=</span> <span class="va">self</span>(idx)</span>
<span id="cb20-31"><a href="#cb20-31"></a>            <span class="co"># focus only on the last time step</span></span>
<span id="cb20-32"><a href="#cb20-32"></a>            logits <span class="op">=</span> logits[:, <span class="op">-</span><span class="dv">1</span>, :] <span class="co"># becomes (B, C)</span></span>
<span id="cb20-33"><a href="#cb20-33"></a>            <span class="co"># apply softmax to get probabilities</span></span>
<span id="cb20-34"><a href="#cb20-34"></a>            probs <span class="op">=</span> F.softmax(logits, dim<span class="op">=-</span><span class="dv">1</span>) <span class="co"># (B, C)</span></span>
<span id="cb20-35"><a href="#cb20-35"></a>            <span class="co"># sample from the distribution</span></span>
<span id="cb20-36"><a href="#cb20-36"></a>            idx_next <span class="op">=</span> torch.multinomial(probs, num_samples<span class="op">=</span><span class="dv">1</span>) <span class="co"># (B, 1)</span></span>
<span id="cb20-37"><a href="#cb20-37"></a>            <span class="co"># append sampled index to the running sequence</span></span>
<span id="cb20-38"><a href="#cb20-38"></a>            idx <span class="op">=</span> torch.cat((idx, idx_next), dim<span class="op">=</span><span class="dv">1</span>) <span class="co"># (B, T+1)</span></span>
<span id="cb20-39"><a href="#cb20-39"></a>        <span class="cf">return</span> idx</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="cross-entropy-loss" class="level3">
<h3 class="anchored" data-anchor-id="cross-entropy-loss">cross entropy loss</h3>
<p>Loss = <span class="math inline">-\sum_{i}(y_i * \log(p_i))</span>x</p>
<p>where:</p>
<p><span class="math inline">y_i</span> = actual probability (0 or 1 for the <span class="math inline">i</span>-th class) <span class="math inline">p_i</span> = predicted probability for the <span class="math inline">i</span>-th class <span class="math inline">\sum</span> = sum over all classes (characters)</p>
<p>This is the loss for a single token prediction. The total loss reported by F.cross_entropy is the average loss across all B*T tokens in the batch, where:</p>
<p>B = batch_size T = block_size (sequence length)</p>
<p>Before training, we would expect the model to predict the next character from a uniform distribution (random guessing). The probability for the correct character would be <span class="math inline">1 / \text{vocab_size}</span>.</p>
<p>Expected initial loss <span class="math inline">\approx - \log(1 / \text{vocab_size}) = \log(\text{vocab_size})</span> <span class="math inline">\log(65) \approx 4.1744</span></p>
</section>
<section id="initialize-the-model-and-compute-the-loss" class="level3">
<h3 class="anchored" data-anchor-id="initialize-the-model-and-compute-the-loss">initialize the model and compute the loss</h3>
<div id="173be945" class="cell" data-execution_count="13">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a>m <span class="op">=</span> BigramLanguageModel(vocab_size)</span>
<span id="cb21-2"><a href="#cb21-2"></a>logits, loss <span class="op">=</span> m(xb, yb) <span class="co"># xb/yb are from the previous cell (B=4, T=8)</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="bu">print</span>(logits.shape) <span class="co"># Expected: (B, T, C) = (4, 8, 65)</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="bu">print</span>(loss) <span class="co"># Expected: Around 4.17</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([32, 65])
tensor(4.8786, grad_fn=&lt;NllLossBackward0&gt;)</code></pre>
</div>
</div>
</section>
<section id="generate-text" class="level3">
<h3 class="anchored" data-anchor-id="generate-text">generate text</h3>
<div id="75f78621" class="cell" data-execution_count="14">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a><span class="bu">print</span>(decode(m.generate(idx <span class="op">=</span> torch.zeros((<span class="dv">1</span>, <span class="dv">1</span>), dtype<span class="op">=</span>torch.<span class="bu">long</span>), max_new_tokens<span class="op">=</span><span class="dv">100</span>)[<span class="dv">0</span>].tolist()))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
SKIcLT;AcELMoTbvZv C?nq-QE33:CJqkOKH-q;:la!oiywkHjgChzbQ?u!3bLIgwevmyFJGUGp
wnYWmnxKWWev-tDqXErVKLgJ</code></pre>
</div>
</div>
</section>
<section id="choose-adamw-as-the-optimizer" class="level3">
<h3 class="anchored" data-anchor-id="choose-adamw-as-the-optimizer">choose AdamW as the optimizer</h3>
<div id="38dc5e3d" class="cell" data-execution_count="15">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a>optimizer <span class="op">=</span> torch.optim.AdamW(m.parameters(), lr<span class="op">=</span><span class="fl">1e-3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="train-the-model" class="level3">
<h3 class="anchored" data-anchor-id="train-the-model">train the model</h3>
<div id="f071e081" class="cell" data-execution_count="16">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a>batch_size <span class="op">=</span> <span class="dv">32</span> <span class="co"># Redefine batch size for training</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="cf">for</span> steps <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>): <span class="co"># # sample a batch of data</span></span>
<span id="cb26-3"><a href="#cb26-3"></a>    xb, yb <span class="op">=</span> get_batch(<span class="st">'train'</span>)</span>
<span id="cb26-4"><a href="#cb26-4"></a></span>
<span id="cb26-5"><a href="#cb26-5"></a>    <span class="co"># evaluate the loss</span></span>
<span id="cb26-6"><a href="#cb26-6"></a>    logits, loss <span class="op">=</span> m(xb, yb)</span>
<span id="cb26-7"><a href="#cb26-7"></a>    optimizer.zero_grad(set_to_none<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb26-8"><a href="#cb26-8"></a>    loss.backward()</span>
<span id="cb26-9"><a href="#cb26-9"></a>    optimizer.step()</span>
<span id="cb26-10"><a href="#cb26-10"></a></span>
<span id="cb26-11"><a href="#cb26-11"></a><span class="bu">print</span>(loss.item())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>4.65630578994751</code></pre>
</div>
</div>
</section>
<section id="generate-text-starting-with-0n-as-initial-context" class="level3">
<h3 class="anchored" data-anchor-id="generate-text-starting-with-0n-as-initial-context">generate text starting with 0=<code>\n</code> as initial context</h3>
<div id="cffc0479" class="cell" data-execution_count="17">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a><span class="bu">print</span>(decode(m.generate(idx <span class="op">=</span> torch.zeros((<span class="dv">1</span>, <span class="dv">1</span>), dtype<span class="op">=</span>torch.<span class="bu">long</span>), max_new_tokens<span class="op">=</span><span class="dv">500</span>)[<span class="dv">0</span>].tolist()))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
oTo.JUZ!!zqe!
xBP qbs$Gy'AcOmrLwwt
p$x;Seh-onQbfM?OjKbn'NwUAW -Np3fkz$FVwAUEa-wzWC -wQo-R!v -Mj?,SPiTyZ;o-opr$mOiPJEYD-CfigkzD3p3?zvS;ADz;.y?o,ivCuC'zqHxcVT cHA
rT'Fd,SBMZyOslg!NXeF$sBe,juUzLq?w-wzP-h
ERjjxlgJzPbHxf$ q,q,KCDCU fqBOQT
SV&amp;CW:xSVwZv'DG'NSPypDhKStKzC -$hslxIVzoivnp ,ethA:NCCGoi
tN!ljjP3fwJMwNelgUzzPGJlgihJ!d?q.d
pSPYgCuCJrIFtb
jQXg
pA.P LP,SPJi
DBcuBM:CixjJ$Jzkq,OLf3KLQLMGph$O 3DfiPHnXKuHMlyjxEiyZib3FaHV-oJa!zoc'XSP :CKGUhd?lgCOF$;;DTHZMlvvcmZAm;:iv'MMgO&amp;Ywbc;BLCUd&amp;vZINLIzkuTGZa
D.?</code></pre>
</div>
</div>
</section>
<section id="the-mathematical-trick-in-self-attention" class="level3">
<h3 class="anchored" data-anchor-id="the-mathematical-trick-in-self-attention">The mathematical trick in self-attention</h3>
<p>toy example illustrating how matrix multiplication can be used for a “weighted aggregation”</p>
<div id="8b585ce4" class="cell" data-execution_count="18">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1"></a>torch.manual_seed(<span class="dv">42</span>)</span>
<span id="cb30-2"><a href="#cb30-2"></a>a <span class="op">=</span> torch.tril(torch.ones(<span class="dv">3</span>, <span class="dv">3</span>)) <span class="co"># Lower triangular matrix of 1s</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>a <span class="op">=</span> a <span class="op">/</span> torch.<span class="bu">sum</span>(a, <span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>) <span class="co"># Normalize rows to sum to 1</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>b <span class="op">=</span> torch.randint(<span class="dv">0</span>,<span class="dv">10</span>,(<span class="dv">3</span>,<span class="dv">2</span>)).<span class="bu">float</span>() <span class="co"># Some data</span></span>
<span id="cb30-5"><a href="#cb30-5"></a>c <span class="op">=</span> a <span class="op">@</span> b <span class="co"># Matrix multiply</span></span>
<span id="cb30-6"><a href="#cb30-6"></a><span class="bu">print</span>(<span class="st">'a='</span>)</span>
<span id="cb30-7"><a href="#cb30-7"></a><span class="bu">print</span>(a)</span>
<span id="cb30-8"><a href="#cb30-8"></a><span class="bu">print</span>(<span class="st">'--'</span>)</span>
<span id="cb30-9"><a href="#cb30-9"></a><span class="bu">print</span>(<span class="st">'b='</span>)</span>
<span id="cb30-10"><a href="#cb30-10"></a><span class="bu">print</span>(b)</span>
<span id="cb30-11"><a href="#cb30-11"></a><span class="bu">print</span>(<span class="st">'--'</span>)</span>
<span id="cb30-12"><a href="#cb30-12"></a><span class="bu">print</span>(<span class="st">'c='</span>)</span>
<span id="cb30-13"><a href="#cb30-13"></a><span class="bu">print</span>(c)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>a=
tensor([[1.0000, 0.0000, 0.0000],
        [0.5000, 0.5000, 0.0000],
        [0.3333, 0.3333, 0.3333]])
--
b=
tensor([[2., 7.],
        [6., 4.],
        [6., 5.]])
--
c=
tensor([[2.0000, 7.0000],
        [4.0000, 5.5000],
        [4.6667, 5.3333]])</code></pre>
</div>
</div>
<div id="e5dcfd8f" class="cell" data-execution_count="19">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1"></a><span class="co"># consider the following toy example:</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb32-3"><a href="#cb32-3"></a>B,T,C <span class="op">=</span> <span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">2</span> <span class="co"># batch, time, channels</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>x <span class="op">=</span> torch.randn(B,T,C)</span>
<span id="cb32-5"><a href="#cb32-5"></a>x.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>torch.Size([4, 8, 2])</code></pre>
</div>
</div>
</section>
<section id="version-1-using-a-for-loop-to-compute-the-weighted-aggregation" class="level3">
<h3 class="anchored" data-anchor-id="version-1-using-a-for-loop-to-compute-the-weighted-aggregation">version 1: using a for loop to compute the weighted aggregation</h3>
<div id="25bd55f8" class="cell" data-execution_count="20">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1"></a><span class="co"># We want x[b,t] = mean_{i&lt;=t} x[b,i]</span></span>
<span id="cb34-2"><a href="#cb34-2"></a>xbow <span class="op">=</span> torch.zeros((B,T,C)) <span class="co"># x bag-of-words (running average)</span></span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="cf">for</span> b <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb34-4"><a href="#cb34-4"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(T):</span>
<span id="cb34-5"><a href="#cb34-5"></a>        xprev <span class="op">=</span> x[b,:t<span class="op">+</span><span class="dv">1</span>] <span class="co"># Select vectors from start up to time t: shape (t+1, C)</span></span>
<span id="cb34-6"><a href="#cb34-6"></a>        xbow[b,t] <span class="op">=</span> torch.mean(xprev, <span class="dv">0</span>) <span class="co"># Compute mean along the time dimension (dim 0)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="version-2-using-matrix-multiply-for-a-weighted-aggregation" class="level3">
<h3 class="anchored" data-anchor-id="version-2-using-matrix-multiply-for-a-weighted-aggregation">version 2: using matrix multiply for a weighted aggregation</h3>
<div id="b640bb4b" class="cell" data-execution_count="21">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1"></a><span class="co"># Create the averaging weight matrix</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>wei <span class="op">=</span> torch.tril(torch.ones(T, T))</span>
<span id="cb35-3"><a href="#cb35-3"></a>wei <span class="op">=</span> wei <span class="op">/</span> wei.<span class="bu">sum</span>(<span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>) <span class="co"># Normalize rows to sum to 1</span></span>
<span id="cb35-4"><a href="#cb35-4"></a><span class="co"># Perform batched matrix multiplication</span></span>
<span id="cb35-5"><a href="#cb35-5"></a>xbow2 <span class="op">=</span> wei <span class="op">@</span> x <span class="co"># (T, T) @ (B, T, C) -&gt; (B, T, C) via broadcasting</span></span>
<span id="cb35-6"><a href="#cb35-6"></a>torch.allclose(xbow, xbow2) <span class="co"># Check if results are identical</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre><code>True</code></pre>
</div>
</div>
</section>
<section id="version-3-use-softmax" class="level3">
<h3 class="anchored" data-anchor-id="version-3-use-softmax">version 3: use Softmax</h3>
<div id="cd0536c4" class="cell" data-execution_count="22">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1"></a>tril <span class="op">=</span> torch.tril(torch.ones(T, T))</span>
<span id="cb37-2"><a href="#cb37-2"></a>wei <span class="op">=</span> torch.zeros((T,T))</span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="co"># Mask out future positions by setting them to -infinity before softmax</span></span>
<span id="cb37-4"><a href="#cb37-4"></a>wei <span class="op">=</span> wei.masked_fill(tril <span class="op">==</span> <span class="dv">0</span>, <span class="bu">float</span>(<span class="st">'-inf'</span>))</span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="co"># Apply softmax to get row-wise probability distributions (weights)</span></span>
<span id="cb37-6"><a href="#cb37-6"></a>wei <span class="op">=</span> F.softmax(wei, dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="co"># Perform weighted aggregation</span></span>
<span id="cb37-8"><a href="#cb37-8"></a>xbow3 <span class="op">=</span> wei <span class="op">@</span> x</span>
<span id="cb37-9"><a href="#cb37-9"></a>torch.allclose(xbow, xbow3) <span class="co"># Check if results are identical</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>True</code></pre>
</div>
</div>
</section>
<section id="softmax-function" class="level3">
<h3 class="anchored" data-anchor-id="softmax-function">softmax function</h3>
<p>softmax(<span class="math inline">z_i</span>) = <span class="math inline">\frac{e^{z_i}}{\sum_j e^{z_j}}</span></p>
</section>
<section id="version-4-self-attention" class="level3">
<h3 class="anchored" data-anchor-id="version-4-self-attention">version 4: self-attention</h3>
<div id="bc387af0" class="cell" data-execution_count="23">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb39-2"><a href="#cb39-2"></a>B,T,C <span class="op">=</span> <span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">32</span> <span class="co"># batch, time, channels (embedding dimension)</span></span>
<span id="cb39-3"><a href="#cb39-3"></a>x <span class="op">=</span> torch.randn(B,T,C)</span>
<span id="cb39-4"><a href="#cb39-4"></a></span>
<span id="cb39-5"><a href="#cb39-5"></a><span class="co"># let's see a single Head perform self-attention</span></span>
<span id="cb39-6"><a href="#cb39-6"></a>head_size <span class="op">=</span> <span class="dv">16</span></span>
<span id="cb39-7"><a href="#cb39-7"></a>key <span class="op">=</span> nn.Linear(C, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb39-8"><a href="#cb39-8"></a>query <span class="op">=</span> nn.Linear(C, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb39-9"><a href="#cb39-9"></a>value <span class="op">=</span> nn.Linear(C, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb39-10"><a href="#cb39-10"></a>k <span class="op">=</span> key(x)   <span class="co"># (B, T, head_size)</span></span>
<span id="cb39-11"><a href="#cb39-11"></a>q <span class="op">=</span> query(x) <span class="co"># (B, T, head_size)</span></span>
<span id="cb39-12"><a href="#cb39-12"></a><span class="co"># Compute attention scores ("affinities")</span></span>
<span id="cb39-13"><a href="#cb39-13"></a>wei <span class="op">=</span> q <span class="op">@</span> k.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>) <span class="co"># (B, T, hs) @ (B, hs, T) ---&gt; (B, T, T)</span></span>
<span id="cb39-14"><a href="#cb39-14"></a></span>
<span id="cb39-15"><a href="#cb39-15"></a><span class="co"># Scale the scores</span></span>
<span id="cb39-16"><a href="#cb39-16"></a><span class="co"># Note: Karpathy uses C**-0.5 here (sqrt(embedding_dim)). Standard Transformer uses sqrt(head_size).</span></span>
<span id="cb39-17"><a href="#cb39-17"></a>wei <span class="op">=</span> wei <span class="op">*</span> (C<span class="op">**-</span><span class="fl">0.5</span>)</span>
<span id="cb39-18"><a href="#cb39-18"></a></span>
<span id="cb39-19"><a href="#cb39-19"></a><span class="co"># Apply causal mask</span></span>
<span id="cb39-20"><a href="#cb39-20"></a>tril <span class="op">=</span> torch.tril(torch.ones(T, T))</span>
<span id="cb39-21"><a href="#cb39-21"></a><span class="co">#wei = torch.zeros((T,T)) # This line is commented out in original, was from softmax demo</span></span>
<span id="cb39-22"><a href="#cb39-22"></a>wei <span class="op">=</span> wei.masked_fill(tril <span class="op">==</span> <span class="dv">0</span>, <span class="bu">float</span>(<span class="st">'-inf'</span>)) <span class="co"># Mask future tokens</span></span>
<span id="cb39-23"><a href="#cb39-23"></a></span>
<span id="cb39-24"><a href="#cb39-24"></a><span class="co"># Apply softmax to get attention weights</span></span>
<span id="cb39-25"><a href="#cb39-25"></a>wei <span class="op">=</span> F.softmax(wei, dim<span class="op">=-</span><span class="dv">1</span>) <span class="co"># (B, T, T)</span></span>
<span id="cb39-26"><a href="#cb39-26"></a></span>
<span id="cb39-27"><a href="#cb39-27"></a><span class="co"># Perform weighted aggregation of Values</span></span>
<span id="cb39-28"><a href="#cb39-28"></a>v <span class="op">=</span> value(x) <span class="co"># (B, T, head_size)</span></span>
<span id="cb39-29"><a href="#cb39-29"></a>out <span class="op">=</span> wei <span class="op">@</span> v <span class="co"># (B, T, T) @ (B, T, hs) ---&gt; (B, T, hs)</span></span>
<span id="cb39-30"><a href="#cb39-30"></a><span class="co">#out = wei @ x # This would aggregate original x, not the projected values 'v'</span></span>
<span id="cb39-31"><a href="#cb39-31"></a></span>
<span id="cb39-32"><a href="#cb39-32"></a>out.shape <span class="co"># Expected: (B, T, head_size) = (4, 8, 16)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>torch.Size([4, 8, 16])</code></pre>
</div>
</div>
<div id="64febc53" class="cell" data-execution_count="24">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1"></a>wei[<span class="dv">0</span>] <span class="co"># Show attention weights for the first sequence in the batch</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre><code>tensor([[1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.4264, 0.5736, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.3151, 0.3022, 0.3827, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.3007, 0.2272, 0.2467, 0.2253, 0.0000, 0.0000, 0.0000, 0.0000],
        [0.1635, 0.2048, 0.1776, 0.1616, 0.2926, 0.0000, 0.0000, 0.0000],
        [0.1403, 0.2272, 0.1454, 0.1244, 0.2678, 0.0949, 0.0000, 0.0000],
        [0.1554, 0.1815, 0.1224, 0.1213, 0.1428, 0.1603, 0.1164, 0.0000],
        [0.0952, 0.1217, 0.1130, 0.1453, 0.1137, 0.1180, 0.1467, 0.1464]],
       grad_fn=&lt;SelectBackward0&gt;)</code></pre>
</div>
</div>
</section>
<section id="check-that-x-xc-is-is-the-correlation-matrix-if-x-is-normalized" class="level3">
<h3 class="anchored" data-anchor-id="check-that-x-xc-is-is-the-correlation-matrix-if-x-is-normalized">Check that X X’/C is is the correlation matrix if X is normalized</h3>
<p>```{r showing xx’/C is correlation matrix if X is normalized}</p>
<p>nC = 64 X = matrix(rnorm(4<em>64), nrow=4, ncol=nC) ## make it so that the third token is similar to the last one X[2,] = X[4,]</em>0.5 + X[2,]*0.5 ## normalize X X = t(scale(t(X)))</p>
<p>q = X k = X v = X</p>
<p>qkt = q %*% t(k)/(nC-1) xcor = cor(t(q),t(k)) dim(xcor) dim(qkt) cat(“xcor”) xcor cat(“—qkt”) qkt</p>
<p>cat(“are xcor and qkt equal?”) all.equal(xcor, qkt)</p>
<p>par(mar=c(5, 6, 4, 2) + 0.1) # increase left margin to avoid cutting of the y label par(pty=“s”) # Set plot type to “square” plot(c(xcor), c(qkt),cex=3,cex.lab=3,cex.axis=2,cex.main=2,cex.sub=2); abline(0,1) par(pty=“m”) # Reset to default plot type par(mar=c(5, 4, 4, 2) + 0.1) # Reset to default margins</p>
<pre><code>





### Notes:

Attention is a communication mechanism. Can be seen as nodes in a directed graph looking at each other and aggregating information with a weighted sum from all nodes that point to them, with data-dependent weights. 

- There is no notion of space. Attention simply acts over a set of vectors. This is why we need to positionally encode tokens. 
    example: "the cat sat on the mat" should be different from "the mat sat on the cat"
- Each example across batch dimension is of course processed completely independently and never "talk" to each other. 
- In an "encoder" attention block just delete the single line that does masking with tril, allowing all tokens to communicate. This block here is called a "decoder" attention block because it has triangular masking, and is usually used in autoregressive settings, like language modeling. 
- "self-attention" just means that the keys and values are produced from the same source as queries (all come from x). In "cross-attention", the queries still get produced from x, but the keys and values come from some other, external source (e.g. an encoder module)

### why scaled attention?

"Scaled" attention additionaly divides wei by 1/sqrt(head_size). This makes it so when input Q,K are unit variance, wei will be unit variance too and Softmax will stay diffuse and not saturate too much. Illustration below

::: {#751f4b08 .cell execution_count=25}
``` {.python .cell-code}
# Demonstrate variance without scaling
k_unscaled = torch.randn(B,T,head_size)
q_unscaled = torch.randn(B,T,head_size)
wei_unscaled = q_unscaled @ k_unscaled.transpose(-2, -1)
print(f"k var: {k_unscaled.var():.4f}, q var: {q_unscaled.var():.4f}, wei (unscaled) var: {wei_unscaled.var():.4f}")

# Demonstrate variance *with* scaling (using head_size for illustration)
k = torch.randn(B,T,head_size)
q = torch.randn(B,T,head_size)
wei = q @ k.transpose(-2, -1) * head_size**-0.5 # Scale by sqrt(head_size)
print(f"k var: {k.var():.4f}, q var: {q.var():.4f}, wei (scaled) var: {wei.var():.4f}") # Variance should be closer to 1</code></pre>
<div class="cell-output cell-output-stdout">
<pre><code>k var: 1.0449, q var: 1.0700, wei (unscaled) var: 17.4690
k var: 0.9006, q var: 1.0037, wei (scaled) var: 0.9957</code></pre>
</div>
<p>:::</p>
<div id="7ab86db5" class="cell" data-execution_count="26">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1"></a>k.var() <span class="co"># Should be close to 1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>tensor(0.9006)</code></pre>
</div>
</div>
<div id="79937ef8" class="cell" data-execution_count="27">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1"></a>q.var() <span class="co"># Should be close to 1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="27">
<pre><code>tensor(1.0037)</code></pre>
</div>
</div>
<div id="e21a12c0" class="cell" data-execution_count="28">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1"></a>wei.var() <span class="co"># With scaling, should be closer to 1 than head_size (16)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="28">
<pre><code>tensor(0.9957)</code></pre>
</div>
</div>
<div id="c5184f63" class="cell" data-execution_count="29">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1"></a><span class="co"># Softmax with small inputs (diffuse distribution)</span></span>
<span id="cb51-2"><a href="#cb51-2"></a>torch.softmax(torch.tensor([<span class="fl">0.1</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.5</span>]), dim<span class="op">=-</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="29">
<pre><code>tensor([0.1925, 0.1426, 0.2351, 0.1426, 0.2872])</code></pre>
</div>
</div>
<div id="5de133c9" class="cell" data-execution_count="30">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1"></a><span class="co"># Softmax with large inputs (simulating unscaled attention scores) -&gt; peaks</span></span>
<span id="cb53-2"><a href="#cb53-2"></a>torch.softmax(torch.tensor([<span class="fl">0.1</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.5</span>])<span class="op">*</span><span class="dv">8</span>, dim<span class="op">=-</span><span class="dv">1</span>) <span class="co"># gets too peaky, converges to one-hot</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="30">
<pre><code>tensor([0.0326, 0.0030, 0.1615, 0.0030, 0.8000])</code></pre>
</div>
</div>
</section>
<section id="layernorm1d" class="level3">
<h3 class="anchored" data-anchor-id="layernorm1d">LayerNorm1d</h3>
<div id="5b02faec" class="cell" data-execution_count="31">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1"></a><span class="kw">class</span> LayerNorm1d: <span class="co"># (used to be BatchNorm1d)</span></span>
<span id="cb55-2"><a href="#cb55-2"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dim, eps<span class="op">=</span><span class="fl">1e-5</span>, momentum<span class="op">=</span><span class="fl">0.1</span>): <span class="co"># Momentum is not used in typical LayerNorm</span></span>
<span id="cb55-3"><a href="#cb55-3"></a>        <span class="va">self</span>.eps <span class="op">=</span> eps</span>
<span id="cb55-4"><a href="#cb55-4"></a>        <span class="co"># Learnable scale and shift parameters, initialized to 1 and 0</span></span>
<span id="cb55-5"><a href="#cb55-5"></a>        <span class="va">self</span>.gamma <span class="op">=</span> torch.ones(dim)</span>
<span id="cb55-6"><a href="#cb55-6"></a>        <span class="va">self</span>.beta <span class="op">=</span> torch.zeros(dim)</span>
<span id="cb55-7"><a href="#cb55-7"></a></span>
<span id="cb55-8"><a href="#cb55-8"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb55-9"><a href="#cb55-9"></a>        <span class="co"># calculate the forward pass</span></span>
<span id="cb55-10"><a href="#cb55-10"></a>        <span class="co"># Calculate mean over the *last* dimension (features/embedding)</span></span>
<span id="cb55-11"><a href="#cb55-11"></a>        xmean <span class="op">=</span> x.mean(<span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>) <span class="co"># batch mean (shape B, 1, C if input B, T, C) --&gt; Needs adjustment for (B,C) input shape here. Assumes input is (B, dim)</span></span>
<span id="cb55-12"><a href="#cb55-12"></a>        <span class="co"># Correction: x is (32, 100). dim=1 is correct for features. Shape (32, 1)</span></span>
<span id="cb55-13"><a href="#cb55-13"></a>        xvar <span class="op">=</span> x.var(<span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>) <span class="co"># batch variance (shape 32, 1)</span></span>
<span id="cb55-14"><a href="#cb55-14"></a>        <span class="co"># Normalize each feature vector independently</span></span>
<span id="cb55-15"><a href="#cb55-15"></a>        xhat <span class="op">=</span> (x <span class="op">-</span> xmean) <span class="op">/</span> torch.sqrt(xvar <span class="op">+</span> <span class="va">self</span>.eps) <span class="co"># normalize to unit variance</span></span>
<span id="cb55-16"><a href="#cb55-16"></a>        <span class="co"># Apply scale and shift</span></span>
<span id="cb55-17"><a href="#cb55-17"></a>        <span class="va">self</span>.out <span class="op">=</span> <span class="va">self</span>.gamma <span class="op">*</span> xhat <span class="op">+</span> <span class="va">self</span>.beta</span>
<span id="cb55-18"><a href="#cb55-18"></a>        <span class="cf">return</span> <span class="va">self</span>.out</span>
<span id="cb55-19"><a href="#cb55-19"></a></span>
<span id="cb55-20"><a href="#cb55-20"></a>    <span class="kw">def</span> parameters(<span class="va">self</span>):</span>
<span id="cb55-21"><a href="#cb55-21"></a>        <span class="co"># Expose gamma and beta as learnable parameters</span></span>
<span id="cb55-22"><a href="#cb55-22"></a>        <span class="cf">return</span> [<span class="va">self</span>.gamma, <span class="va">self</span>.beta]</span>
<span id="cb55-23"><a href="#cb55-23"></a></span>
<span id="cb55-24"><a href="#cb55-24"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb55-25"><a href="#cb55-25"></a>module <span class="op">=</span> LayerNorm1d(<span class="dv">100</span>) <span class="co"># Create LayerNorm for 100 features</span></span>
<span id="cb55-26"><a href="#cb55-26"></a>x <span class="op">=</span> torch.randn(<span class="dv">32</span>, <span class="dv">100</span>) <span class="co"># batch size 32 of 100-dimensional vectors</span></span>
<span id="cb55-27"><a href="#cb55-27"></a>x <span class="op">=</span> module(x)</span>
<span id="cb55-28"><a href="#cb55-28"></a>x.shape <span class="co"># Should be (32, 100)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="31">
<pre><code>torch.Size([32, 100])</code></pre>
</div>
</div>
<p>Explanation of layernorm</p>
<p>Input shape: (B, T, C) where: B = batch size T = sequence length (number of tokens) C = embedding dimension (features of each token) For each token in the sequence (each position T), LayerNorm: Takes its embedding vector of size C Calculates the mean and standard deviation of just that vector Normalizes that vector by subtracting its mean and dividing by its standard deviation Applies the learnable scale (gamma) and shift (beta) parameters So if you have a sequence like “The cat sat”, and each word is represented by a 64-dimensional embedding vector, LayerNorm would: Take “The”’s 64-dimensional vector and normalize it Take “cat”’s 64-dimensional vector and normalize it Take “sat”’s 64-dimensional vector and normalize it Each token’s vector is normalized independently of the others. This is different from BatchNorm, which would normalize across the batch dimension (i.e., looking at the same position across different examples in the batch). This per-token normalization helps maintain stable gradients during training and is particularly important in Transformers where the attention mechanism needs to work with normalized vectors to compute meaningful attention scores.</p>
<div id="3d5d4112" class="cell" data-execution_count="32">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1"></a><span class="co"># Mean and std of the first feature *across the batch*. Not expected to be 0 and 1.</span></span>
<span id="cb57-2"><a href="#cb57-2"></a>x[:,<span class="dv">0</span>].mean(), x[:,<span class="dv">0</span>].std()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="32">
<pre><code>(tensor(0.1469), tensor(0.8803))</code></pre>
</div>
</div>
<div id="31a3c1fe" class="cell" data-execution_count="33">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1"></a><span class="co"># Mean and std *across features* for the first item in the batch. Expected to be ~0 and ~1.</span></span>
<span id="cb59-2"><a href="#cb59-2"></a>x[<span class="dv">0</span>,:].mean(), x[<span class="dv">0</span>,:].std()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="33">
<pre><code>(tensor(2.3842e-09), tensor(1.0000))</code></pre>
</div>
</div>
</section>
<section id="french-to-english-translation-example" class="level3">
<h3 class="anchored" data-anchor-id="french-to-english-translation-example">French to English translation example:</h3>
<div id="1aea58e6" class="cell" data-execution_count="34">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1"></a><span class="co"># &lt;--------- ENCODE ------------------&gt;&lt;--------------- DECODE -----------------&gt;</span></span>
<span id="cb61-2"><a href="#cb61-2"></a><span class="co"># les réseaux de neurones sont géniaux! &lt;START&gt; neural networks are awesome!&lt;</span><span class="re">END</span><span class="co">&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="full-finished-code-for-reference" class="level3">
<h3 class="anchored" data-anchor-id="full-finished-code-for-reference">Full finished code, for reference</h3>
<div id="83e132d7" class="cell" data-execution_count="35">
<details>
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1"></a><span class="co"># Import necessary PyTorch modules</span></span>
<span id="cb62-2"><a href="#cb62-2"></a><span class="im">import</span> torch</span>
<span id="cb62-3"><a href="#cb62-3"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb62-4"><a href="#cb62-4"></a><span class="im">from</span> torch.nn <span class="im">import</span> functional <span class="im">as</span> F</span>
<span id="cb62-5"><a href="#cb62-5"></a></span>
<span id="cb62-6"><a href="#cb62-6"></a><span class="co"># ===== HYPERPARAMETERS =====</span></span>
<span id="cb62-7"><a href="#cb62-7"></a>batch_size <span class="op">=</span> <span class="dv">16</span>       <span class="co"># Number of sequences per batch (Smaller than Bigram training)</span></span>
<span id="cb62-8"><a href="#cb62-8"></a>block_size <span class="op">=</span> <span class="dv">32</span>       <span class="co"># Context length (Larger than Bigram demo)</span></span>
<span id="cb62-9"><a href="#cb62-9"></a>max_iters <span class="op">=</span> <span class="dv">5000</span>      <span class="co"># Total training iterations (More substantial training) </span><span class="al">TODO</span><span class="co"> change to 5000 later</span></span>
<span id="cb62-10"><a href="#cb62-10"></a>eval_interval <span class="op">=</span> <span class="dv">100</span>   <span class="co"># How often to check validation loss</span></span>
<span id="cb62-11"><a href="#cb62-11"></a>learning_rate <span class="op">=</span> <span class="fl">1e-3</span>  <span class="co"># Optimizer learning rate</span></span>
<span id="cb62-12"><a href="#cb62-12"></a>eval_iters <span class="op">=</span> <span class="dv">200</span>      <span class="co"># Number of batches to average for validation loss estimate</span></span>
<span id="cb62-13"><a href="#cb62-13"></a>n_embd <span class="op">=</span> <span class="dv">64</span>           <span class="co"># Embedding dimension (Size of token vectors)</span></span>
<span id="cb62-14"><a href="#cb62-14"></a>n_head <span class="op">=</span> <span class="dv">4</span>            <span class="co"># Number of attention heads</span></span>
<span id="cb62-15"><a href="#cb62-15"></a>n_layer <span class="op">=</span> <span class="dv">4</span>           <span class="co"># Number of Transformer blocks (layers)</span></span>
<span id="cb62-16"><a href="#cb62-16"></a>dropout <span class="op">=</span> <span class="fl">0.0</span>         <span class="co"># Dropout probability (0.0 means no dropout here)</span></span>
<span id="cb62-17"><a href="#cb62-17"></a><span class="co"># ==========================</span></span>
<span id="cb62-18"><a href="#cb62-18"></a></span>
<span id="cb62-19"><a href="#cb62-19"></a><span class="co"># Device selection: MPS (Apple Silicon) &gt; CUDA &gt; CPU</span></span>
<span id="cb62-20"><a href="#cb62-20"></a><span class="cf">if</span> torch.backends.mps.is_available():</span>
<span id="cb62-21"><a href="#cb62-21"></a>    device <span class="op">=</span> torch.device(<span class="st">"mps"</span>)   <span class="co"># Apple Silicon GPU</span></span>
<span id="cb62-22"><a href="#cb62-22"></a><span class="cf">elif</span> torch.cuda.is_available():</span>
<span id="cb62-23"><a href="#cb62-23"></a>    device <span class="op">=</span> torch.device(<span class="st">"cuda"</span>)  <span class="co"># NVIDIA GPU</span></span>
<span id="cb62-24"><a href="#cb62-24"></a><span class="cf">else</span>:</span>
<span id="cb62-25"><a href="#cb62-25"></a>    device <span class="op">=</span> torch.device(<span class="st">"cpu"</span>)   <span class="co"># CPU fallback</span></span>
<span id="cb62-26"><a href="#cb62-26"></a><span class="bu">print</span>(<span class="ss">f"Using device: </span><span class="sc">{</span>device<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb62-27"><a href="#cb62-27"></a></span>
<span id="cb62-28"><a href="#cb62-28"></a><span class="co"># Set random seed for reproducibility</span></span>
<span id="cb62-29"><a href="#cb62-29"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb62-30"><a href="#cb62-30"></a><span class="cf">if</span> device.<span class="bu">type</span> <span class="op">==</span> <span class="st">'cuda'</span>:</span>
<span id="cb62-31"><a href="#cb62-31"></a>    torch.cuda.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb62-32"><a href="#cb62-32"></a><span class="cf">elif</span> device.<span class="bu">type</span> <span class="op">==</span> <span class="st">'mps'</span>:</span>
<span id="cb62-33"><a href="#cb62-33"></a>    torch.mps.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb62-34"><a href="#cb62-34"></a></span>
<span id="cb62-35"><a href="#cb62-35"></a><span class="co"># Load and read the training text (assuming input.txt is available)</span></span>
<span id="cb62-36"><a href="#cb62-36"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">'input.txt'</span>, <span class="st">'r'</span>, encoding<span class="op">=</span><span class="st">'utf-8'</span>) <span class="im">as</span> f:</span>
<span id="cb62-37"><a href="#cb62-37"></a>    text <span class="op">=</span> f.read()</span>
<span id="cb62-38"><a href="#cb62-38"></a></span>
<span id="cb62-39"><a href="#cb62-39"></a><span class="co"># ===== DATA PREPROCESSING =====</span></span>
<span id="cb62-40"><a href="#cb62-40"></a>chars <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(text)))</span>
<span id="cb62-41"><a href="#cb62-41"></a>vocab_size <span class="op">=</span> <span class="bu">len</span>(chars)</span>
<span id="cb62-42"><a href="#cb62-42"></a>stoi <span class="op">=</span> { ch:i <span class="cf">for</span> i,ch <span class="kw">in</span> <span class="bu">enumerate</span>(chars) }   <span class="co"># string to index</span></span>
<span id="cb62-43"><a href="#cb62-43"></a>itos <span class="op">=</span> { i:ch <span class="cf">for</span> i,ch <span class="kw">in</span> <span class="bu">enumerate</span>(chars) }   <span class="co"># index to string</span></span>
<span id="cb62-44"><a href="#cb62-44"></a>encode <span class="op">=</span> <span class="kw">lambda</span> s: [stoi[c] <span class="cf">for</span> c <span class="kw">in</span> s]   <span class="co"># convert string to list of integers</span></span>
<span id="cb62-45"><a href="#cb62-45"></a>decode <span class="op">=</span> <span class="kw">lambda</span> l: <span class="st">''</span>.join([itos[i] <span class="cf">for</span> i <span class="kw">in</span> l])   <span class="co"># convert list of integers to string</span></span>
<span id="cb62-46"><a href="#cb62-46"></a></span>
<span id="cb62-47"><a href="#cb62-47"></a><span class="co"># Split data into training and validation sets</span></span>
<span id="cb62-48"><a href="#cb62-48"></a>data <span class="op">=</span> torch.tensor(encode(text), dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb62-49"><a href="#cb62-49"></a>n <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.9</span><span class="op">*</span><span class="bu">len</span>(data))   <span class="co"># first 90% for training</span></span>
<span id="cb62-50"><a href="#cb62-50"></a>train_data <span class="op">=</span> data[:n]</span>
<span id="cb62-51"><a href="#cb62-51"></a>val_data <span class="op">=</span> data[n:]</span>
<span id="cb62-52"><a href="#cb62-52"></a><span class="co"># =============================</span></span>
<span id="cb62-53"><a href="#cb62-53"></a></span>
<span id="cb62-54"><a href="#cb62-54"></a><span class="co"># ===== DATA LOADING FUNCTION =====</span></span>
<span id="cb62-55"><a href="#cb62-55"></a><span class="kw">def</span> get_batch(split):</span>
<span id="cb62-56"><a href="#cb62-56"></a>    <span class="co">"""Generate a batch of data for training or validation."""</span></span>
<span id="cb62-57"><a href="#cb62-57"></a>    data <span class="op">=</span> train_data <span class="cf">if</span> split <span class="op">==</span> <span class="st">'train'</span> <span class="cf">else</span> val_data</span>
<span id="cb62-58"><a href="#cb62-58"></a>    ix <span class="op">=</span> torch.randint(<span class="bu">len</span>(data) <span class="op">-</span> block_size, (batch_size,))</span>
<span id="cb62-59"><a href="#cb62-59"></a>    x <span class="op">=</span> torch.stack([data[i:i<span class="op">+</span>block_size] <span class="cf">for</span> i <span class="kw">in</span> ix])</span>
<span id="cb62-60"><a href="#cb62-60"></a>    y <span class="op">=</span> torch.stack([data[i<span class="op">+</span><span class="dv">1</span>:i<span class="op">+</span>block_size<span class="op">+</span><span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> ix])</span>
<span id="cb62-61"><a href="#cb62-61"></a>    x, y <span class="op">=</span> x.to(device), y.to(device) <span class="co"># Move data to the target device</span></span>
<span id="cb62-62"><a href="#cb62-62"></a>    <span class="cf">return</span> x, y</span>
<span id="cb62-63"><a href="#cb62-63"></a><span class="co"># ================================</span></span>
<span id="cb62-64"><a href="#cb62-64"></a></span>
<span id="cb62-65"><a href="#cb62-65"></a><span class="co"># ===== LOSS ESTIMATION FUNCTION =====</span></span>
<span id="cb62-66"><a href="#cb62-66"></a><span class="at">@torch.no_grad</span>()   <span class="co"># Disable gradient calculation for efficiency</span></span>
<span id="cb62-67"><a href="#cb62-67"></a><span class="kw">def</span> estimate_loss():</span>
<span id="cb62-68"><a href="#cb62-68"></a>    <span class="co">"""Estimate the loss on training and validation sets."""</span></span>
<span id="cb62-69"><a href="#cb62-69"></a>    out <span class="op">=</span> {}</span>
<span id="cb62-70"><a href="#cb62-70"></a>    model.<span class="bu">eval</span>()   <span class="co"># Set model to evaluation mode</span></span>
<span id="cb62-71"><a href="#cb62-71"></a>    <span class="cf">for</span> split <span class="kw">in</span> [<span class="st">'train'</span>, <span class="st">'val'</span>]:</span>
<span id="cb62-72"><a href="#cb62-72"></a>        losses <span class="op">=</span> torch.zeros(eval_iters)</span>
<span id="cb62-73"><a href="#cb62-73"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(eval_iters):</span>
<span id="cb62-74"><a href="#cb62-74"></a>            X, Y <span class="op">=</span> get_batch(split)</span>
<span id="cb62-75"><a href="#cb62-75"></a>            logits, loss <span class="op">=</span> model(X, Y)</span>
<span id="cb62-76"><a href="#cb62-76"></a>            losses[k] <span class="op">=</span> loss.item()</span>
<span id="cb62-77"><a href="#cb62-77"></a>        out[split] <span class="op">=</span> losses.mean()</span>
<span id="cb62-78"><a href="#cb62-78"></a>    model.train()  <span class="co"># Set model back to training mode</span></span>
<span id="cb62-79"><a href="#cb62-79"></a>    <span class="cf">return</span> out</span>
<span id="cb62-80"><a href="#cb62-80"></a><span class="co"># ===================================</span></span>
<span id="cb62-81"><a href="#cb62-81"></a></span>
<span id="cb62-82"><a href="#cb62-82"></a><span class="co"># ===== </span><span class="al">ATTENTION</span><span class="co"> HEAD IMPLEMENTATION =====</span></span>
<span id="cb62-83"><a href="#cb62-83"></a><span class="kw">class</span> Head(nn.Module):</span>
<span id="cb62-84"><a href="#cb62-84"></a>    <span class="co">"""Single head of self-attention."""</span></span>
<span id="cb62-85"><a href="#cb62-85"></a>    </span>
<span id="cb62-86"><a href="#cb62-86"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, head_size):</span>
<span id="cb62-87"><a href="#cb62-87"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb62-88"><a href="#cb62-88"></a>        <span class="co"># Linear projections for Key, Query, Value</span></span>
<span id="cb62-89"><a href="#cb62-89"></a>        <span class="va">self</span>.key <span class="op">=</span> nn.Linear(n_embd, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb62-90"><a href="#cb62-90"></a>        <span class="va">self</span>.query <span class="op">=</span> nn.Linear(n_embd, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb62-91"><a href="#cb62-91"></a>        <span class="va">self</span>.value <span class="op">=</span> nn.Linear(n_embd, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb62-92"><a href="#cb62-92"></a>        <span class="co"># Causal mask (tril). 'register_buffer' makes it part of the model state but not a parameter to be trained.</span></span>
<span id="cb62-93"><a href="#cb62-93"></a>        <span class="va">self</span>.register_buffer(<span class="st">'tril'</span>, torch.tril(torch.ones(block_size, block_size)))</span>
<span id="cb62-94"><a href="#cb62-94"></a>        <span class="co"># Dropout layer (applied after softmax)</span></span>
<span id="cb62-95"><a href="#cb62-95"></a>        <span class="va">self</span>.dropout <span class="op">=</span> nn.Dropout(dropout)</span>
<span id="cb62-96"><a href="#cb62-96"></a></span>
<span id="cb62-97"><a href="#cb62-97"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb62-98"><a href="#cb62-98"></a>        B,T,C <span class="op">=</span> x.shape <span class="co"># C here is n_embd</span></span>
<span id="cb62-99"><a href="#cb62-99"></a>        <span class="co"># Project input to K, Q, V</span></span>
<span id="cb62-100"><a href="#cb62-100"></a>        k <span class="op">=</span> <span class="va">self</span>.key(x)   <span class="co"># (B,T,head_size)</span></span>
<span id="cb62-101"><a href="#cb62-101"></a>        q <span class="op">=</span> <span class="va">self</span>.query(x) <span class="co"># (B,T,head_size)</span></span>
<span id="cb62-102"><a href="#cb62-102"></a>        <span class="co"># Compute attention scores, scale, mask, softmax</span></span>
<span id="cb62-103"><a href="#cb62-103"></a>        <span class="co"># Note the scaling by C**-0.5 (sqrt(n_embd)) as discussed before</span></span>
<span id="cb62-104"><a href="#cb62-104"></a>        wei <span class="op">=</span> q <span class="op">@</span> k.transpose(<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span> C<span class="op">**-</span><span class="fl">0.5</span>   <span class="co"># (B, T, T)</span></span>
<span id="cb62-105"><a href="#cb62-105"></a>        wei <span class="op">=</span> wei.masked_fill(<span class="va">self</span>.tril[:T, :T] <span class="op">==</span> <span class="dv">0</span>, <span class="bu">float</span>(<span class="st">'-inf'</span>))   <span class="co"># Use dynamic slicing [:T, :T] for flexibility if T &lt; block_size</span></span>
<span id="cb62-106"><a href="#cb62-106"></a>        wei <span class="op">=</span> F.softmax(wei, dim<span class="op">=-</span><span class="dv">1</span>)   <span class="co"># (B, T, T)</span></span>
<span id="cb62-107"><a href="#cb62-107"></a>        wei <span class="op">=</span> <span class="va">self</span>.dropout(wei) <span class="co"># Apply dropout to attention weights</span></span>
<span id="cb62-108"><a href="#cb62-108"></a>        <span class="co"># Weighted aggregation of values</span></span>
<span id="cb62-109"><a href="#cb62-109"></a>        v <span class="op">=</span> <span class="va">self</span>.value(x) <span class="co"># (B,T,head_size)</span></span>
<span id="cb62-110"><a href="#cb62-110"></a>        out <span class="op">=</span> wei <span class="op">@</span> v <span class="co"># (B, T, T) @ (B, T, head_size) -&gt; (B, T, head_size)</span></span>
<span id="cb62-111"><a href="#cb62-111"></a>        <span class="cf">return</span> out</span>
<span id="cb62-112"><a href="#cb62-112"></a><span class="co"># ========================================</span></span>
<span id="cb62-113"><a href="#cb62-113"></a></span>
<span id="cb62-114"><a href="#cb62-114"></a><span class="co"># ===== MULTI-HEAD </span><span class="al">ATTENTION</span><span class="co"> =====</span></span>
<span id="cb62-115"><a href="#cb62-115"></a><span class="kw">class</span> MultiHeadAttention(nn.Module):</span>
<span id="cb62-116"><a href="#cb62-116"></a>    <span class="co">"""Multiple heads of self-attention in parallel."""</span></span>
<span id="cb62-117"><a href="#cb62-117"></a>    </span>
<span id="cb62-118"><a href="#cb62-118"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_heads, head_size):</span>
<span id="cb62-119"><a href="#cb62-119"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb62-120"><a href="#cb62-120"></a>        <span class="va">self</span>.heads <span class="op">=</span> nn.ModuleList([Head(head_size) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_heads)])</span>
<span id="cb62-121"><a href="#cb62-121"></a>        <span class="co"># Linear layer after concatenating heads</span></span>
<span id="cb62-122"><a href="#cb62-122"></a>        <span class="va">self</span>.proj <span class="op">=</span> nn.Linear(n_embd, n_embd) <span class="co"># Projects back to n_embd dimension</span></span>
<span id="cb62-123"><a href="#cb62-123"></a>        <span class="va">self</span>.dropout <span class="op">=</span> nn.Dropout(dropout)</span>
<span id="cb62-124"><a href="#cb62-124"></a></span>
<span id="cb62-125"><a href="#cb62-125"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb62-126"><a href="#cb62-126"></a>        <span class="co"># Compute attention for each head and concatenate results</span></span>
<span id="cb62-127"><a href="#cb62-127"></a>        out <span class="op">=</span> torch.cat([h(x) <span class="cf">for</span> h <span class="kw">in</span> <span class="va">self</span>.heads], dim<span class="op">=-</span><span class="dv">1</span>) <span class="co"># Shape (B, T, num_heads * head_size) = (B, T, n_embd)</span></span>
<span id="cb62-128"><a href="#cb62-128"></a>        <span class="co"># Apply final projection and dropout</span></span>
<span id="cb62-129"><a href="#cb62-129"></a>        out <span class="op">=</span> <span class="va">self</span>.dropout(<span class="va">self</span>.proj(out))</span>
<span id="cb62-130"><a href="#cb62-130"></a>        <span class="cf">return</span> out</span>
<span id="cb62-131"><a href="#cb62-131"></a><span class="co"># ===============================</span></span>
<span id="cb62-132"><a href="#cb62-132"></a></span>
<span id="cb62-133"><a href="#cb62-133"></a><span class="co"># ===== FEED-FORWARD NETWORK =====</span></span>
<span id="cb62-134"><a href="#cb62-134"></a><span class="kw">class</span> FeedFoward(nn.Module):</span>
<span id="cb62-135"><a href="#cb62-135"></a>    <span class="co">"""Simple position-wise feed-forward network with one hidden layer."""</span></span>
<span id="cb62-136"><a href="#cb62-136"></a>    </span>
<span id="cb62-137"><a href="#cb62-137"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n_embd):</span>
<span id="cb62-138"><a href="#cb62-138"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb62-139"><a href="#cb62-139"></a>        <span class="va">self</span>.net <span class="op">=</span> nn.Sequential(</span>
<span id="cb62-140"><a href="#cb62-140"></a>            nn.Linear(n_embd, <span class="dv">4</span> <span class="op">*</span> n_embd),   <span class="co"># Expand dimension (common practice)</span></span>
<span id="cb62-141"><a href="#cb62-141"></a>            nn.ReLU(),                      <span class="co"># Non-linearity</span></span>
<span id="cb62-142"><a href="#cb62-142"></a>            nn.Linear(<span class="dv">4</span> <span class="op">*</span> n_embd, n_embd),   <span class="co"># Project back to original dimension</span></span>
<span id="cb62-143"><a href="#cb62-143"></a>            nn.Dropout(dropout),</span>
<span id="cb62-144"><a href="#cb62-144"></a>        )</span>
<span id="cb62-145"><a href="#cb62-145"></a></span>
<span id="cb62-146"><a href="#cb62-146"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb62-147"><a href="#cb62-147"></a>        <span class="cf">return</span> <span class="va">self</span>.net(x)</span>
<span id="cb62-148"><a href="#cb62-148"></a><span class="co"># ==============================</span></span>
<span id="cb62-149"><a href="#cb62-149"></a></span>
<span id="cb62-150"><a href="#cb62-150"></a><span class="co"># ===== TRANSFORMER BLOCK =====</span></span>
<span id="cb62-151"><a href="#cb62-151"></a><span class="kw">class</span> Block(nn.Module):</span>
<span id="cb62-152"><a href="#cb62-152"></a>    <span class="co">"""Transformer block: communication (attention) followed by computation (FFN)."""</span></span>
<span id="cb62-153"><a href="#cb62-153"></a>    </span>
<span id="cb62-154"><a href="#cb62-154"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n_embd, n_head):</span>
<span id="cb62-155"><a href="#cb62-155"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb62-156"><a href="#cb62-156"></a>        head_size <span class="op">=</span> n_embd <span class="op">//</span> n_head   <span class="co"># Calculate size for each head</span></span>
<span id="cb62-157"><a href="#cb62-157"></a>        <span class="va">self</span>.sa <span class="op">=</span> MultiHeadAttention(n_head, head_size) <span class="co"># Self-Attention layer</span></span>
<span id="cb62-158"><a href="#cb62-158"></a>        <span class="va">self</span>.ffwd <span class="op">=</span> FeedFoward(n_embd) <span class="co"># Feed-Forward layer</span></span>
<span id="cb62-159"><a href="#cb62-159"></a>        <span class="va">self</span>.ln1 <span class="op">=</span> nn.LayerNorm(n_embd) <span class="co"># LayerNorm for Attention input</span></span>
<span id="cb62-160"><a href="#cb62-160"></a>        <span class="va">self</span>.ln2 <span class="op">=</span> nn.LayerNorm(n_embd) <span class="co"># LayerNorm for FFN input</span></span>
<span id="cb62-161"><a href="#cb62-161"></a></span>
<span id="cb62-162"><a href="#cb62-162"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb62-163"><a href="#cb62-163"></a>        <span class="co"># Pre-Normalization variant: Norm -&gt; Sublayer -&gt; Residual</span></span>
<span id="cb62-164"><a href="#cb62-164"></a>        x <span class="op">=</span> x <span class="op">+</span> <span class="va">self</span>.sa(<span class="va">self</span>.ln1(x))  <span class="co"># Attention block</span></span>
<span id="cb62-165"><a href="#cb62-165"></a>        x <span class="op">=</span> x <span class="op">+</span> <span class="va">self</span>.ffwd(<span class="va">self</span>.ln2(x)) <span class="co"># Feed-forward block</span></span>
<span id="cb62-166"><a href="#cb62-166"></a>        <span class="cf">return</span> x</span>
<span id="cb62-167"><a href="#cb62-167"></a><span class="co"># ============================</span></span>
<span id="cb62-168"><a href="#cb62-168"></a></span>
<span id="cb62-169"><a href="#cb62-169"></a><span class="co"># ===== LANGUAGE MODEL =====</span></span>
<span id="cb62-170"><a href="#cb62-170"></a><span class="kw">class</span> BigramLanguageModel(nn.Module):</span>
<span id="cb62-171"><a href="#cb62-171"></a>    <span class="co">"""GPT-like language model using Transformer blocks."""</span></span>
<span id="cb62-172"><a href="#cb62-172"></a>    </span>
<span id="cb62-173"><a href="#cb62-173"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb62-174"><a href="#cb62-174"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb62-175"><a href="#cb62-175"></a>        <span class="co"># Token Embedding Table: Maps character index to embedding vector. (vocab_size, n_embd)</span></span>
<span id="cb62-176"><a href="#cb62-176"></a>        <span class="va">self</span>.token_embedding_table <span class="op">=</span> nn.Embedding(vocab_size, n_embd)</span>
<span id="cb62-177"><a href="#cb62-177"></a>        <span class="co"># Position Embedding Table: Maps position index (0 to block_size-1) to embedding vector. (block_size, n_embd)</span></span>
<span id="cb62-178"><a href="#cb62-178"></a>        <span class="va">self</span>.position_embedding_table <span class="op">=</span> nn.Embedding(block_size, n_embd)</span>
<span id="cb62-179"><a href="#cb62-179"></a>        <span class="co"># Sequence of Transformer Blocks</span></span>
<span id="cb62-180"><a href="#cb62-180"></a>        <span class="va">self</span>.blocks <span class="op">=</span> nn.Sequential(<span class="op">*</span>[Block(n_embd, n_head<span class="op">=</span>n_head) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_layer)])</span>
<span id="cb62-181"><a href="#cb62-181"></a>        <span class="co"># Final Layer Normalization (applied after blocks)</span></span>
<span id="cb62-182"><a href="#cb62-182"></a>        <span class="va">self</span>.ln_f <span class="op">=</span> nn.LayerNorm(n_embd)   <span class="co"># Final layer norm</span></span>
<span id="cb62-183"><a href="#cb62-183"></a>        <span class="co"># Linear Head: Maps final embedding back to vocabulary size to get logits. (n_embd, vocab_size)</span></span>
<span id="cb62-184"><a href="#cb62-184"></a>        <span class="va">self</span>.lm_head <span class="op">=</span> nn.Linear(n_embd, vocab_size)</span>
<span id="cb62-185"><a href="#cb62-185"></a></span>
<span id="cb62-186"><a href="#cb62-186"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, idx, targets<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb62-187"><a href="#cb62-187"></a>        B, T <span class="op">=</span> idx.shape</span>
<span id="cb62-188"><a href="#cb62-188"></a>        </span>
<span id="cb62-189"><a href="#cb62-189"></a>        <span class="co"># Get token embeddings from indices: (B, T) -&gt; (B, T, n_embd)</span></span>
<span id="cb62-190"><a href="#cb62-190"></a>        tok_emb <span class="op">=</span> <span class="va">self</span>.token_embedding_table(idx)</span>
<span id="cb62-191"><a href="#cb62-191"></a>        <span class="co"># Get position embeddings: Create indices 0..T-1, look up embeddings -&gt; (T, n_embd)</span></span>
<span id="cb62-192"><a href="#cb62-192"></a>        pos_emb <span class="op">=</span> <span class="va">self</span>.position_embedding_table(torch.arange(T, device<span class="op">=</span>device))</span>
<span id="cb62-193"><a href="#cb62-193"></a>        <span class="co"># Combine token and position embeddings by addition: (B, T, n_embd). Broadcasting handles the addition.</span></span>
<span id="cb62-194"><a href="#cb62-194"></a>        x <span class="op">=</span> tok_emb <span class="op">+</span> pos_emb   <span class="co"># (B,T,C)</span></span>
<span id="cb62-195"><a href="#cb62-195"></a>        <span class="co"># Pass through Transformer blocks: (B, T, n_embd) -&gt; (B, T, n_embd)</span></span>
<span id="cb62-196"><a href="#cb62-196"></a>        x <span class="op">=</span> <span class="va">self</span>.blocks(x)</span>
<span id="cb62-197"><a href="#cb62-197"></a>        <span class="co"># Apply final LayerNorm</span></span>
<span id="cb62-198"><a href="#cb62-198"></a>        x <span class="op">=</span> <span class="va">self</span>.ln_f(x)</span>
<span id="cb62-199"><a href="#cb62-199"></a>        <span class="co"># Map to vocabulary logits: (B, T, n_embd) -&gt; (B, T, vocab_size)</span></span>
<span id="cb62-200"><a href="#cb62-200"></a>        logits <span class="op">=</span> <span class="va">self</span>.lm_head(x)</span>
<span id="cb62-201"><a href="#cb62-201"></a></span>
<span id="cb62-202"><a href="#cb62-202"></a>        <span class="co"># Calculate loss if targets are provided (same as before)</span></span>
<span id="cb62-203"><a href="#cb62-203"></a>        <span class="cf">if</span> targets <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb62-204"><a href="#cb62-204"></a>            loss <span class="op">=</span> <span class="va">None</span></span>
<span id="cb62-205"><a href="#cb62-205"></a>        <span class="cf">else</span>:</span>
<span id="cb62-206"><a href="#cb62-206"></a>            <span class="co"># Reshape for cross_entropy: (B*T, vocab_size) and (B*T)</span></span>
<span id="cb62-207"><a href="#cb62-207"></a>            B, T, C <span class="op">=</span> logits.shape</span>
<span id="cb62-208"><a href="#cb62-208"></a>            logits <span class="op">=</span> logits.view(B<span class="op">*</span>T, C)</span>
<span id="cb62-209"><a href="#cb62-209"></a>            targets <span class="op">=</span> targets.view(B<span class="op">*</span>T)</span>
<span id="cb62-210"><a href="#cb62-210"></a>            loss <span class="op">=</span> F.cross_entropy(logits, targets)</span>
<span id="cb62-211"><a href="#cb62-211"></a></span>
<span id="cb62-212"><a href="#cb62-212"></a>        <span class="cf">return</span> logits, loss</span>
<span id="cb62-213"><a href="#cb62-213"></a></span>
<span id="cb62-214"><a href="#cb62-214"></a>    <span class="kw">def</span> generate(<span class="va">self</span>, idx, max_new_tokens):</span>
<span id="cb62-215"><a href="#cb62-215"></a>        <span class="co">"""Generate new text given a starting sequence."""</span></span>
<span id="cb62-216"><a href="#cb62-216"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_new_tokens):</span>
<span id="cb62-217"><a href="#cb62-217"></a>            <span class="co"># Crop context `idx` to the last `block_size` tokens. Important as position embeddings only go up to block_size.</span></span>
<span id="cb62-218"><a href="#cb62-218"></a>            idx_cond <span class="op">=</span> idx[:, <span class="op">-</span>block_size:]</span>
<span id="cb62-219"><a href="#cb62-219"></a>            <span class="co"># Get predictions (logits) from the model</span></span>
<span id="cb62-220"><a href="#cb62-220"></a>            logits, loss <span class="op">=</span> <span class="va">self</span>(idx_cond)</span>
<span id="cb62-221"><a href="#cb62-221"></a>            <span class="co"># Focus on the logits for the *last* time step: (B, C)</span></span>
<span id="cb62-222"><a href="#cb62-222"></a>            logits <span class="op">=</span> logits[:, <span class="op">-</span><span class="dv">1</span>, :]</span>
<span id="cb62-223"><a href="#cb62-223"></a>            <span class="co"># Convert logits to probabilities via softmax</span></span>
<span id="cb62-224"><a href="#cb62-224"></a>            probs <span class="op">=</span> F.softmax(logits, dim<span class="op">=-</span><span class="dv">1</span>)   <span class="co"># (B, C)</span></span>
<span id="cb62-225"><a href="#cb62-225"></a>            <span class="co"># Sample next token index from the probability distribution</span></span>
<span id="cb62-226"><a href="#cb62-226"></a>            idx_next <span class="op">=</span> torch.multinomial(probs, num_samples<span class="op">=</span><span class="dv">1</span>)   <span class="co"># (B, 1)</span></span>
<span id="cb62-227"><a href="#cb62-227"></a>            <span class="co"># Append the sampled index to the running sequence</span></span>
<span id="cb62-228"><a href="#cb62-228"></a>            idx <span class="op">=</span> torch.cat((idx, idx_next), dim<span class="op">=</span><span class="dv">1</span>)   <span class="co"># (B, T+1)</span></span>
<span id="cb62-229"><a href="#cb62-229"></a>        <span class="cf">return</span> idx</span>
<span id="cb62-230"><a href="#cb62-230"></a><span class="co"># =========================</span></span>
<span id="cb62-231"><a href="#cb62-231"></a></span>
<span id="cb62-232"><a href="#cb62-232"></a><span class="co"># ===== MODEL INITIALIZATION AND TRAINING =====</span></span>
<span id="cb62-233"><a href="#cb62-233"></a><span class="co"># Create model instance and move it to the selected device</span></span>
<span id="cb62-234"><a href="#cb62-234"></a>model <span class="op">=</span> BigramLanguageModel()</span>
<span id="cb62-235"><a href="#cb62-235"></a>m <span class="op">=</span> model.to(device)</span>
<span id="cb62-236"><a href="#cb62-236"></a><span class="co"># Print number of parameters (useful for understanding model size)</span></span>
<span id="cb62-237"><a href="#cb62-237"></a><span class="bu">print</span>(<span class="bu">sum</span>(p.numel() <span class="cf">for</span> p <span class="kw">in</span> m.parameters())<span class="op">/</span><span class="fl">1e6</span>, <span class="st">'M parameters'</span>) <span class="co"># Calculate and print M parameters</span></span>
<span id="cb62-238"><a href="#cb62-238"></a></span>
<span id="cb62-239"><a href="#cb62-239"></a><span class="co"># Create optimizer (AdamW again)</span></span>
<span id="cb62-240"><a href="#cb62-240"></a>optimizer <span class="op">=</span> torch.optim.AdamW(model.parameters(), lr<span class="op">=</span>learning_rate)</span>
<span id="cb62-241"><a href="#cb62-241"></a></span>
<span id="cb62-242"><a href="#cb62-242"></a><span class="co"># Training loop</span></span>
<span id="cb62-243"><a href="#cb62-243"></a><span class="cf">for</span> <span class="bu">iter</span> <span class="kw">in</span> <span class="bu">range</span>(max_iters):</span>
<span id="cb62-244"><a href="#cb62-244"></a>    <span class="co"># Evaluate loss periodically</span></span>
<span id="cb62-245"><a href="#cb62-245"></a>    <span class="cf">if</span> <span class="bu">iter</span> <span class="op">%</span> eval_interval <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> <span class="bu">iter</span> <span class="op">==</span> max_iters <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb62-246"><a href="#cb62-246"></a>        losses <span class="op">=</span> estimate_loss() <span class="co"># Get train/val loss using the helper function</span></span>
<span id="cb62-247"><a href="#cb62-247"></a>        <span class="bu">print</span>(<span class="ss">f"step </span><span class="sc">{</span><span class="bu">iter</span><span class="sc">}</span><span class="ss">: train loss </span><span class="sc">{</span>losses[<span class="st">'train'</span>]<span class="sc">:.4f}</span><span class="ss">, val loss </span><span class="sc">{</span>losses[<span class="st">'val'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>) <span class="co"># Print losses</span></span>
<span id="cb62-248"><a href="#cb62-248"></a></span>
<span id="cb62-249"><a href="#cb62-249"></a>    <span class="co"># Sample a batch of data</span></span>
<span id="cb62-250"><a href="#cb62-250"></a>    xb, yb <span class="op">=</span> get_batch(<span class="st">'train'</span>)</span>
<span id="cb62-251"><a href="#cb62-251"></a></span>
<span id="cb62-252"><a href="#cb62-252"></a>    <span class="co"># Forward pass: Evaluate loss</span></span>
<span id="cb62-253"><a href="#cb62-253"></a>    logits, loss <span class="op">=</span> model(xb, yb)</span>
<span id="cb62-254"><a href="#cb62-254"></a>    <span class="co"># Backward pass: Calculate gradients</span></span>
<span id="cb62-255"><a href="#cb62-255"></a>    optimizer.zero_grad(set_to_none<span class="op">=</span><span class="va">True</span>) <span class="co"># Zero gradients</span></span>
<span id="cb62-256"><a href="#cb62-256"></a>    loss.backward() <span class="co"># Backpropagation</span></span>
<span id="cb62-257"><a href="#cb62-257"></a>    <span class="co"># Update parameters</span></span>
<span id="cb62-258"><a href="#cb62-258"></a>    optimizer.step() <span class="co"># Optimizer step</span></span>
<span id="cb62-259"><a href="#cb62-259"></a></span>
<span id="cb62-260"><a href="#cb62-260"></a><span class="co"># Generate text from the trained model</span></span>
<span id="cb62-261"><a href="#cb62-261"></a>context <span class="op">=</span> torch.zeros((<span class="dv">1</span>, <span class="dv">1</span>), dtype<span class="op">=</span>torch.<span class="bu">long</span>, device<span class="op">=</span>device) <span class="co"># Starting context: [[0]]</span></span>
<span id="cb62-262"><a href="#cb62-262"></a><span class="bu">print</span>(decode(m.generate(context, max_new_tokens<span class="op">=</span><span class="dv">2000</span>)[<span class="dv">0</span>].tolist()))</span>
<span id="cb62-263"><a href="#cb62-263"></a><span class="co"># ============================================</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Using device: mps
0.209729 M parameters
step 0: train loss 4.4116, val loss 4.4022
step 100: train loss 2.6568, val loss 2.6670
step 200: train loss 2.5091, val loss 2.5059
step 300: train loss 2.4194, val loss 2.4336
step 400: train loss 2.3499, val loss 2.3563
step 500: train loss 2.2963, val loss 2.3126
step 600: train loss 2.2411, val loss 2.2501
step 700: train loss 2.2053, val loss 2.2188
step 800: train loss 2.1645, val loss 2.1882
step 900: train loss 2.1238, val loss 2.1498
step 1000: train loss 2.1027, val loss 2.1297
step 1100: train loss 2.0699, val loss 2.1186
step 1200: train loss 2.0394, val loss 2.0806
step 1300: train loss 2.0255, val loss 2.0644
step 1400: train loss 1.9924, val loss 2.0376
step 1500: train loss 1.9697, val loss 2.0303
step 1600: train loss 1.9644, val loss 2.0482
step 1700: train loss 1.9413, val loss 2.0122
step 1800: train loss 1.9087, val loss 1.9949
step 1900: train loss 1.9106, val loss 1.9898
step 2000: train loss 1.8858, val loss 1.9993
step 2100: train loss 1.8722, val loss 1.9762
step 2200: train loss 1.8602, val loss 1.9636
step 2300: train loss 1.8577, val loss 1.9551
step 2400: train loss 1.8442, val loss 1.9467
step 2500: train loss 1.8153, val loss 1.9439
step 2600: train loss 1.8224, val loss 1.9363
step 2700: train loss 1.8125, val loss 1.9370
step 2800: train loss 1.8054, val loss 1.9250
step 2900: train loss 1.8045, val loss 1.9336
step 3000: train loss 1.7950, val loss 1.9202
step 3100: train loss 1.7707, val loss 1.9197
step 3200: train loss 1.7545, val loss 1.9107
step 3300: train loss 1.7569, val loss 1.9075
step 3400: train loss 1.7533, val loss 1.8942
step 3500: train loss 1.7374, val loss 1.8960
step 3600: train loss 1.7268, val loss 1.8909
step 3700: train loss 1.7277, val loss 1.8814
step 3800: train loss 1.7188, val loss 1.8889
step 3900: train loss 1.7194, val loss 1.8714
step 4000: train loss 1.7127, val loss 1.8636
step 4100: train loss 1.7073, val loss 1.8710
step 4200: train loss 1.7022, val loss 1.8597
step 4300: train loss 1.6994, val loss 1.8488
step 4400: train loss 1.7048, val loss 1.8664
step 4500: train loss 1.6860, val loss 1.8461
step 4600: train loss 1.6854, val loss 1.8304
step 4700: train loss 1.6841, val loss 1.8469
step 4800: train loss 1.6655, val loss 1.8454
step 4900: train loss 1.6713, val loss 1.8387
step 4999: train loss 1.6656, val loss 1.8277

Foast.

MENENIUS:
Praviely your niews? I cank, CORiced aggele;
Or heave worth sunt bone Ammiod, Lord,
Who is make thy batted oub! servilings
Toke as lihtch you basw to see swife,
Is letsts lown'd us; to lace and though mistrair took
And the proply enstriaghte for a shien.
Why, they foul tlead,
up is later and
behoy cried men as thou beatt his you.

HERRY VI:
There, you weaks mirre and all was imper, Then death, doth those I will read;
Weas sul't is King me, I what lady so not this dire.

ROMEO:
O, upon to death! him not this bornorow-prove.

MUCIOND:
Why leave ye no you?

DUCUCHESTEH:
But one thyies, if will the save your blages wore I mong father you hast;
Alaitle not arm thither crown tow doth.

FROM WTARDit't me reven.

WARWICK:
Or, as extress womb voishmas!
Good me you; and incaes up done! make,
Or I serigh to emmequerel, to speak, herse to supomet?

LUCIO:
The like, But twast on was theirs
poor of thou do
As hath lay but so bredaint, forweet of For which his lictless me,
That while fumseriands thy unclity,
Wheree I wam my broth? am the too to virsant, whould enterfuly,
All there, ontreman one his him;
When whom to Luvinge one the rews,
Warwixt kill himfined me the bights the with and
Thost will in him,
Mor Sonme man, make to men, Must took.

Server:
Is aid the underer you: if
The I holseld at most lost! Comioli his but a bedrip thy lord,
And then you pringent, and what you kingle is a gestreface is ears.
But take me. Tis basdeh,--
Cendom to nie,
You lordone turn to mine hath dels in woo forth.
Poy devisecity, Ineed and encont
Onking, pleasiness, here's me?
What the have of the doet.

ClaytAM:
Now tweett, cour is plose,
Ostate, and you raint this made untu
With ould to Warwith that me bone;
Will him drown the have wesest: doth,
Are goody gent yours the pot opings, time same, that BI thirself have gative. I' cown love this mind,
Nether if thou her fortune they have fight my ftlair aggainst for him burry.

BRUTUS:
Whoth lost for for leth
And, being eyes
And if for</code></pre>
</div>
</div>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>With 5000 iterations, the model is able to generate text that is similar to the training text.</p>
</div>
</div>


<!-- -->

</section>
</section>

<p>© <a href="https://hakyimlab.org">HakyImLab and Listed Authors</a> - <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 License</a></p></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb64" data-shortcodes="false"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb64-1"><a href="#cb64-1"></a><span class="co">---</span></span>
<span id="cb64-2"><a href="#cb64-2"></a><span class="an">title:</span><span class="co"> Building a GPT - companion notebook annotated</span></span>
<span id="cb64-3"><a href="#cb64-3"></a><span class="an">author:</span><span class="co"> Andrey Karpathy</span></span>
<span id="cb64-4"><a href="#cb64-4"></a><span class="an">date:</span><span class="co"> '2025-04-15'</span></span>
<span id="cb64-5"><a href="#cb64-5"></a><span class="an">freeze:</span><span class="co"> true</span></span>
<span id="cb64-6"><a href="#cb64-6"></a><span class="an">jupyter:</span><span class="co"> </span></span>
<span id="cb64-7"><a href="#cb64-7"></a><span class="co">  kernelspec:</span></span>
<span id="cb64-8"><a href="#cb64-8"></a><span class="co">    name: "conda-env-gene46100-py"</span></span>
<span id="cb64-9"><a href="#cb64-9"></a><span class="co">    language: "python"</span></span>
<span id="cb64-10"><a href="#cb64-10"></a><span class="co">    display_name: "gene46100"</span></span>
<span id="cb64-11"><a href="#cb64-11"></a><span class="an">format:</span></span>
<span id="cb64-12"><a href="#cb64-12"></a><span class="co">  html:</span></span>
<span id="cb64-13"><a href="#cb64-13"></a><span class="co">    code-fold: true</span></span>
<span id="cb64-14"><a href="#cb64-14"></a><span class="co">    code-line-numbers: true</span></span>
<span id="cb64-15"><a href="#cb64-15"></a><span class="co">    code-tools: true</span></span>
<span id="cb64-16"><a href="#cb64-16"></a><span class="co">    code-wrap: true</span></span>
<span id="cb64-17"><a href="#cb64-17"></a><span class="an">description:</span><span class="co"> Companion notebook from Karpathys video on building a minimal GPT, annotated by cursors LLM with summary from gemini.</span></span>
<span id="cb64-18"><a href="#cb64-18"></a><span class="co">---</span></span>
<span id="cb64-19"><a href="#cb64-19"></a></span>
<span id="cb64-20"><a href="#cb64-20"></a><span class="fu">## Building a GPT</span></span>
<span id="cb64-21"><a href="#cb64-21"></a></span>
<span id="cb64-22"><a href="#cb64-22"></a>Companion notebook to the <span class="co">[</span><span class="ot">Zero To Hero</span><span class="co">](https://karpathy.ai/zero-to-hero.html)</span> video on GPT. Downloaded from <span class="co">[</span><span class="ot">here</span><span class="co">](https://colab.research.google.com/drive/1JMLa53HDuA-i7ZBmqV7ZnA3c_fvtXnx-?usp=sharing)</span></span>
<span id="cb64-23"><a href="#cb64-23"></a></span>
<span id="cb64-24"><a href="#cb64-24"></a>(https://github.com/karpathy/nanoGPT)</span>
<span id="cb64-25"><a href="#cb64-25"></a></span>
<span id="cb64-26"><a href="#cb64-26"></a><span class="fu">### download the tiny shakespeare dataset</span></span>
<span id="cb64-29"><a href="#cb64-29"></a><span class="in">```{python}</span></span>
<span id="cb64-30"><a href="#cb64-30"></a><span class="co"># Download the tiny shakespeare dataset</span></span>
<span id="cb64-31"><a href="#cb64-31"></a><span class="co">#!wget https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt</span></span>
<span id="cb64-32"><a href="#cb64-32"></a></span>
<span id="cb64-33"><a href="#cb64-33"></a><span class="in">```</span></span>
<span id="cb64-34"><a href="#cb64-34"></a></span>
<span id="cb64-37"><a href="#cb64-37"></a><span class="in">```{python}</span></span>
<span id="cb64-38"><a href="#cb64-38"></a><span class="co"># read it in to inspect it</span></span>
<span id="cb64-39"><a href="#cb64-39"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">'input.txt'</span>, <span class="st">'r'</span>, encoding<span class="op">=</span><span class="st">'utf-8'</span>) <span class="im">as</span> f:</span>
<span id="cb64-40"><a href="#cb64-40"></a>    text <span class="op">=</span> f.read()</span>
<span id="cb64-41"><a href="#cb64-41"></a><span class="in">```</span></span>
<span id="cb64-42"><a href="#cb64-42"></a></span>
<span id="cb64-45"><a href="#cb64-45"></a><span class="in">```{python}</span></span>
<span id="cb64-46"><a href="#cb64-46"></a><span class="co"># print the length of the dataset</span></span>
<span id="cb64-47"><a href="#cb64-47"></a><span class="bu">print</span>(<span class="st">"length of dataset in characters: "</span>, <span class="bu">len</span>(text))</span>
<span id="cb64-48"><a href="#cb64-48"></a><span class="in">```</span></span>
<span id="cb64-49"><a href="#cb64-49"></a></span>
<span id="cb64-52"><a href="#cb64-52"></a><span class="in">```{python}</span></span>
<span id="cb64-53"><a href="#cb64-53"></a><span class="co"># let's look at the first 1000 characters</span></span>
<span id="cb64-54"><a href="#cb64-54"></a><span class="bu">print</span>(text[:<span class="dv">1000</span>])</span>
<span id="cb64-55"><a href="#cb64-55"></a><span class="in">```</span></span>
<span id="cb64-56"><a href="#cb64-56"></a></span>
<span id="cb64-59"><a href="#cb64-59"></a><span class="in">```{python}</span></span>
<span id="cb64-60"><a href="#cb64-60"></a><span class="co"># here are all the unique characters that occur in this text</span></span>
<span id="cb64-61"><a href="#cb64-61"></a>chars <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(text)))</span>
<span id="cb64-62"><a href="#cb64-62"></a>vocab_size <span class="op">=</span> <span class="bu">len</span>(chars)</span>
<span id="cb64-63"><a href="#cb64-63"></a><span class="bu">print</span>(<span class="st">''</span>.join(chars))</span>
<span id="cb64-64"><a href="#cb64-64"></a><span class="bu">print</span>(vocab_size)</span>
<span id="cb64-65"><a href="#cb64-65"></a><span class="in">```</span></span>
<span id="cb64-66"><a href="#cb64-66"></a></span>
<span id="cb64-67"><a href="#cb64-67"></a><span class="fu">### mapping characters to integers and vice versa</span></span>
<span id="cb64-70"><a href="#cb64-70"></a><span class="in">```{python}</span></span>
<span id="cb64-71"><a href="#cb64-71"></a><span class="co"># create a mapping from characters to integers</span></span>
<span id="cb64-72"><a href="#cb64-72"></a>stoi <span class="op">=</span> { ch:i <span class="cf">for</span> i,ch <span class="kw">in</span> <span class="bu">enumerate</span>(chars) }</span>
<span id="cb64-73"><a href="#cb64-73"></a>itos <span class="op">=</span> { i:ch <span class="cf">for</span> i,ch <span class="kw">in</span> <span class="bu">enumerate</span>(chars) }</span>
<span id="cb64-74"><a href="#cb64-74"></a>encode <span class="op">=</span> <span class="kw">lambda</span> s: [stoi[c] <span class="cf">for</span> c <span class="kw">in</span> s] <span class="co"># encoder: take a string, output a list of integers</span></span>
<span id="cb64-75"><a href="#cb64-75"></a>decode <span class="op">=</span> <span class="kw">lambda</span> l: <span class="st">''</span>.join([itos[i] <span class="cf">for</span> i <span class="kw">in</span> l]) <span class="co"># decoder: take a list of integers, output a string</span></span>
<span id="cb64-76"><a href="#cb64-76"></a></span>
<span id="cb64-77"><a href="#cb64-77"></a><span class="bu">print</span>(encode(<span class="st">"hii there"</span>))</span>
<span id="cb64-78"><a href="#cb64-78"></a><span class="bu">print</span>(decode(encode(<span class="st">"hii there"</span>)))</span>
<span id="cb64-79"><a href="#cb64-79"></a><span class="in">```</span></span>
<span id="cb64-80"><a href="#cb64-80"></a></span>
<span id="cb64-81"><a href="#cb64-81"></a><span class="fu">### encode the data into torch tensor</span></span>
<span id="cb64-84"><a href="#cb64-84"></a><span class="in">```{python}</span></span>
<span id="cb64-85"><a href="#cb64-85"></a><span class="co"># let's now encode the entire text dataset and store it into a torch.Tensor</span></span>
<span id="cb64-86"><a href="#cb64-86"></a><span class="im">import</span> torch <span class="co"># we use PyTorch: [https://pytorch.org](https://pytorch.org)</span></span>
<span id="cb64-87"><a href="#cb64-87"></a>data <span class="op">=</span> torch.tensor(encode(text), dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb64-88"><a href="#cb64-88"></a><span class="bu">print</span>(data.shape, data.dtype)</span>
<span id="cb64-89"><a href="#cb64-89"></a><span class="bu">print</span>(data[:<span class="dv">1000</span>]) <span class="co"># the 1000 characters we looked at earier will to the GPT look like this</span></span>
<span id="cb64-90"><a href="#cb64-90"></a><span class="in">```</span></span>
<span id="cb64-91"><a href="#cb64-91"></a></span>
<span id="cb64-92"><a href="#cb64-92"></a><span class="fu">### split up the data into train and validation sets</span></span>
<span id="cb64-95"><a href="#cb64-95"></a><span class="in">```{python}</span></span>
<span id="cb64-96"><a href="#cb64-96"></a><span class="co"># split up the data into train and validation sets</span></span>
<span id="cb64-97"><a href="#cb64-97"></a>n <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.9</span><span class="op">*</span><span class="bu">len</span>(data)) <span class="co"># first 90% will be train, rest val</span></span>
<span id="cb64-98"><a href="#cb64-98"></a>train_data <span class="op">=</span> data[:n]</span>
<span id="cb64-99"><a href="#cb64-99"></a>val_data <span class="op">=</span> data[n:]</span>
<span id="cb64-100"><a href="#cb64-100"></a><span class="in">```</span></span>
<span id="cb64-101"><a href="#cb64-101"></a></span>
<span id="cb64-102"><a href="#cb64-102"></a><span class="fu">### define the block size</span></span>
<span id="cb64-105"><a href="#cb64-105"></a><span class="in">```{python}</span></span>
<span id="cb64-106"><a href="#cb64-106"></a>block_size <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb64-107"><a href="#cb64-107"></a>train_data[:block_size<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb64-108"><a href="#cb64-108"></a><span class="in">```</span></span>
<span id="cb64-109"><a href="#cb64-109"></a></span>
<span id="cb64-110"><a href="#cb64-110"></a><span class="fu">### define the context and target: 8 examples in one batch</span></span>
<span id="cb64-113"><a href="#cb64-113"></a><span class="in">```{python}</span></span>
<span id="cb64-114"><a href="#cb64-114"></a>x <span class="op">=</span> train_data[:block_size]</span>
<span id="cb64-115"><a href="#cb64-115"></a>y <span class="op">=</span> train_data[<span class="dv">1</span>:block_size<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb64-116"><a href="#cb64-116"></a><span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(block_size):</span>
<span id="cb64-117"><a href="#cb64-117"></a>    context <span class="op">=</span> x[:t<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb64-118"><a href="#cb64-118"></a>    target <span class="op">=</span> y[t]</span>
<span id="cb64-119"><a href="#cb64-119"></a>    <span class="bu">print</span>(<span class="ss">f"when input is </span><span class="sc">{</span>context<span class="sc">}</span><span class="ss"> the target: </span><span class="sc">{</span>target<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb64-120"><a href="#cb64-120"></a><span class="in">```</span></span>
<span id="cb64-121"><a href="#cb64-121"></a></span>
<span id="cb64-122"><a href="#cb64-122"></a><span class="fu">### define the batch size and get the batch</span></span>
<span id="cb64-123"><a href="#cb64-123"></a></span>
<span id="cb64-126"><a href="#cb64-126"></a><span class="in">```{python}</span></span>
<span id="cb64-127"><a href="#cb64-127"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb64-128"><a href="#cb64-128"></a>batch_size <span class="op">=</span> <span class="dv">4</span> <span class="co"># how many independent sequences will we process in parallel?</span></span>
<span id="cb64-129"><a href="#cb64-129"></a>block_size <span class="op">=</span> <span class="dv">8</span> <span class="co"># what is the maximum context length for predictions?</span></span>
<span id="cb64-130"><a href="#cb64-130"></a></span>
<span id="cb64-131"><a href="#cb64-131"></a><span class="kw">def</span> get_batch(split):</span>
<span id="cb64-132"><a href="#cb64-132"></a>    <span class="co"># generate a small batch of data of inputs x and targets y</span></span>
<span id="cb64-133"><a href="#cb64-133"></a>    data <span class="op">=</span> train_data <span class="cf">if</span> split <span class="op">==</span> <span class="st">'train'</span> <span class="cf">else</span> val_data</span>
<span id="cb64-134"><a href="#cb64-134"></a>    ix <span class="op">=</span> torch.randint(<span class="bu">len</span>(data) <span class="op">-</span> block_size, (batch_size,))</span>
<span id="cb64-135"><a href="#cb64-135"></a>    x <span class="op">=</span> torch.stack([data[i:i<span class="op">+</span>block_size] <span class="cf">for</span> i <span class="kw">in</span> ix])</span>
<span id="cb64-136"><a href="#cb64-136"></a>    y <span class="op">=</span> torch.stack([data[i<span class="op">+</span><span class="dv">1</span>:i<span class="op">+</span>block_size<span class="op">+</span><span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> ix])</span>
<span id="cb64-137"><a href="#cb64-137"></a>    <span class="cf">return</span> x, y</span>
<span id="cb64-138"><a href="#cb64-138"></a></span>
<span id="cb64-139"><a href="#cb64-139"></a>xb, yb <span class="op">=</span> get_batch(<span class="st">'train'</span>)</span>
<span id="cb64-140"><a href="#cb64-140"></a><span class="bu">print</span>(<span class="st">'inputs:'</span>)</span>
<span id="cb64-141"><a href="#cb64-141"></a><span class="bu">print</span>(xb.shape)</span>
<span id="cb64-142"><a href="#cb64-142"></a><span class="bu">print</span>(xb)</span>
<span id="cb64-143"><a href="#cb64-143"></a><span class="bu">print</span>(<span class="st">'targets:'</span>)</span>
<span id="cb64-144"><a href="#cb64-144"></a><span class="bu">print</span>(yb.shape)</span>
<span id="cb64-145"><a href="#cb64-145"></a><span class="bu">print</span>(yb)</span>
<span id="cb64-146"><a href="#cb64-146"></a></span>
<span id="cb64-147"><a href="#cb64-147"></a><span class="bu">print</span>(<span class="st">'----'</span>)</span>
<span id="cb64-148"><a href="#cb64-148"></a></span>
<span id="cb64-149"><a href="#cb64-149"></a><span class="cf">for</span> b <span class="kw">in</span> <span class="bu">range</span>(batch_size): <span class="co"># batch dimension</span></span>
<span id="cb64-150"><a href="#cb64-150"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(block_size): <span class="co"># time dimension</span></span>
<span id="cb64-151"><a href="#cb64-151"></a>        context <span class="op">=</span> xb[b, :t<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb64-152"><a href="#cb64-152"></a>        target <span class="op">=</span> yb[b,t]</span>
<span id="cb64-153"><a href="#cb64-153"></a>        <span class="bu">print</span>(<span class="ss">f"when input is </span><span class="sc">{</span>context<span class="sc">.</span>tolist()<span class="sc">}</span><span class="ss"> the target: </span><span class="sc">{</span>target<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb64-154"><a href="#cb64-154"></a><span class="in">```</span></span>
<span id="cb64-155"><a href="#cb64-155"></a></span>
<span id="cb64-156"><a href="#cb64-156"></a><span class="fu">### start with a simple model: the bigram language model</span></span>
<span id="cb64-157"><a href="#cb64-157"></a></span>
<span id="cb64-160"><a href="#cb64-160"></a><span class="in">```{python}</span></span>
<span id="cb64-161"><a href="#cb64-161"></a><span class="co"># define the bigram language model</span></span>
<span id="cb64-162"><a href="#cb64-162"></a><span class="im">import</span> torch</span>
<span id="cb64-163"><a href="#cb64-163"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb64-164"><a href="#cb64-164"></a><span class="im">from</span> torch.nn <span class="im">import</span> functional <span class="im">as</span> F</span>
<span id="cb64-165"><a href="#cb64-165"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb64-166"><a href="#cb64-166"></a></span>
<span id="cb64-167"><a href="#cb64-167"></a><span class="kw">class</span> BigramLanguageModel(nn.Module):</span>
<span id="cb64-168"><a href="#cb64-168"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, vocab_size):</span>
<span id="cb64-169"><a href="#cb64-169"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb64-170"><a href="#cb64-170"></a>        <span class="va">self</span>.token_embedding_table <span class="op">=</span> nn.Embedding(vocab_size, vocab_size)</span>
<span id="cb64-171"><a href="#cb64-171"></a></span>
<span id="cb64-172"><a href="#cb64-172"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, idx, targets<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb64-173"><a href="#cb64-173"></a>        <span class="co"># idx and targets are both (B,T) tensor of integers</span></span>
<span id="cb64-174"><a href="#cb64-174"></a>        logits <span class="op">=</span> <span class="va">self</span>.token_embedding_table(idx) <span class="co"># (B,T,C)</span></span>
<span id="cb64-175"><a href="#cb64-175"></a></span>
<span id="cb64-176"><a href="#cb64-176"></a>        <span class="cf">if</span> targets <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb64-177"><a href="#cb64-177"></a>            loss <span class="op">=</span> <span class="va">None</span></span>
<span id="cb64-178"><a href="#cb64-178"></a>        <span class="cf">else</span>:</span>
<span id="cb64-179"><a href="#cb64-179"></a>            B, T, C <span class="op">=</span> logits.shape</span>
<span id="cb64-180"><a href="#cb64-180"></a>            logits <span class="op">=</span> logits.view(B<span class="op">*</span>T, C)</span>
<span id="cb64-181"><a href="#cb64-181"></a>            targets <span class="op">=</span> targets.view(B<span class="op">*</span>T)</span>
<span id="cb64-182"><a href="#cb64-182"></a>            loss <span class="op">=</span> F.cross_entropy(logits, targets)</span>
<span id="cb64-183"><a href="#cb64-183"></a></span>
<span id="cb64-184"><a href="#cb64-184"></a>        <span class="cf">return</span> logits, loss</span>
<span id="cb64-185"><a href="#cb64-185"></a></span>
<span id="cb64-186"><a href="#cb64-186"></a>    <span class="kw">def</span> generate(<span class="va">self</span>, idx, max_new_tokens):</span>
<span id="cb64-187"><a href="#cb64-187"></a>        <span class="co"># idx is (B, T) array of indices in the current context</span></span>
<span id="cb64-188"><a href="#cb64-188"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_new_tokens):</span>
<span id="cb64-189"><a href="#cb64-189"></a>            <span class="co"># get the predictions</span></span>
<span id="cb64-190"><a href="#cb64-190"></a>            logits, loss <span class="op">=</span> <span class="va">self</span>(idx)</span>
<span id="cb64-191"><a href="#cb64-191"></a>            <span class="co"># focus only on the last time step</span></span>
<span id="cb64-192"><a href="#cb64-192"></a>            logits <span class="op">=</span> logits[:, <span class="op">-</span><span class="dv">1</span>, :] <span class="co"># becomes (B, C)</span></span>
<span id="cb64-193"><a href="#cb64-193"></a>            <span class="co"># apply softmax to get probabilities</span></span>
<span id="cb64-194"><a href="#cb64-194"></a>            probs <span class="op">=</span> F.softmax(logits, dim<span class="op">=-</span><span class="dv">1</span>) <span class="co"># (B, C)</span></span>
<span id="cb64-195"><a href="#cb64-195"></a>            <span class="co"># sample from the distribution</span></span>
<span id="cb64-196"><a href="#cb64-196"></a>            idx_next <span class="op">=</span> torch.multinomial(probs, num_samples<span class="op">=</span><span class="dv">1</span>) <span class="co"># (B, 1)</span></span>
<span id="cb64-197"><a href="#cb64-197"></a>            <span class="co"># append sampled index to the running sequence</span></span>
<span id="cb64-198"><a href="#cb64-198"></a>            idx <span class="op">=</span> torch.cat((idx, idx_next), dim<span class="op">=</span><span class="dv">1</span>) <span class="co"># (B, T+1)</span></span>
<span id="cb64-199"><a href="#cb64-199"></a>        <span class="cf">return</span> idx</span>
<span id="cb64-200"><a href="#cb64-200"></a><span class="in">```</span></span>
<span id="cb64-201"><a href="#cb64-201"></a></span>
<span id="cb64-202"><a href="#cb64-202"></a><span class="fu">### cross entropy loss</span></span>
<span id="cb64-203"><a href="#cb64-203"></a></span>
<span id="cb64-204"><a href="#cb64-204"></a>Loss = $-\sum_{i}(y_i * \log(p_i))$x</span>
<span id="cb64-205"><a href="#cb64-205"></a></span>
<span id="cb64-206"><a href="#cb64-206"></a>where:</span>
<span id="cb64-207"><a href="#cb64-207"></a></span>
<span id="cb64-208"><a href="#cb64-208"></a>$y_i$ = actual probability (0 or 1 for the $i$-th class)</span>
<span id="cb64-209"><a href="#cb64-209"></a>$p_i$ = predicted probability for the $i$-th class</span>
<span id="cb64-210"><a href="#cb64-210"></a>$\sum$ = sum over all classes (characters)</span>
<span id="cb64-211"><a href="#cb64-211"></a></span>
<span id="cb64-212"><a href="#cb64-212"></a>This is the loss for a single token prediction. The total loss reported by F.cross_entropy is the average loss across all B*T tokens in the batch, where:</span>
<span id="cb64-213"><a href="#cb64-213"></a></span>
<span id="cb64-214"><a href="#cb64-214"></a>B = batch_size</span>
<span id="cb64-215"><a href="#cb64-215"></a>T = block_size (sequence length)</span>
<span id="cb64-216"><a href="#cb64-216"></a></span>
<span id="cb64-217"><a href="#cb64-217"></a>Before training, we would expect the model to predict the next character from a uniform distribution (random guessing). The probability for the correct character would be $1 / \text{vocab_size}$.</span>
<span id="cb64-218"><a href="#cb64-218"></a></span>
<span id="cb64-219"><a href="#cb64-219"></a>Expected initial loss $\approx - \log(1 / \text{vocab_size}) = \log(\text{vocab_size})$</span>
<span id="cb64-220"><a href="#cb64-220"></a>$\log(65) \approx 4.1744$</span>
<span id="cb64-221"><a href="#cb64-221"></a></span>
<span id="cb64-222"><a href="#cb64-222"></a><span class="fu">### initialize the model and compute the loss</span></span>
<span id="cb64-223"><a href="#cb64-223"></a></span>
<span id="cb64-226"><a href="#cb64-226"></a><span class="in">```{python}</span></span>
<span id="cb64-227"><a href="#cb64-227"></a>m <span class="op">=</span> BigramLanguageModel(vocab_size)</span>
<span id="cb64-228"><a href="#cb64-228"></a>logits, loss <span class="op">=</span> m(xb, yb) <span class="co"># xb/yb are from the previous cell (B=4, T=8)</span></span>
<span id="cb64-229"><a href="#cb64-229"></a><span class="bu">print</span>(logits.shape) <span class="co"># Expected: (B, T, C) = (4, 8, 65)</span></span>
<span id="cb64-230"><a href="#cb64-230"></a><span class="bu">print</span>(loss) <span class="co"># Expected: Around 4.17</span></span>
<span id="cb64-231"><a href="#cb64-231"></a><span class="in">```</span></span>
<span id="cb64-232"><a href="#cb64-232"></a></span>
<span id="cb64-233"><a href="#cb64-233"></a><span class="fu">### generate text</span></span>
<span id="cb64-234"><a href="#cb64-234"></a></span>
<span id="cb64-237"><a href="#cb64-237"></a><span class="in">```{python}</span></span>
<span id="cb64-238"><a href="#cb64-238"></a><span class="bu">print</span>(decode(m.generate(idx <span class="op">=</span> torch.zeros((<span class="dv">1</span>, <span class="dv">1</span>), dtype<span class="op">=</span>torch.<span class="bu">long</span>), max_new_tokens<span class="op">=</span><span class="dv">100</span>)[<span class="dv">0</span>].tolist()))</span>
<span id="cb64-239"><a href="#cb64-239"></a><span class="in">```</span></span>
<span id="cb64-240"><a href="#cb64-240"></a></span>
<span id="cb64-241"><a href="#cb64-241"></a><span class="fu">### choose AdamW as the optimizer</span></span>
<span id="cb64-242"><a href="#cb64-242"></a></span>
<span id="cb64-245"><a href="#cb64-245"></a><span class="in">```{python}</span></span>
<span id="cb64-246"><a href="#cb64-246"></a>optimizer <span class="op">=</span> torch.optim.AdamW(m.parameters(), lr<span class="op">=</span><span class="fl">1e-3</span>)</span>
<span id="cb64-247"><a href="#cb64-247"></a><span class="in">```</span></span>
<span id="cb64-248"><a href="#cb64-248"></a></span>
<span id="cb64-249"><a href="#cb64-249"></a><span class="fu">### train the model</span></span>
<span id="cb64-250"><a href="#cb64-250"></a></span>
<span id="cb64-253"><a href="#cb64-253"></a><span class="in">```{python}</span></span>
<span id="cb64-254"><a href="#cb64-254"></a>batch_size <span class="op">=</span> <span class="dv">32</span> <span class="co"># Redefine batch size for training</span></span>
<span id="cb64-255"><a href="#cb64-255"></a><span class="cf">for</span> steps <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>): <span class="co"># # sample a batch of data</span></span>
<span id="cb64-256"><a href="#cb64-256"></a>    xb, yb <span class="op">=</span> get_batch(<span class="st">'train'</span>)</span>
<span id="cb64-257"><a href="#cb64-257"></a></span>
<span id="cb64-258"><a href="#cb64-258"></a>    <span class="co"># evaluate the loss</span></span>
<span id="cb64-259"><a href="#cb64-259"></a>    logits, loss <span class="op">=</span> m(xb, yb)</span>
<span id="cb64-260"><a href="#cb64-260"></a>    optimizer.zero_grad(set_to_none<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb64-261"><a href="#cb64-261"></a>    loss.backward()</span>
<span id="cb64-262"><a href="#cb64-262"></a>    optimizer.step()</span>
<span id="cb64-263"><a href="#cb64-263"></a></span>
<span id="cb64-264"><a href="#cb64-264"></a><span class="bu">print</span>(loss.item())</span>
<span id="cb64-265"><a href="#cb64-265"></a><span class="in">```</span></span>
<span id="cb64-266"><a href="#cb64-266"></a></span>
<span id="cb64-267"><a href="#cb64-267"></a><span class="fu">### generate text starting with 0=`\n` as initial context</span></span>
<span id="cb64-268"><a href="#cb64-268"></a></span>
<span id="cb64-271"><a href="#cb64-271"></a><span class="in">```{python}</span></span>
<span id="cb64-272"><a href="#cb64-272"></a><span class="bu">print</span>(decode(m.generate(idx <span class="op">=</span> torch.zeros((<span class="dv">1</span>, <span class="dv">1</span>), dtype<span class="op">=</span>torch.<span class="bu">long</span>), max_new_tokens<span class="op">=</span><span class="dv">500</span>)[<span class="dv">0</span>].tolist()))</span>
<span id="cb64-273"><a href="#cb64-273"></a><span class="in">```</span></span>
<span id="cb64-274"><a href="#cb64-274"></a></span>
<span id="cb64-275"><a href="#cb64-275"></a><span class="fu">### The mathematical trick in self-attention</span></span>
<span id="cb64-276"><a href="#cb64-276"></a>toy example illustrating how matrix multiplication can be used for a "weighted aggregation"</span>
<span id="cb64-277"><a href="#cb64-277"></a></span>
<span id="cb64-280"><a href="#cb64-280"></a><span class="in">```{python}</span></span>
<span id="cb64-281"><a href="#cb64-281"></a>torch.manual_seed(<span class="dv">42</span>)</span>
<span id="cb64-282"><a href="#cb64-282"></a>a <span class="op">=</span> torch.tril(torch.ones(<span class="dv">3</span>, <span class="dv">3</span>)) <span class="co"># Lower triangular matrix of 1s</span></span>
<span id="cb64-283"><a href="#cb64-283"></a>a <span class="op">=</span> a <span class="op">/</span> torch.<span class="bu">sum</span>(a, <span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>) <span class="co"># Normalize rows to sum to 1</span></span>
<span id="cb64-284"><a href="#cb64-284"></a>b <span class="op">=</span> torch.randint(<span class="dv">0</span>,<span class="dv">10</span>,(<span class="dv">3</span>,<span class="dv">2</span>)).<span class="bu">float</span>() <span class="co"># Some data</span></span>
<span id="cb64-285"><a href="#cb64-285"></a>c <span class="op">=</span> a <span class="op">@</span> b <span class="co"># Matrix multiply</span></span>
<span id="cb64-286"><a href="#cb64-286"></a><span class="bu">print</span>(<span class="st">'a='</span>)</span>
<span id="cb64-287"><a href="#cb64-287"></a><span class="bu">print</span>(a)</span>
<span id="cb64-288"><a href="#cb64-288"></a><span class="bu">print</span>(<span class="st">'--'</span>)</span>
<span id="cb64-289"><a href="#cb64-289"></a><span class="bu">print</span>(<span class="st">'b='</span>)</span>
<span id="cb64-290"><a href="#cb64-290"></a><span class="bu">print</span>(b)</span>
<span id="cb64-291"><a href="#cb64-291"></a><span class="bu">print</span>(<span class="st">'--'</span>)</span>
<span id="cb64-292"><a href="#cb64-292"></a><span class="bu">print</span>(<span class="st">'c='</span>)</span>
<span id="cb64-293"><a href="#cb64-293"></a><span class="bu">print</span>(c)</span>
<span id="cb64-294"><a href="#cb64-294"></a><span class="in">```</span></span>
<span id="cb64-295"><a href="#cb64-295"></a></span>
<span id="cb64-298"><a href="#cb64-298"></a><span class="in">```{python}</span></span>
<span id="cb64-299"><a href="#cb64-299"></a><span class="co"># consider the following toy example:</span></span>
<span id="cb64-300"><a href="#cb64-300"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb64-301"><a href="#cb64-301"></a>B,T,C <span class="op">=</span> <span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">2</span> <span class="co"># batch, time, channels</span></span>
<span id="cb64-302"><a href="#cb64-302"></a>x <span class="op">=</span> torch.randn(B,T,C)</span>
<span id="cb64-303"><a href="#cb64-303"></a>x.shape</span>
<span id="cb64-304"><a href="#cb64-304"></a><span class="in">```</span></span>
<span id="cb64-305"><a href="#cb64-305"></a></span>
<span id="cb64-306"><a href="#cb64-306"></a><span class="fu">### version 1: using a for loop to compute the weighted aggregation</span></span>
<span id="cb64-307"><a href="#cb64-307"></a></span>
<span id="cb64-310"><a href="#cb64-310"></a><span class="in">```{python}</span></span>
<span id="cb64-311"><a href="#cb64-311"></a><span class="co"># We want x[b,t] = mean_{i&lt;=t} x[b,i]</span></span>
<span id="cb64-312"><a href="#cb64-312"></a>xbow <span class="op">=</span> torch.zeros((B,T,C)) <span class="co"># x bag-of-words (running average)</span></span>
<span id="cb64-313"><a href="#cb64-313"></a><span class="cf">for</span> b <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb64-314"><a href="#cb64-314"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(T):</span>
<span id="cb64-315"><a href="#cb64-315"></a>        xprev <span class="op">=</span> x[b,:t<span class="op">+</span><span class="dv">1</span>] <span class="co"># Select vectors from start up to time t: shape (t+1, C)</span></span>
<span id="cb64-316"><a href="#cb64-316"></a>        xbow[b,t] <span class="op">=</span> torch.mean(xprev, <span class="dv">0</span>) <span class="co"># Compute mean along the time dimension (dim 0)</span></span>
<span id="cb64-317"><a href="#cb64-317"></a><span class="in">```</span></span>
<span id="cb64-318"><a href="#cb64-318"></a></span>
<span id="cb64-319"><a href="#cb64-319"></a><span class="fu">### version 2: using matrix multiply for a weighted aggregation</span></span>
<span id="cb64-320"><a href="#cb64-320"></a></span>
<span id="cb64-323"><a href="#cb64-323"></a><span class="in">```{python}</span></span>
<span id="cb64-324"><a href="#cb64-324"></a><span class="co"># Create the averaging weight matrix</span></span>
<span id="cb64-325"><a href="#cb64-325"></a>wei <span class="op">=</span> torch.tril(torch.ones(T, T))</span>
<span id="cb64-326"><a href="#cb64-326"></a>wei <span class="op">=</span> wei <span class="op">/</span> wei.<span class="bu">sum</span>(<span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>) <span class="co"># Normalize rows to sum to 1</span></span>
<span id="cb64-327"><a href="#cb64-327"></a><span class="co"># Perform batched matrix multiplication</span></span>
<span id="cb64-328"><a href="#cb64-328"></a>xbow2 <span class="op">=</span> wei <span class="op">@</span> x <span class="co"># (T, T) @ (B, T, C) -&gt; (B, T, C) via broadcasting</span></span>
<span id="cb64-329"><a href="#cb64-329"></a>torch.allclose(xbow, xbow2) <span class="co"># Check if results are identical</span></span>
<span id="cb64-330"><a href="#cb64-330"></a><span class="in">```</span></span>
<span id="cb64-331"><a href="#cb64-331"></a></span>
<span id="cb64-332"><a href="#cb64-332"></a><span class="fu">### version 3: use Softmax</span></span>
<span id="cb64-333"><a href="#cb64-333"></a></span>
<span id="cb64-336"><a href="#cb64-336"></a><span class="in">```{python}</span></span>
<span id="cb64-337"><a href="#cb64-337"></a>tril <span class="op">=</span> torch.tril(torch.ones(T, T))</span>
<span id="cb64-338"><a href="#cb64-338"></a>wei <span class="op">=</span> torch.zeros((T,T))</span>
<span id="cb64-339"><a href="#cb64-339"></a><span class="co"># Mask out future positions by setting them to -infinity before softmax</span></span>
<span id="cb64-340"><a href="#cb64-340"></a>wei <span class="op">=</span> wei.masked_fill(tril <span class="op">==</span> <span class="dv">0</span>, <span class="bu">float</span>(<span class="st">'-inf'</span>))</span>
<span id="cb64-341"><a href="#cb64-341"></a><span class="co"># Apply softmax to get row-wise probability distributions (weights)</span></span>
<span id="cb64-342"><a href="#cb64-342"></a>wei <span class="op">=</span> F.softmax(wei, dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb64-343"><a href="#cb64-343"></a><span class="co"># Perform weighted aggregation</span></span>
<span id="cb64-344"><a href="#cb64-344"></a>xbow3 <span class="op">=</span> wei <span class="op">@</span> x</span>
<span id="cb64-345"><a href="#cb64-345"></a>torch.allclose(xbow, xbow3) <span class="co"># Check if results are identical</span></span>
<span id="cb64-346"><a href="#cb64-346"></a><span class="in">```</span></span>
<span id="cb64-347"><a href="#cb64-347"></a></span>
<span id="cb64-348"><a href="#cb64-348"></a><span class="fu">### softmax function</span></span>
<span id="cb64-349"><a href="#cb64-349"></a>softmax($z_i$) = $\frac{e^{z_i}}{\sum_j e^{z_j}}$</span>
<span id="cb64-350"><a href="#cb64-350"></a></span>
<span id="cb64-351"><a href="#cb64-351"></a><span class="fu">### version 4: self-attention</span></span>
<span id="cb64-352"><a href="#cb64-352"></a></span>
<span id="cb64-355"><a href="#cb64-355"></a><span class="in">```{python}</span></span>
<span id="cb64-356"><a href="#cb64-356"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb64-357"><a href="#cb64-357"></a>B,T,C <span class="op">=</span> <span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">32</span> <span class="co"># batch, time, channels (embedding dimension)</span></span>
<span id="cb64-358"><a href="#cb64-358"></a>x <span class="op">=</span> torch.randn(B,T,C)</span>
<span id="cb64-359"><a href="#cb64-359"></a></span>
<span id="cb64-360"><a href="#cb64-360"></a><span class="co"># let's see a single Head perform self-attention</span></span>
<span id="cb64-361"><a href="#cb64-361"></a>head_size <span class="op">=</span> <span class="dv">16</span></span>
<span id="cb64-362"><a href="#cb64-362"></a>key <span class="op">=</span> nn.Linear(C, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb64-363"><a href="#cb64-363"></a>query <span class="op">=</span> nn.Linear(C, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb64-364"><a href="#cb64-364"></a>value <span class="op">=</span> nn.Linear(C, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb64-365"><a href="#cb64-365"></a>k <span class="op">=</span> key(x)   <span class="co"># (B, T, head_size)</span></span>
<span id="cb64-366"><a href="#cb64-366"></a>q <span class="op">=</span> query(x) <span class="co"># (B, T, head_size)</span></span>
<span id="cb64-367"><a href="#cb64-367"></a><span class="co"># Compute attention scores ("affinities")</span></span>
<span id="cb64-368"><a href="#cb64-368"></a>wei <span class="op">=</span> q <span class="op">@</span> k.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>) <span class="co"># (B, T, hs) @ (B, hs, T) ---&gt; (B, T, T)</span></span>
<span id="cb64-369"><a href="#cb64-369"></a></span>
<span id="cb64-370"><a href="#cb64-370"></a><span class="co"># Scale the scores</span></span>
<span id="cb64-371"><a href="#cb64-371"></a><span class="co"># Note: Karpathy uses C**-0.5 here (sqrt(embedding_dim)). Standard Transformer uses sqrt(head_size).</span></span>
<span id="cb64-372"><a href="#cb64-372"></a>wei <span class="op">=</span> wei <span class="op">*</span> (C<span class="op">**-</span><span class="fl">0.5</span>)</span>
<span id="cb64-373"><a href="#cb64-373"></a></span>
<span id="cb64-374"><a href="#cb64-374"></a><span class="co"># Apply causal mask</span></span>
<span id="cb64-375"><a href="#cb64-375"></a>tril <span class="op">=</span> torch.tril(torch.ones(T, T))</span>
<span id="cb64-376"><a href="#cb64-376"></a><span class="co">#wei = torch.zeros((T,T)) # This line is commented out in original, was from softmax demo</span></span>
<span id="cb64-377"><a href="#cb64-377"></a>wei <span class="op">=</span> wei.masked_fill(tril <span class="op">==</span> <span class="dv">0</span>, <span class="bu">float</span>(<span class="st">'-inf'</span>)) <span class="co"># Mask future tokens</span></span>
<span id="cb64-378"><a href="#cb64-378"></a></span>
<span id="cb64-379"><a href="#cb64-379"></a><span class="co"># Apply softmax to get attention weights</span></span>
<span id="cb64-380"><a href="#cb64-380"></a>wei <span class="op">=</span> F.softmax(wei, dim<span class="op">=-</span><span class="dv">1</span>) <span class="co"># (B, T, T)</span></span>
<span id="cb64-381"><a href="#cb64-381"></a></span>
<span id="cb64-382"><a href="#cb64-382"></a><span class="co"># Perform weighted aggregation of Values</span></span>
<span id="cb64-383"><a href="#cb64-383"></a>v <span class="op">=</span> value(x) <span class="co"># (B, T, head_size)</span></span>
<span id="cb64-384"><a href="#cb64-384"></a>out <span class="op">=</span> wei <span class="op">@</span> v <span class="co"># (B, T, T) @ (B, T, hs) ---&gt; (B, T, hs)</span></span>
<span id="cb64-385"><a href="#cb64-385"></a><span class="co">#out = wei @ x # This would aggregate original x, not the projected values 'v'</span></span>
<span id="cb64-386"><a href="#cb64-386"></a></span>
<span id="cb64-387"><a href="#cb64-387"></a>out.shape <span class="co"># Expected: (B, T, head_size) = (4, 8, 16)</span></span>
<span id="cb64-388"><a href="#cb64-388"></a><span class="in">```</span></span>
<span id="cb64-389"><a href="#cb64-389"></a></span>
<span id="cb64-392"><a href="#cb64-392"></a><span class="in">```{python}</span></span>
<span id="cb64-393"><a href="#cb64-393"></a>wei[<span class="dv">0</span>] <span class="co"># Show attention weights for the first sequence in the batch</span></span>
<span id="cb64-394"><a href="#cb64-394"></a><span class="in">```</span></span>
<span id="cb64-395"><a href="#cb64-395"></a></span>
<span id="cb64-396"><a href="#cb64-396"></a></span>
<span id="cb64-397"><a href="#cb64-397"></a><span class="fu">### Check that X X'/C is is the correlation matrix if X is normalized</span></span>
<span id="cb64-398"><a href="#cb64-398"></a></span>
<span id="cb64-399"><a href="#cb64-399"></a><span class="in">```{r showing xx'/C is correlation matrix if X is normalized}</span></span>
<span id="cb64-400"><a href="#cb64-400"></a></span>
<span id="cb64-401"><a href="#cb64-401"></a>nC <span class="ot">=</span> <span class="dv">64</span></span>
<span id="cb64-402"><a href="#cb64-402"></a>X <span class="ot">=</span> <span class="fu">matrix</span>(<span class="fu">rnorm</span>(<span class="dv">4</span><span class="sc">*</span><span class="dv">64</span>), <span class="at">nrow=</span><span class="dv">4</span>, <span class="at">ncol=</span>nC)</span>
<span id="cb64-403"><a href="#cb64-403"></a><span class="do">## make it so that the third token is similar to the last one</span></span>
<span id="cb64-404"><a href="#cb64-404"></a>X[<span class="dv">2</span>,] <span class="ot">=</span> X[<span class="dv">4</span>,]<span class="sc">*</span><span class="fl">0.5</span> <span class="sc">+</span> X[<span class="dv">2</span>,]<span class="sc">*</span><span class="fl">0.5</span></span>
<span id="cb64-405"><a href="#cb64-405"></a><span class="do">## normalize X</span></span>
<span id="cb64-406"><a href="#cb64-406"></a>X <span class="ot">=</span> <span class="fu">t</span>(<span class="fu">scale</span>(<span class="fu">t</span>(X)))</span>
<span id="cb64-407"><a href="#cb64-407"></a></span>
<span id="cb64-408"><a href="#cb64-408"></a>q <span class="ot">=</span> X</span>
<span id="cb64-409"><a href="#cb64-409"></a>k <span class="ot">=</span> X</span>
<span id="cb64-410"><a href="#cb64-410"></a>v <span class="ot">=</span> X</span>
<span id="cb64-411"><a href="#cb64-411"></a></span>
<span id="cb64-412"><a href="#cb64-412"></a>qkt <span class="ot">=</span> q <span class="sc">%*%</span> <span class="fu">t</span>(k)<span class="sc">/</span>(nC<span class="dv">-1</span>)</span>
<span id="cb64-413"><a href="#cb64-413"></a>xcor <span class="ot">=</span> <span class="fu">cor</span>(<span class="fu">t</span>(q),<span class="fu">t</span>(k))</span>
<span id="cb64-414"><a href="#cb64-414"></a><span class="fu">dim</span>(xcor)</span>
<span id="cb64-415"><a href="#cb64-415"></a><span class="fu">dim</span>(qkt)</span>
<span id="cb64-416"><a href="#cb64-416"></a><span class="fu">cat</span>(<span class="st">"xcor</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb64-417"><a href="#cb64-417"></a>xcor</span>
<span id="cb64-418"><a href="#cb64-418"></a><span class="fu">cat</span>(<span class="st">"---</span><span class="sc">\n</span><span class="st"> qkt</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb64-419"><a href="#cb64-419"></a>qkt</span>
<span id="cb64-420"><a href="#cb64-420"></a></span>
<span id="cb64-421"><a href="#cb64-421"></a><span class="fu">cat</span>(<span class="st">"are xcor and qkt equal?"</span>)</span>
<span id="cb64-422"><a href="#cb64-422"></a><span class="fu">all.equal</span>(xcor, qkt)</span>
<span id="cb64-423"><a href="#cb64-423"></a></span>
<span id="cb64-424"><a href="#cb64-424"></a><span class="fu">par</span>(<span class="at">mar=</span><span class="fu">c</span>(<span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">4</span>, <span class="dv">2</span>) <span class="sc">+</span> <span class="fl">0.1</span>)  <span class="co"># increase left margin to avoid cutting of the y label</span></span>
<span id="cb64-425"><a href="#cb64-425"></a><span class="fu">par</span>(<span class="at">pty=</span><span class="st">"s"</span>)  <span class="co"># Set plot type to "square"</span></span>
<span id="cb64-426"><a href="#cb64-426"></a><span class="fu">plot</span>(<span class="fu">c</span>(xcor), <span class="fu">c</span>(qkt),<span class="at">cex=</span><span class="dv">3</span>,<span class="at">cex.lab=</span><span class="dv">3</span>,<span class="at">cex.axis=</span><span class="dv">2</span>,<span class="at">cex.main=</span><span class="dv">2</span>,<span class="at">cex.sub=</span><span class="dv">2</span>); <span class="fu">abline</span>(<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb64-427"><a href="#cb64-427"></a><span class="fu">par</span>(<span class="at">pty=</span><span class="st">"m"</span>)  <span class="co"># Reset to default plot type</span></span>
<span id="cb64-428"><a href="#cb64-428"></a><span class="fu">par</span>(<span class="at">mar=</span><span class="fu">c</span>(<span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">2</span>) <span class="sc">+</span> <span class="fl">0.1</span>)  <span class="co"># Reset to default margins</span></span>
<span id="cb64-429"><a href="#cb64-429"></a></span>
<span id="cb64-430"><a href="#cb64-430"></a></span>
<span id="cb64-431"><a href="#cb64-431"></a><span class="in">```</span></span>
<span id="cb64-432"><a href="#cb64-432"></a></span>
<span id="cb64-433"><a href="#cb64-433"></a></span>
<span id="cb64-434"><a href="#cb64-434"></a><span class="fu">### Notes:</span></span>
<span id="cb64-435"><a href="#cb64-435"></a></span>
<span id="cb64-436"><a href="#cb64-436"></a>Attention is a communication mechanism. Can be seen as nodes in a directed graph looking at each other and aggregating information with a weighted sum from all nodes that point to them, with data-dependent weights. </span>
<span id="cb64-437"><a href="#cb64-437"></a></span>
<span id="cb64-438"><a href="#cb64-438"></a><span class="ss">- </span>There is no notion of space. Attention simply acts over a set of vectors. This is why we need to positionally encode tokens. </span>
<span id="cb64-439"><a href="#cb64-439"></a>    example: "the cat sat on the mat" should be different from "the mat sat on the cat"</span>
<span id="cb64-440"><a href="#cb64-440"></a><span class="ss">- </span>Each example across batch dimension is of course processed completely independently and never "talk" to each other. </span>
<span id="cb64-441"><a href="#cb64-441"></a><span class="ss">- </span>In an "encoder" attention block just delete the single line that does masking with tril, allowing all tokens to communicate. This block here is called a "decoder" attention block because it has triangular masking, and is usually used in autoregressive settings, like language modeling. </span>
<span id="cb64-442"><a href="#cb64-442"></a><span class="ss">- </span>"self-attention" just means that the keys and values are produced from the same source as queries (all come from x). In "cross-attention", the queries still get produced from x, but the keys and values come from some other, external source (e.g. an encoder module)</span>
<span id="cb64-443"><a href="#cb64-443"></a></span>
<span id="cb64-444"><a href="#cb64-444"></a><span class="fu">### why scaled attention?</span></span>
<span id="cb64-445"><a href="#cb64-445"></a></span>
<span id="cb64-446"><a href="#cb64-446"></a>"Scaled" attention additionaly divides wei by 1/sqrt(head_size). This makes it so when input Q,K are unit variance, wei will be unit variance too and Softmax will stay diffuse and not saturate too much. Illustration below</span>
<span id="cb64-447"><a href="#cb64-447"></a></span>
<span id="cb64-450"><a href="#cb64-450"></a><span class="in">```{python}</span></span>
<span id="cb64-451"><a href="#cb64-451"></a><span class="co"># Demonstrate variance without scaling</span></span>
<span id="cb64-452"><a href="#cb64-452"></a>k_unscaled <span class="op">=</span> torch.randn(B,T,head_size)</span>
<span id="cb64-453"><a href="#cb64-453"></a>q_unscaled <span class="op">=</span> torch.randn(B,T,head_size)</span>
<span id="cb64-454"><a href="#cb64-454"></a>wei_unscaled <span class="op">=</span> q_unscaled <span class="op">@</span> k_unscaled.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb64-455"><a href="#cb64-455"></a><span class="bu">print</span>(<span class="ss">f"k var: </span><span class="sc">{</span>k_unscaled<span class="sc">.</span>var()<span class="sc">:.4f}</span><span class="ss">, q var: </span><span class="sc">{</span>q_unscaled<span class="sc">.</span>var()<span class="sc">:.4f}</span><span class="ss">, wei (unscaled) var: </span><span class="sc">{</span>wei_unscaled<span class="sc">.</span>var()<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb64-456"><a href="#cb64-456"></a></span>
<span id="cb64-457"><a href="#cb64-457"></a><span class="co"># Demonstrate variance *with* scaling (using head_size for illustration)</span></span>
<span id="cb64-458"><a href="#cb64-458"></a>k <span class="op">=</span> torch.randn(B,T,head_size)</span>
<span id="cb64-459"><a href="#cb64-459"></a>q <span class="op">=</span> torch.randn(B,T,head_size)</span>
<span id="cb64-460"><a href="#cb64-460"></a>wei <span class="op">=</span> q <span class="op">@</span> k.transpose(<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>) <span class="op">*</span> head_size<span class="op">**-</span><span class="fl">0.5</span> <span class="co"># Scale by sqrt(head_size)</span></span>
<span id="cb64-461"><a href="#cb64-461"></a><span class="bu">print</span>(<span class="ss">f"k var: </span><span class="sc">{</span>k<span class="sc">.</span>var()<span class="sc">:.4f}</span><span class="ss">, q var: </span><span class="sc">{</span>q<span class="sc">.</span>var()<span class="sc">:.4f}</span><span class="ss">, wei (scaled) var: </span><span class="sc">{</span>wei<span class="sc">.</span>var()<span class="sc">:.4f}</span><span class="ss">"</span>) <span class="co"># Variance should be closer to 1</span></span>
<span id="cb64-462"><a href="#cb64-462"></a><span class="in">```</span></span>
<span id="cb64-463"><a href="#cb64-463"></a></span>
<span id="cb64-466"><a href="#cb64-466"></a><span class="in">```{python}</span></span>
<span id="cb64-467"><a href="#cb64-467"></a>k.var() <span class="co"># Should be close to 1</span></span>
<span id="cb64-468"><a href="#cb64-468"></a><span class="in">```</span></span>
<span id="cb64-469"><a href="#cb64-469"></a></span>
<span id="cb64-472"><a href="#cb64-472"></a><span class="in">```{python}</span></span>
<span id="cb64-473"><a href="#cb64-473"></a>q.var() <span class="co"># Should be close to 1</span></span>
<span id="cb64-474"><a href="#cb64-474"></a><span class="in">```</span></span>
<span id="cb64-475"><a href="#cb64-475"></a></span>
<span id="cb64-478"><a href="#cb64-478"></a><span class="in">```{python}</span></span>
<span id="cb64-479"><a href="#cb64-479"></a>wei.var() <span class="co"># With scaling, should be closer to 1 than head_size (16)</span></span>
<span id="cb64-480"><a href="#cb64-480"></a><span class="in">```</span></span>
<span id="cb64-481"><a href="#cb64-481"></a></span>
<span id="cb64-484"><a href="#cb64-484"></a><span class="in">```{python}</span></span>
<span id="cb64-485"><a href="#cb64-485"></a><span class="co"># Softmax with small inputs (diffuse distribution)</span></span>
<span id="cb64-486"><a href="#cb64-486"></a>torch.softmax(torch.tensor([<span class="fl">0.1</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.5</span>]), dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb64-487"><a href="#cb64-487"></a><span class="in">```</span></span>
<span id="cb64-488"><a href="#cb64-488"></a></span>
<span id="cb64-491"><a href="#cb64-491"></a><span class="in">```{python}</span></span>
<span id="cb64-492"><a href="#cb64-492"></a><span class="co"># Softmax with large inputs (simulating unscaled attention scores) -&gt; peaks</span></span>
<span id="cb64-493"><a href="#cb64-493"></a>torch.softmax(torch.tensor([<span class="fl">0.1</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.5</span>])<span class="op">*</span><span class="dv">8</span>, dim<span class="op">=-</span><span class="dv">1</span>) <span class="co"># gets too peaky, converges to one-hot</span></span>
<span id="cb64-494"><a href="#cb64-494"></a><span class="in">```</span></span>
<span id="cb64-495"><a href="#cb64-495"></a></span>
<span id="cb64-496"><a href="#cb64-496"></a><span class="fu">### LayerNorm1d</span></span>
<span id="cb64-497"><a href="#cb64-497"></a></span>
<span id="cb64-500"><a href="#cb64-500"></a><span class="in">```{python}</span></span>
<span id="cb64-501"><a href="#cb64-501"></a><span class="kw">class</span> LayerNorm1d: <span class="co"># (used to be BatchNorm1d)</span></span>
<span id="cb64-502"><a href="#cb64-502"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dim, eps<span class="op">=</span><span class="fl">1e-5</span>, momentum<span class="op">=</span><span class="fl">0.1</span>): <span class="co"># Momentum is not used in typical LayerNorm</span></span>
<span id="cb64-503"><a href="#cb64-503"></a>        <span class="va">self</span>.eps <span class="op">=</span> eps</span>
<span id="cb64-504"><a href="#cb64-504"></a>        <span class="co"># Learnable scale and shift parameters, initialized to 1 and 0</span></span>
<span id="cb64-505"><a href="#cb64-505"></a>        <span class="va">self</span>.gamma <span class="op">=</span> torch.ones(dim)</span>
<span id="cb64-506"><a href="#cb64-506"></a>        <span class="va">self</span>.beta <span class="op">=</span> torch.zeros(dim)</span>
<span id="cb64-507"><a href="#cb64-507"></a></span>
<span id="cb64-508"><a href="#cb64-508"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb64-509"><a href="#cb64-509"></a>        <span class="co"># calculate the forward pass</span></span>
<span id="cb64-510"><a href="#cb64-510"></a>        <span class="co"># Calculate mean over the *last* dimension (features/embedding)</span></span>
<span id="cb64-511"><a href="#cb64-511"></a>        xmean <span class="op">=</span> x.mean(<span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>) <span class="co"># batch mean (shape B, 1, C if input B, T, C) --&gt; Needs adjustment for (B,C) input shape here. Assumes input is (B, dim)</span></span>
<span id="cb64-512"><a href="#cb64-512"></a>        <span class="co"># Correction: x is (32, 100). dim=1 is correct for features. Shape (32, 1)</span></span>
<span id="cb64-513"><a href="#cb64-513"></a>        xvar <span class="op">=</span> x.var(<span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>) <span class="co"># batch variance (shape 32, 1)</span></span>
<span id="cb64-514"><a href="#cb64-514"></a>        <span class="co"># Normalize each feature vector independently</span></span>
<span id="cb64-515"><a href="#cb64-515"></a>        xhat <span class="op">=</span> (x <span class="op">-</span> xmean) <span class="op">/</span> torch.sqrt(xvar <span class="op">+</span> <span class="va">self</span>.eps) <span class="co"># normalize to unit variance</span></span>
<span id="cb64-516"><a href="#cb64-516"></a>        <span class="co"># Apply scale and shift</span></span>
<span id="cb64-517"><a href="#cb64-517"></a>        <span class="va">self</span>.out <span class="op">=</span> <span class="va">self</span>.gamma <span class="op">*</span> xhat <span class="op">+</span> <span class="va">self</span>.beta</span>
<span id="cb64-518"><a href="#cb64-518"></a>        <span class="cf">return</span> <span class="va">self</span>.out</span>
<span id="cb64-519"><a href="#cb64-519"></a></span>
<span id="cb64-520"><a href="#cb64-520"></a>    <span class="kw">def</span> parameters(<span class="va">self</span>):</span>
<span id="cb64-521"><a href="#cb64-521"></a>        <span class="co"># Expose gamma and beta as learnable parameters</span></span>
<span id="cb64-522"><a href="#cb64-522"></a>        <span class="cf">return</span> [<span class="va">self</span>.gamma, <span class="va">self</span>.beta]</span>
<span id="cb64-523"><a href="#cb64-523"></a></span>
<span id="cb64-524"><a href="#cb64-524"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb64-525"><a href="#cb64-525"></a>module <span class="op">=</span> LayerNorm1d(<span class="dv">100</span>) <span class="co"># Create LayerNorm for 100 features</span></span>
<span id="cb64-526"><a href="#cb64-526"></a>x <span class="op">=</span> torch.randn(<span class="dv">32</span>, <span class="dv">100</span>) <span class="co"># batch size 32 of 100-dimensional vectors</span></span>
<span id="cb64-527"><a href="#cb64-527"></a>x <span class="op">=</span> module(x)</span>
<span id="cb64-528"><a href="#cb64-528"></a>x.shape <span class="co"># Should be (32, 100)</span></span>
<span id="cb64-529"><a href="#cb64-529"></a><span class="in">```</span></span>
<span id="cb64-530"><a href="#cb64-530"></a></span>
<span id="cb64-531"><a href="#cb64-531"></a>Explanation of layernorm</span>
<span id="cb64-532"><a href="#cb64-532"></a></span>
<span id="cb64-533"><a href="#cb64-533"></a>Input shape: (B, T, C) where:</span>
<span id="cb64-534"><a href="#cb64-534"></a>B = batch size</span>
<span id="cb64-535"><a href="#cb64-535"></a>T = sequence length (number of tokens)</span>
<span id="cb64-536"><a href="#cb64-536"></a>C = embedding dimension (features of each token)</span>
<span id="cb64-537"><a href="#cb64-537"></a>For each token in the sequence (each position T), LayerNorm:</span>
<span id="cb64-538"><a href="#cb64-538"></a>Takes its embedding vector of size C</span>
<span id="cb64-539"><a href="#cb64-539"></a>Calculates the mean and standard deviation of just that vector</span>
<span id="cb64-540"><a href="#cb64-540"></a>Normalizes that vector by subtracting its mean and dividing by its standard deviation</span>
<span id="cb64-541"><a href="#cb64-541"></a>Applies the learnable scale (gamma) and shift (beta) parameters</span>
<span id="cb64-542"><a href="#cb64-542"></a>So if you have a sequence like "The cat sat", and each word is represented by a 64-dimensional embedding vector, LayerNorm would:</span>
<span id="cb64-543"><a href="#cb64-543"></a>Take "The"'s 64-dimensional vector and normalize it</span>
<span id="cb64-544"><a href="#cb64-544"></a>Take "cat"'s 64-dimensional vector and normalize it</span>
<span id="cb64-545"><a href="#cb64-545"></a>Take "sat"'s 64-dimensional vector and normalize it</span>
<span id="cb64-546"><a href="#cb64-546"></a>Each token's vector is normalized independently of the others. This is different from BatchNorm, which would normalize across the batch dimension (i.e., looking at the same position across different examples in the batch).</span>
<span id="cb64-547"><a href="#cb64-547"></a>This per-token normalization helps maintain stable gradients during training and is particularly important in Transformers where the attention mechanism needs to work with normalized vectors to compute meaningful attention scores.</span>
<span id="cb64-548"><a href="#cb64-548"></a></span>
<span id="cb64-551"><a href="#cb64-551"></a><span class="in">```{python}</span></span>
<span id="cb64-552"><a href="#cb64-552"></a><span class="co"># Mean and std of the first feature *across the batch*. Not expected to be 0 and 1.</span></span>
<span id="cb64-553"><a href="#cb64-553"></a>x[:,<span class="dv">0</span>].mean(), x[:,<span class="dv">0</span>].std()</span>
<span id="cb64-554"><a href="#cb64-554"></a><span class="in">```</span></span>
<span id="cb64-555"><a href="#cb64-555"></a></span>
<span id="cb64-558"><a href="#cb64-558"></a><span class="in">```{python}</span></span>
<span id="cb64-559"><a href="#cb64-559"></a><span class="co"># Mean and std *across features* for the first item in the batch. Expected to be ~0 and ~1.</span></span>
<span id="cb64-560"><a href="#cb64-560"></a>x[<span class="dv">0</span>,:].mean(), x[<span class="dv">0</span>,:].std()</span>
<span id="cb64-561"><a href="#cb64-561"></a><span class="in">```</span></span>
<span id="cb64-562"><a href="#cb64-562"></a></span>
<span id="cb64-563"><a href="#cb64-563"></a><span class="fu">### French to English translation example:</span></span>
<span id="cb64-566"><a href="#cb64-566"></a><span class="in">```{python}</span></span>
<span id="cb64-567"><a href="#cb64-567"></a><span class="co"># &lt;--------- ENCODE ------------------&gt;&lt;--------------- DECODE -----------------&gt;</span></span>
<span id="cb64-568"><a href="#cb64-568"></a><span class="co"># les réseaux de neurones sont géniaux! &lt;START&gt; neural networks are awesome!&lt;</span><span class="re">END</span><span class="co">&gt;</span></span>
<span id="cb64-569"><a href="#cb64-569"></a><span class="in">```</span></span>
<span id="cb64-570"><a href="#cb64-570"></a></span>
<span id="cb64-571"><a href="#cb64-571"></a><span class="fu">### Full finished code, for reference</span></span>
<span id="cb64-572"><a href="#cb64-572"></a></span>
<span id="cb64-575"><a href="#cb64-575"></a><span class="in">```{python}</span></span>
<span id="cb64-576"><a href="#cb64-576"></a><span class="co"># Import necessary PyTorch modules</span></span>
<span id="cb64-577"><a href="#cb64-577"></a><span class="im">import</span> torch</span>
<span id="cb64-578"><a href="#cb64-578"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb64-579"><a href="#cb64-579"></a><span class="im">from</span> torch.nn <span class="im">import</span> functional <span class="im">as</span> F</span>
<span id="cb64-580"><a href="#cb64-580"></a></span>
<span id="cb64-581"><a href="#cb64-581"></a><span class="co"># ===== HYPERPARAMETERS =====</span></span>
<span id="cb64-582"><a href="#cb64-582"></a>batch_size <span class="op">=</span> <span class="dv">16</span>       <span class="co"># Number of sequences per batch (Smaller than Bigram training)</span></span>
<span id="cb64-583"><a href="#cb64-583"></a>block_size <span class="op">=</span> <span class="dv">32</span>       <span class="co"># Context length (Larger than Bigram demo)</span></span>
<span id="cb64-584"><a href="#cb64-584"></a>max_iters <span class="op">=</span> <span class="dv">5000</span>      <span class="co"># Total training iterations (More substantial training) </span><span class="al">TODO</span><span class="co"> change to 5000 later</span></span>
<span id="cb64-585"><a href="#cb64-585"></a>eval_interval <span class="op">=</span> <span class="dv">100</span>   <span class="co"># How often to check validation loss</span></span>
<span id="cb64-586"><a href="#cb64-586"></a>learning_rate <span class="op">=</span> <span class="fl">1e-3</span>  <span class="co"># Optimizer learning rate</span></span>
<span id="cb64-587"><a href="#cb64-587"></a>eval_iters <span class="op">=</span> <span class="dv">200</span>      <span class="co"># Number of batches to average for validation loss estimate</span></span>
<span id="cb64-588"><a href="#cb64-588"></a>n_embd <span class="op">=</span> <span class="dv">64</span>           <span class="co"># Embedding dimension (Size of token vectors)</span></span>
<span id="cb64-589"><a href="#cb64-589"></a>n_head <span class="op">=</span> <span class="dv">4</span>            <span class="co"># Number of attention heads</span></span>
<span id="cb64-590"><a href="#cb64-590"></a>n_layer <span class="op">=</span> <span class="dv">4</span>           <span class="co"># Number of Transformer blocks (layers)</span></span>
<span id="cb64-591"><a href="#cb64-591"></a>dropout <span class="op">=</span> <span class="fl">0.0</span>         <span class="co"># Dropout probability (0.0 means no dropout here)</span></span>
<span id="cb64-592"><a href="#cb64-592"></a><span class="co"># ==========================</span></span>
<span id="cb64-593"><a href="#cb64-593"></a></span>
<span id="cb64-594"><a href="#cb64-594"></a><span class="co"># Device selection: MPS (Apple Silicon) &gt; CUDA &gt; CPU</span></span>
<span id="cb64-595"><a href="#cb64-595"></a><span class="cf">if</span> torch.backends.mps.is_available():</span>
<span id="cb64-596"><a href="#cb64-596"></a>    device <span class="op">=</span> torch.device(<span class="st">"mps"</span>)   <span class="co"># Apple Silicon GPU</span></span>
<span id="cb64-597"><a href="#cb64-597"></a><span class="cf">elif</span> torch.cuda.is_available():</span>
<span id="cb64-598"><a href="#cb64-598"></a>    device <span class="op">=</span> torch.device(<span class="st">"cuda"</span>)  <span class="co"># NVIDIA GPU</span></span>
<span id="cb64-599"><a href="#cb64-599"></a><span class="cf">else</span>:</span>
<span id="cb64-600"><a href="#cb64-600"></a>    device <span class="op">=</span> torch.device(<span class="st">"cpu"</span>)   <span class="co"># CPU fallback</span></span>
<span id="cb64-601"><a href="#cb64-601"></a><span class="bu">print</span>(<span class="ss">f"Using device: </span><span class="sc">{</span>device<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb64-602"><a href="#cb64-602"></a></span>
<span id="cb64-603"><a href="#cb64-603"></a><span class="co"># Set random seed for reproducibility</span></span>
<span id="cb64-604"><a href="#cb64-604"></a>torch.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb64-605"><a href="#cb64-605"></a><span class="cf">if</span> device.<span class="bu">type</span> <span class="op">==</span> <span class="st">'cuda'</span>:</span>
<span id="cb64-606"><a href="#cb64-606"></a>    torch.cuda.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb64-607"><a href="#cb64-607"></a><span class="cf">elif</span> device.<span class="bu">type</span> <span class="op">==</span> <span class="st">'mps'</span>:</span>
<span id="cb64-608"><a href="#cb64-608"></a>    torch.mps.manual_seed(<span class="dv">1337</span>)</span>
<span id="cb64-609"><a href="#cb64-609"></a></span>
<span id="cb64-610"><a href="#cb64-610"></a><span class="co"># Load and read the training text (assuming input.txt is available)</span></span>
<span id="cb64-611"><a href="#cb64-611"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">'input.txt'</span>, <span class="st">'r'</span>, encoding<span class="op">=</span><span class="st">'utf-8'</span>) <span class="im">as</span> f:</span>
<span id="cb64-612"><a href="#cb64-612"></a>    text <span class="op">=</span> f.read()</span>
<span id="cb64-613"><a href="#cb64-613"></a></span>
<span id="cb64-614"><a href="#cb64-614"></a><span class="co"># ===== DATA PREPROCESSING =====</span></span>
<span id="cb64-615"><a href="#cb64-615"></a>chars <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(text)))</span>
<span id="cb64-616"><a href="#cb64-616"></a>vocab_size <span class="op">=</span> <span class="bu">len</span>(chars)</span>
<span id="cb64-617"><a href="#cb64-617"></a>stoi <span class="op">=</span> { ch:i <span class="cf">for</span> i,ch <span class="kw">in</span> <span class="bu">enumerate</span>(chars) }   <span class="co"># string to index</span></span>
<span id="cb64-618"><a href="#cb64-618"></a>itos <span class="op">=</span> { i:ch <span class="cf">for</span> i,ch <span class="kw">in</span> <span class="bu">enumerate</span>(chars) }   <span class="co"># index to string</span></span>
<span id="cb64-619"><a href="#cb64-619"></a>encode <span class="op">=</span> <span class="kw">lambda</span> s: [stoi[c] <span class="cf">for</span> c <span class="kw">in</span> s]   <span class="co"># convert string to list of integers</span></span>
<span id="cb64-620"><a href="#cb64-620"></a>decode <span class="op">=</span> <span class="kw">lambda</span> l: <span class="st">''</span>.join([itos[i] <span class="cf">for</span> i <span class="kw">in</span> l])   <span class="co"># convert list of integers to string</span></span>
<span id="cb64-621"><a href="#cb64-621"></a></span>
<span id="cb64-622"><a href="#cb64-622"></a><span class="co"># Split data into training and validation sets</span></span>
<span id="cb64-623"><a href="#cb64-623"></a>data <span class="op">=</span> torch.tensor(encode(text), dtype<span class="op">=</span>torch.<span class="bu">long</span>)</span>
<span id="cb64-624"><a href="#cb64-624"></a>n <span class="op">=</span> <span class="bu">int</span>(<span class="fl">0.9</span><span class="op">*</span><span class="bu">len</span>(data))   <span class="co"># first 90% for training</span></span>
<span id="cb64-625"><a href="#cb64-625"></a>train_data <span class="op">=</span> data[:n]</span>
<span id="cb64-626"><a href="#cb64-626"></a>val_data <span class="op">=</span> data[n:]</span>
<span id="cb64-627"><a href="#cb64-627"></a><span class="co"># =============================</span></span>
<span id="cb64-628"><a href="#cb64-628"></a></span>
<span id="cb64-629"><a href="#cb64-629"></a><span class="co"># ===== DATA LOADING FUNCTION =====</span></span>
<span id="cb64-630"><a href="#cb64-630"></a><span class="kw">def</span> get_batch(split):</span>
<span id="cb64-631"><a href="#cb64-631"></a>    <span class="co">"""Generate a batch of data for training or validation."""</span></span>
<span id="cb64-632"><a href="#cb64-632"></a>    data <span class="op">=</span> train_data <span class="cf">if</span> split <span class="op">==</span> <span class="st">'train'</span> <span class="cf">else</span> val_data</span>
<span id="cb64-633"><a href="#cb64-633"></a>    ix <span class="op">=</span> torch.randint(<span class="bu">len</span>(data) <span class="op">-</span> block_size, (batch_size,))</span>
<span id="cb64-634"><a href="#cb64-634"></a>    x <span class="op">=</span> torch.stack([data[i:i<span class="op">+</span>block_size] <span class="cf">for</span> i <span class="kw">in</span> ix])</span>
<span id="cb64-635"><a href="#cb64-635"></a>    y <span class="op">=</span> torch.stack([data[i<span class="op">+</span><span class="dv">1</span>:i<span class="op">+</span>block_size<span class="op">+</span><span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> ix])</span>
<span id="cb64-636"><a href="#cb64-636"></a>    x, y <span class="op">=</span> x.to(device), y.to(device) <span class="co"># Move data to the target device</span></span>
<span id="cb64-637"><a href="#cb64-637"></a>    <span class="cf">return</span> x, y</span>
<span id="cb64-638"><a href="#cb64-638"></a><span class="co"># ================================</span></span>
<span id="cb64-639"><a href="#cb64-639"></a></span>
<span id="cb64-640"><a href="#cb64-640"></a><span class="co"># ===== LOSS ESTIMATION FUNCTION =====</span></span>
<span id="cb64-641"><a href="#cb64-641"></a><span class="at">@torch.no_grad</span>()   <span class="co"># Disable gradient calculation for efficiency</span></span>
<span id="cb64-642"><a href="#cb64-642"></a><span class="kw">def</span> estimate_loss():</span>
<span id="cb64-643"><a href="#cb64-643"></a>    <span class="co">"""Estimate the loss on training and validation sets."""</span></span>
<span id="cb64-644"><a href="#cb64-644"></a>    out <span class="op">=</span> {}</span>
<span id="cb64-645"><a href="#cb64-645"></a>    model.<span class="bu">eval</span>()   <span class="co"># Set model to evaluation mode</span></span>
<span id="cb64-646"><a href="#cb64-646"></a>    <span class="cf">for</span> split <span class="kw">in</span> [<span class="st">'train'</span>, <span class="st">'val'</span>]:</span>
<span id="cb64-647"><a href="#cb64-647"></a>        losses <span class="op">=</span> torch.zeros(eval_iters)</span>
<span id="cb64-648"><a href="#cb64-648"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(eval_iters):</span>
<span id="cb64-649"><a href="#cb64-649"></a>            X, Y <span class="op">=</span> get_batch(split)</span>
<span id="cb64-650"><a href="#cb64-650"></a>            logits, loss <span class="op">=</span> model(X, Y)</span>
<span id="cb64-651"><a href="#cb64-651"></a>            losses[k] <span class="op">=</span> loss.item()</span>
<span id="cb64-652"><a href="#cb64-652"></a>        out[split] <span class="op">=</span> losses.mean()</span>
<span id="cb64-653"><a href="#cb64-653"></a>    model.train()  <span class="co"># Set model back to training mode</span></span>
<span id="cb64-654"><a href="#cb64-654"></a>    <span class="cf">return</span> out</span>
<span id="cb64-655"><a href="#cb64-655"></a><span class="co"># ===================================</span></span>
<span id="cb64-656"><a href="#cb64-656"></a></span>
<span id="cb64-657"><a href="#cb64-657"></a><span class="co"># ===== </span><span class="al">ATTENTION</span><span class="co"> HEAD IMPLEMENTATION =====</span></span>
<span id="cb64-658"><a href="#cb64-658"></a><span class="kw">class</span> Head(nn.Module):</span>
<span id="cb64-659"><a href="#cb64-659"></a>    <span class="co">"""Single head of self-attention."""</span></span>
<span id="cb64-660"><a href="#cb64-660"></a>    </span>
<span id="cb64-661"><a href="#cb64-661"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, head_size):</span>
<span id="cb64-662"><a href="#cb64-662"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb64-663"><a href="#cb64-663"></a>        <span class="co"># Linear projections for Key, Query, Value</span></span>
<span id="cb64-664"><a href="#cb64-664"></a>        <span class="va">self</span>.key <span class="op">=</span> nn.Linear(n_embd, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb64-665"><a href="#cb64-665"></a>        <span class="va">self</span>.query <span class="op">=</span> nn.Linear(n_embd, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb64-666"><a href="#cb64-666"></a>        <span class="va">self</span>.value <span class="op">=</span> nn.Linear(n_embd, head_size, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb64-667"><a href="#cb64-667"></a>        <span class="co"># Causal mask (tril). 'register_buffer' makes it part of the model state but not a parameter to be trained.</span></span>
<span id="cb64-668"><a href="#cb64-668"></a>        <span class="va">self</span>.register_buffer(<span class="st">'tril'</span>, torch.tril(torch.ones(block_size, block_size)))</span>
<span id="cb64-669"><a href="#cb64-669"></a>        <span class="co"># Dropout layer (applied after softmax)</span></span>
<span id="cb64-670"><a href="#cb64-670"></a>        <span class="va">self</span>.dropout <span class="op">=</span> nn.Dropout(dropout)</span>
<span id="cb64-671"><a href="#cb64-671"></a></span>
<span id="cb64-672"><a href="#cb64-672"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb64-673"><a href="#cb64-673"></a>        B,T,C <span class="op">=</span> x.shape <span class="co"># C here is n_embd</span></span>
<span id="cb64-674"><a href="#cb64-674"></a>        <span class="co"># Project input to K, Q, V</span></span>
<span id="cb64-675"><a href="#cb64-675"></a>        k <span class="op">=</span> <span class="va">self</span>.key(x)   <span class="co"># (B,T,head_size)</span></span>
<span id="cb64-676"><a href="#cb64-676"></a>        q <span class="op">=</span> <span class="va">self</span>.query(x) <span class="co"># (B,T,head_size)</span></span>
<span id="cb64-677"><a href="#cb64-677"></a>        <span class="co"># Compute attention scores, scale, mask, softmax</span></span>
<span id="cb64-678"><a href="#cb64-678"></a>        <span class="co"># Note the scaling by C**-0.5 (sqrt(n_embd)) as discussed before</span></span>
<span id="cb64-679"><a href="#cb64-679"></a>        wei <span class="op">=</span> q <span class="op">@</span> k.transpose(<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span> C<span class="op">**-</span><span class="fl">0.5</span>   <span class="co"># (B, T, T)</span></span>
<span id="cb64-680"><a href="#cb64-680"></a>        wei <span class="op">=</span> wei.masked_fill(<span class="va">self</span>.tril[:T, :T] <span class="op">==</span> <span class="dv">0</span>, <span class="bu">float</span>(<span class="st">'-inf'</span>))   <span class="co"># Use dynamic slicing [:T, :T] for flexibility if T &lt; block_size</span></span>
<span id="cb64-681"><a href="#cb64-681"></a>        wei <span class="op">=</span> F.softmax(wei, dim<span class="op">=-</span><span class="dv">1</span>)   <span class="co"># (B, T, T)</span></span>
<span id="cb64-682"><a href="#cb64-682"></a>        wei <span class="op">=</span> <span class="va">self</span>.dropout(wei) <span class="co"># Apply dropout to attention weights</span></span>
<span id="cb64-683"><a href="#cb64-683"></a>        <span class="co"># Weighted aggregation of values</span></span>
<span id="cb64-684"><a href="#cb64-684"></a>        v <span class="op">=</span> <span class="va">self</span>.value(x) <span class="co"># (B,T,head_size)</span></span>
<span id="cb64-685"><a href="#cb64-685"></a>        out <span class="op">=</span> wei <span class="op">@</span> v <span class="co"># (B, T, T) @ (B, T, head_size) -&gt; (B, T, head_size)</span></span>
<span id="cb64-686"><a href="#cb64-686"></a>        <span class="cf">return</span> out</span>
<span id="cb64-687"><a href="#cb64-687"></a><span class="co"># ========================================</span></span>
<span id="cb64-688"><a href="#cb64-688"></a></span>
<span id="cb64-689"><a href="#cb64-689"></a><span class="co"># ===== MULTI-HEAD </span><span class="al">ATTENTION</span><span class="co"> =====</span></span>
<span id="cb64-690"><a href="#cb64-690"></a><span class="kw">class</span> MultiHeadAttention(nn.Module):</span>
<span id="cb64-691"><a href="#cb64-691"></a>    <span class="co">"""Multiple heads of self-attention in parallel."""</span></span>
<span id="cb64-692"><a href="#cb64-692"></a>    </span>
<span id="cb64-693"><a href="#cb64-693"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_heads, head_size):</span>
<span id="cb64-694"><a href="#cb64-694"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb64-695"><a href="#cb64-695"></a>        <span class="va">self</span>.heads <span class="op">=</span> nn.ModuleList([Head(head_size) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_heads)])</span>
<span id="cb64-696"><a href="#cb64-696"></a>        <span class="co"># Linear layer after concatenating heads</span></span>
<span id="cb64-697"><a href="#cb64-697"></a>        <span class="va">self</span>.proj <span class="op">=</span> nn.Linear(n_embd, n_embd) <span class="co"># Projects back to n_embd dimension</span></span>
<span id="cb64-698"><a href="#cb64-698"></a>        <span class="va">self</span>.dropout <span class="op">=</span> nn.Dropout(dropout)</span>
<span id="cb64-699"><a href="#cb64-699"></a></span>
<span id="cb64-700"><a href="#cb64-700"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb64-701"><a href="#cb64-701"></a>        <span class="co"># Compute attention for each head and concatenate results</span></span>
<span id="cb64-702"><a href="#cb64-702"></a>        out <span class="op">=</span> torch.cat([h(x) <span class="cf">for</span> h <span class="kw">in</span> <span class="va">self</span>.heads], dim<span class="op">=-</span><span class="dv">1</span>) <span class="co"># Shape (B, T, num_heads * head_size) = (B, T, n_embd)</span></span>
<span id="cb64-703"><a href="#cb64-703"></a>        <span class="co"># Apply final projection and dropout</span></span>
<span id="cb64-704"><a href="#cb64-704"></a>        out <span class="op">=</span> <span class="va">self</span>.dropout(<span class="va">self</span>.proj(out))</span>
<span id="cb64-705"><a href="#cb64-705"></a>        <span class="cf">return</span> out</span>
<span id="cb64-706"><a href="#cb64-706"></a><span class="co"># ===============================</span></span>
<span id="cb64-707"><a href="#cb64-707"></a></span>
<span id="cb64-708"><a href="#cb64-708"></a><span class="co"># ===== FEED-FORWARD NETWORK =====</span></span>
<span id="cb64-709"><a href="#cb64-709"></a><span class="kw">class</span> FeedFoward(nn.Module):</span>
<span id="cb64-710"><a href="#cb64-710"></a>    <span class="co">"""Simple position-wise feed-forward network with one hidden layer."""</span></span>
<span id="cb64-711"><a href="#cb64-711"></a>    </span>
<span id="cb64-712"><a href="#cb64-712"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n_embd):</span>
<span id="cb64-713"><a href="#cb64-713"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb64-714"><a href="#cb64-714"></a>        <span class="va">self</span>.net <span class="op">=</span> nn.Sequential(</span>
<span id="cb64-715"><a href="#cb64-715"></a>            nn.Linear(n_embd, <span class="dv">4</span> <span class="op">*</span> n_embd),   <span class="co"># Expand dimension (common practice)</span></span>
<span id="cb64-716"><a href="#cb64-716"></a>            nn.ReLU(),                      <span class="co"># Non-linearity</span></span>
<span id="cb64-717"><a href="#cb64-717"></a>            nn.Linear(<span class="dv">4</span> <span class="op">*</span> n_embd, n_embd),   <span class="co"># Project back to original dimension</span></span>
<span id="cb64-718"><a href="#cb64-718"></a>            nn.Dropout(dropout),</span>
<span id="cb64-719"><a href="#cb64-719"></a>        )</span>
<span id="cb64-720"><a href="#cb64-720"></a></span>
<span id="cb64-721"><a href="#cb64-721"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb64-722"><a href="#cb64-722"></a>        <span class="cf">return</span> <span class="va">self</span>.net(x)</span>
<span id="cb64-723"><a href="#cb64-723"></a><span class="co"># ==============================</span></span>
<span id="cb64-724"><a href="#cb64-724"></a></span>
<span id="cb64-725"><a href="#cb64-725"></a><span class="co"># ===== TRANSFORMER BLOCK =====</span></span>
<span id="cb64-726"><a href="#cb64-726"></a><span class="kw">class</span> Block(nn.Module):</span>
<span id="cb64-727"><a href="#cb64-727"></a>    <span class="co">"""Transformer block: communication (attention) followed by computation (FFN)."""</span></span>
<span id="cb64-728"><a href="#cb64-728"></a>    </span>
<span id="cb64-729"><a href="#cb64-729"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n_embd, n_head):</span>
<span id="cb64-730"><a href="#cb64-730"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb64-731"><a href="#cb64-731"></a>        head_size <span class="op">=</span> n_embd <span class="op">//</span> n_head   <span class="co"># Calculate size for each head</span></span>
<span id="cb64-732"><a href="#cb64-732"></a>        <span class="va">self</span>.sa <span class="op">=</span> MultiHeadAttention(n_head, head_size) <span class="co"># Self-Attention layer</span></span>
<span id="cb64-733"><a href="#cb64-733"></a>        <span class="va">self</span>.ffwd <span class="op">=</span> FeedFoward(n_embd) <span class="co"># Feed-Forward layer</span></span>
<span id="cb64-734"><a href="#cb64-734"></a>        <span class="va">self</span>.ln1 <span class="op">=</span> nn.LayerNorm(n_embd) <span class="co"># LayerNorm for Attention input</span></span>
<span id="cb64-735"><a href="#cb64-735"></a>        <span class="va">self</span>.ln2 <span class="op">=</span> nn.LayerNorm(n_embd) <span class="co"># LayerNorm for FFN input</span></span>
<span id="cb64-736"><a href="#cb64-736"></a></span>
<span id="cb64-737"><a href="#cb64-737"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb64-738"><a href="#cb64-738"></a>        <span class="co"># Pre-Normalization variant: Norm -&gt; Sublayer -&gt; Residual</span></span>
<span id="cb64-739"><a href="#cb64-739"></a>        x <span class="op">=</span> x <span class="op">+</span> <span class="va">self</span>.sa(<span class="va">self</span>.ln1(x))  <span class="co"># Attention block</span></span>
<span id="cb64-740"><a href="#cb64-740"></a>        x <span class="op">=</span> x <span class="op">+</span> <span class="va">self</span>.ffwd(<span class="va">self</span>.ln2(x)) <span class="co"># Feed-forward block</span></span>
<span id="cb64-741"><a href="#cb64-741"></a>        <span class="cf">return</span> x</span>
<span id="cb64-742"><a href="#cb64-742"></a><span class="co"># ============================</span></span>
<span id="cb64-743"><a href="#cb64-743"></a></span>
<span id="cb64-744"><a href="#cb64-744"></a><span class="co"># ===== LANGUAGE MODEL =====</span></span>
<span id="cb64-745"><a href="#cb64-745"></a><span class="kw">class</span> BigramLanguageModel(nn.Module):</span>
<span id="cb64-746"><a href="#cb64-746"></a>    <span class="co">"""GPT-like language model using Transformer blocks."""</span></span>
<span id="cb64-747"><a href="#cb64-747"></a>    </span>
<span id="cb64-748"><a href="#cb64-748"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb64-749"><a href="#cb64-749"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb64-750"><a href="#cb64-750"></a>        <span class="co"># Token Embedding Table: Maps character index to embedding vector. (vocab_size, n_embd)</span></span>
<span id="cb64-751"><a href="#cb64-751"></a>        <span class="va">self</span>.token_embedding_table <span class="op">=</span> nn.Embedding(vocab_size, n_embd)</span>
<span id="cb64-752"><a href="#cb64-752"></a>        <span class="co"># Position Embedding Table: Maps position index (0 to block_size-1) to embedding vector. (block_size, n_embd)</span></span>
<span id="cb64-753"><a href="#cb64-753"></a>        <span class="va">self</span>.position_embedding_table <span class="op">=</span> nn.Embedding(block_size, n_embd)</span>
<span id="cb64-754"><a href="#cb64-754"></a>        <span class="co"># Sequence of Transformer Blocks</span></span>
<span id="cb64-755"><a href="#cb64-755"></a>        <span class="va">self</span>.blocks <span class="op">=</span> nn.Sequential(<span class="op">*</span>[Block(n_embd, n_head<span class="op">=</span>n_head) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_layer)])</span>
<span id="cb64-756"><a href="#cb64-756"></a>        <span class="co"># Final Layer Normalization (applied after blocks)</span></span>
<span id="cb64-757"><a href="#cb64-757"></a>        <span class="va">self</span>.ln_f <span class="op">=</span> nn.LayerNorm(n_embd)   <span class="co"># Final layer norm</span></span>
<span id="cb64-758"><a href="#cb64-758"></a>        <span class="co"># Linear Head: Maps final embedding back to vocabulary size to get logits. (n_embd, vocab_size)</span></span>
<span id="cb64-759"><a href="#cb64-759"></a>        <span class="va">self</span>.lm_head <span class="op">=</span> nn.Linear(n_embd, vocab_size)</span>
<span id="cb64-760"><a href="#cb64-760"></a></span>
<span id="cb64-761"><a href="#cb64-761"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, idx, targets<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb64-762"><a href="#cb64-762"></a>        B, T <span class="op">=</span> idx.shape</span>
<span id="cb64-763"><a href="#cb64-763"></a>        </span>
<span id="cb64-764"><a href="#cb64-764"></a>        <span class="co"># Get token embeddings from indices: (B, T) -&gt; (B, T, n_embd)</span></span>
<span id="cb64-765"><a href="#cb64-765"></a>        tok_emb <span class="op">=</span> <span class="va">self</span>.token_embedding_table(idx)</span>
<span id="cb64-766"><a href="#cb64-766"></a>        <span class="co"># Get position embeddings: Create indices 0..T-1, look up embeddings -&gt; (T, n_embd)</span></span>
<span id="cb64-767"><a href="#cb64-767"></a>        pos_emb <span class="op">=</span> <span class="va">self</span>.position_embedding_table(torch.arange(T, device<span class="op">=</span>device))</span>
<span id="cb64-768"><a href="#cb64-768"></a>        <span class="co"># Combine token and position embeddings by addition: (B, T, n_embd). Broadcasting handles the addition.</span></span>
<span id="cb64-769"><a href="#cb64-769"></a>        x <span class="op">=</span> tok_emb <span class="op">+</span> pos_emb   <span class="co"># (B,T,C)</span></span>
<span id="cb64-770"><a href="#cb64-770"></a>        <span class="co"># Pass through Transformer blocks: (B, T, n_embd) -&gt; (B, T, n_embd)</span></span>
<span id="cb64-771"><a href="#cb64-771"></a>        x <span class="op">=</span> <span class="va">self</span>.blocks(x)</span>
<span id="cb64-772"><a href="#cb64-772"></a>        <span class="co"># Apply final LayerNorm</span></span>
<span id="cb64-773"><a href="#cb64-773"></a>        x <span class="op">=</span> <span class="va">self</span>.ln_f(x)</span>
<span id="cb64-774"><a href="#cb64-774"></a>        <span class="co"># Map to vocabulary logits: (B, T, n_embd) -&gt; (B, T, vocab_size)</span></span>
<span id="cb64-775"><a href="#cb64-775"></a>        logits <span class="op">=</span> <span class="va">self</span>.lm_head(x)</span>
<span id="cb64-776"><a href="#cb64-776"></a></span>
<span id="cb64-777"><a href="#cb64-777"></a>        <span class="co"># Calculate loss if targets are provided (same as before)</span></span>
<span id="cb64-778"><a href="#cb64-778"></a>        <span class="cf">if</span> targets <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb64-779"><a href="#cb64-779"></a>            loss <span class="op">=</span> <span class="va">None</span></span>
<span id="cb64-780"><a href="#cb64-780"></a>        <span class="cf">else</span>:</span>
<span id="cb64-781"><a href="#cb64-781"></a>            <span class="co"># Reshape for cross_entropy: (B*T, vocab_size) and (B*T)</span></span>
<span id="cb64-782"><a href="#cb64-782"></a>            B, T, C <span class="op">=</span> logits.shape</span>
<span id="cb64-783"><a href="#cb64-783"></a>            logits <span class="op">=</span> logits.view(B<span class="op">*</span>T, C)</span>
<span id="cb64-784"><a href="#cb64-784"></a>            targets <span class="op">=</span> targets.view(B<span class="op">*</span>T)</span>
<span id="cb64-785"><a href="#cb64-785"></a>            loss <span class="op">=</span> F.cross_entropy(logits, targets)</span>
<span id="cb64-786"><a href="#cb64-786"></a></span>
<span id="cb64-787"><a href="#cb64-787"></a>        <span class="cf">return</span> logits, loss</span>
<span id="cb64-788"><a href="#cb64-788"></a></span>
<span id="cb64-789"><a href="#cb64-789"></a>    <span class="kw">def</span> generate(<span class="va">self</span>, idx, max_new_tokens):</span>
<span id="cb64-790"><a href="#cb64-790"></a>        <span class="co">"""Generate new text given a starting sequence."""</span></span>
<span id="cb64-791"><a href="#cb64-791"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_new_tokens):</span>
<span id="cb64-792"><a href="#cb64-792"></a>            <span class="co"># Crop context `idx` to the last `block_size` tokens. Important as position embeddings only go up to block_size.</span></span>
<span id="cb64-793"><a href="#cb64-793"></a>            idx_cond <span class="op">=</span> idx[:, <span class="op">-</span>block_size:]</span>
<span id="cb64-794"><a href="#cb64-794"></a>            <span class="co"># Get predictions (logits) from the model</span></span>
<span id="cb64-795"><a href="#cb64-795"></a>            logits, loss <span class="op">=</span> <span class="va">self</span>(idx_cond)</span>
<span id="cb64-796"><a href="#cb64-796"></a>            <span class="co"># Focus on the logits for the *last* time step: (B, C)</span></span>
<span id="cb64-797"><a href="#cb64-797"></a>            logits <span class="op">=</span> logits[:, <span class="op">-</span><span class="dv">1</span>, :]</span>
<span id="cb64-798"><a href="#cb64-798"></a>            <span class="co"># Convert logits to probabilities via softmax</span></span>
<span id="cb64-799"><a href="#cb64-799"></a>            probs <span class="op">=</span> F.softmax(logits, dim<span class="op">=-</span><span class="dv">1</span>)   <span class="co"># (B, C)</span></span>
<span id="cb64-800"><a href="#cb64-800"></a>            <span class="co"># Sample next token index from the probability distribution</span></span>
<span id="cb64-801"><a href="#cb64-801"></a>            idx_next <span class="op">=</span> torch.multinomial(probs, num_samples<span class="op">=</span><span class="dv">1</span>)   <span class="co"># (B, 1)</span></span>
<span id="cb64-802"><a href="#cb64-802"></a>            <span class="co"># Append the sampled index to the running sequence</span></span>
<span id="cb64-803"><a href="#cb64-803"></a>            idx <span class="op">=</span> torch.cat((idx, idx_next), dim<span class="op">=</span><span class="dv">1</span>)   <span class="co"># (B, T+1)</span></span>
<span id="cb64-804"><a href="#cb64-804"></a>        <span class="cf">return</span> idx</span>
<span id="cb64-805"><a href="#cb64-805"></a><span class="co"># =========================</span></span>
<span id="cb64-806"><a href="#cb64-806"></a></span>
<span id="cb64-807"><a href="#cb64-807"></a><span class="co"># ===== MODEL INITIALIZATION AND TRAINING =====</span></span>
<span id="cb64-808"><a href="#cb64-808"></a><span class="co"># Create model instance and move it to the selected device</span></span>
<span id="cb64-809"><a href="#cb64-809"></a>model <span class="op">=</span> BigramLanguageModel()</span>
<span id="cb64-810"><a href="#cb64-810"></a>m <span class="op">=</span> model.to(device)</span>
<span id="cb64-811"><a href="#cb64-811"></a><span class="co"># Print number of parameters (useful for understanding model size)</span></span>
<span id="cb64-812"><a href="#cb64-812"></a><span class="bu">print</span>(<span class="bu">sum</span>(p.numel() <span class="cf">for</span> p <span class="kw">in</span> m.parameters())<span class="op">/</span><span class="fl">1e6</span>, <span class="st">'M parameters'</span>) <span class="co"># Calculate and print M parameters</span></span>
<span id="cb64-813"><a href="#cb64-813"></a></span>
<span id="cb64-814"><a href="#cb64-814"></a><span class="co"># Create optimizer (AdamW again)</span></span>
<span id="cb64-815"><a href="#cb64-815"></a>optimizer <span class="op">=</span> torch.optim.AdamW(model.parameters(), lr<span class="op">=</span>learning_rate)</span>
<span id="cb64-816"><a href="#cb64-816"></a></span>
<span id="cb64-817"><a href="#cb64-817"></a><span class="co"># Training loop</span></span>
<span id="cb64-818"><a href="#cb64-818"></a><span class="cf">for</span> <span class="bu">iter</span> <span class="kw">in</span> <span class="bu">range</span>(max_iters):</span>
<span id="cb64-819"><a href="#cb64-819"></a>    <span class="co"># Evaluate loss periodically</span></span>
<span id="cb64-820"><a href="#cb64-820"></a>    <span class="cf">if</span> <span class="bu">iter</span> <span class="op">%</span> eval_interval <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> <span class="bu">iter</span> <span class="op">==</span> max_iters <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb64-821"><a href="#cb64-821"></a>        losses <span class="op">=</span> estimate_loss() <span class="co"># Get train/val loss using the helper function</span></span>
<span id="cb64-822"><a href="#cb64-822"></a>        <span class="bu">print</span>(<span class="ss">f"step </span><span class="sc">{</span><span class="bu">iter</span><span class="sc">}</span><span class="ss">: train loss </span><span class="sc">{</span>losses[<span class="st">'train'</span>]<span class="sc">:.4f}</span><span class="ss">, val loss </span><span class="sc">{</span>losses[<span class="st">'val'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>) <span class="co"># Print losses</span></span>
<span id="cb64-823"><a href="#cb64-823"></a></span>
<span id="cb64-824"><a href="#cb64-824"></a>    <span class="co"># Sample a batch of data</span></span>
<span id="cb64-825"><a href="#cb64-825"></a>    xb, yb <span class="op">=</span> get_batch(<span class="st">'train'</span>)</span>
<span id="cb64-826"><a href="#cb64-826"></a></span>
<span id="cb64-827"><a href="#cb64-827"></a>    <span class="co"># Forward pass: Evaluate loss</span></span>
<span id="cb64-828"><a href="#cb64-828"></a>    logits, loss <span class="op">=</span> model(xb, yb)</span>
<span id="cb64-829"><a href="#cb64-829"></a>    <span class="co"># Backward pass: Calculate gradients</span></span>
<span id="cb64-830"><a href="#cb64-830"></a>    optimizer.zero_grad(set_to_none<span class="op">=</span><span class="va">True</span>) <span class="co"># Zero gradients</span></span>
<span id="cb64-831"><a href="#cb64-831"></a>    loss.backward() <span class="co"># Backpropagation</span></span>
<span id="cb64-832"><a href="#cb64-832"></a>    <span class="co"># Update parameters</span></span>
<span id="cb64-833"><a href="#cb64-833"></a>    optimizer.step() <span class="co"># Optimizer step</span></span>
<span id="cb64-834"><a href="#cb64-834"></a></span>
<span id="cb64-835"><a href="#cb64-835"></a><span class="co"># Generate text from the trained model</span></span>
<span id="cb64-836"><a href="#cb64-836"></a>context <span class="op">=</span> torch.zeros((<span class="dv">1</span>, <span class="dv">1</span>), dtype<span class="op">=</span>torch.<span class="bu">long</span>, device<span class="op">=</span>device) <span class="co"># Starting context: [[0]]</span></span>
<span id="cb64-837"><a href="#cb64-837"></a><span class="bu">print</span>(decode(m.generate(context, max_new_tokens<span class="op">=</span><span class="dv">2000</span>)[<span class="dv">0</span>].tolist()))</span>
<span id="cb64-838"><a href="#cb64-838"></a><span class="co"># ============================================</span></span>
<span id="cb64-839"><a href="#cb64-839"></a><span class="in">```</span></span>
<span id="cb64-840"><a href="#cb64-840"></a></span>
<span id="cb64-841"><a href="#cb64-841"></a></span>
<span id="cb64-842"><a href="#cb64-842"></a>::: {.callout-note}</span>
<span id="cb64-843"><a href="#cb64-843"></a>With 5000 iterations, the model is able to generate text that is similar to the training text.</span>
<span id="cb64-844"><a href="#cb64-844"></a>:::</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>